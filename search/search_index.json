{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Info</p> <p>Please keep in mind that this course is still a work in progress. If you notice anything incorrect, confusing, or missing, feel free to open an issue on GitHub: https://github.com/CL0001/learn-cplusplus/issues</p> <p>Welcome! This course is my attempt to share useful knowledge about C++.</p> <p>I created this course because C++ was the first programming language I learned in school, but unfortunately, it was taught in a way that made it seem terrible. We were using a very old version of C++, and the teaching style felt like, \"This is how it's always been done, so this is how we'll keep doing it.\" It was essentially the old \"C with Classes\" style of programming \u2014 the way C++ was first introduced \u2014 and almost everyone hated it. I didn\u2019t understand much, and I certainly didn\u2019t learn enough to feel confident with the language; I was completely lost.</p> <p>Disappointed, I switched to Python because I heard it was easier to learn and more versatile. I started learning programming on my own, combining the little I grasped from school with online tutorials and personal projects. Eventually, I became more interested in systems programming, especially game development and building my own game engines. That's when I realized I needed to return to C++. Unreal Engine, my engine of choice, relies heavily on C++ for writing game logic, whereas engines like Unity are built on C++ but use other languages, such as C#, for that purpose. Furthermore, it highlights the limitations of the Blueprint system, which, regrettably, is not a 'jack-of-all-trades' for every task. Low-level control is essential for performance and flexibility, something Python and similar languages didn't offer. I could have used Unity for that purpose, but I was genuinely interested in gathering knowledge and building game engine myself, and that's where C++ truly shines.</p> <p>When I returned to C++, I found it wasn't the messy, outdated language I'd remembered. Modern C++ boasts powerful, well-designed features and can actually be enjoyable. Yet, this understanding only came after many frustrating hours of self-study. As someone who had only used high-level languages like Python, even fundamental low-level concepts felt entirely new to me. My goal was to truly understand how computers work \"under the hood,\" rather than just depending on libraries for everything.</p> <p>After struggling with confusing resources and piecing together knowledge over the years, I realized that maybe others were going through the same thing. That's why I decided to write this course: a \"wannabe professional but friendly\" guide for beginners. It starts with the fundamentals and goes all the way through to building a complete game without a pre-built engine.</p> <p>I hope anyone reading this finds the journey enjoyable and learns something new along the way.</p>"},{"location":"00%20Table%20of%20Contents/","title":"00 Table of Contents","text":"<pre>\n\u251c\u2500\u2500 01 Introduction/\n\u2502   \u251c\u2500\u2500 Environment Setup/\n\u2502   \u2502   \u251c\u2500\u2500 Recommended Setup for Windows\n\u2502   \u2502   \u251c\u2500\u2500 Recommended Setup for macOS\n\u2502   \u2502   \u2514\u2500\u2500 Alternative Setup via Web\n\u2502   \u251c\u2500\u2500 How C++ Works/\n\u2502   \u2502   \u251c\u2500\u2500 Entry Point\n\u2502   \u2502   \u251c\u2500\u2500 Preprocessor Directives\n\u2502   \u2502   \u251c\u2500\u2500 Compiler\n\u2502   \u2502   \u2514\u2500\u2500 Linker\n\u2502   \u251c\u2500\u2500 Header Files/\n\u2502   \u2502   \u251c\u2500\u2500 Header Guard\n\u2502   \u2502   \u2514\u2500\u2500 Header Search\n\u2502   \u251c\u2500\u2500 Code Comments/\n\u2502   \u2502   \u2514\u2500\u2500 Types of Comments\n\u2502   \u251c\u2500\u2500 Data Types and Variables/\n\u2502   \u2502   \u251c\u2500\u2500 Data Types and Variables\n\u2502   \u2502   \u251c\u2500\u2500 ASCII\n\u2502   \u2502   \u251c\u2500\u2500 Declaring and Naming Variables\n\u2502   \u2502   \u2514\u2500\u2500 Constants\n\u2502   \u251c\u2500\u2500 Terminal Input and Output\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 02 Control Flow/\n\u2502   \u251c\u2500\u2500 If Statements\n\u2502   \u251c\u2500\u2500 Switch Statements\n\u2502   \u251c\u2500\u2500 Go To Statements\n\u2502   \u251c\u2500\u2500 Loops/\n\u2502   \u2502   \u251c\u2500\u2500 While Loops\n\u2502   \u2502   \u251c\u2500\u2500 For Loops\n\u2502   \u2502   \u2514\u2500\u2500 Nested Loops\n\u2502   \u251c\u2500\u2500 Break and Continue\n\u2502   \u251c\u2500\u2500 Shortened Notations\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 03 Operators/\n\u2502   \u251c\u2500\u2500 Comparison Operators\n\u2502   \u251c\u2500\u2500 Logical Operators\n\u2502   \u251c\u2500\u2500 Arithmetic Operators/\n\u2502   \u2502   \u2514\u2500\u2500 Shortened Notations\n\u2502   \u251c\u2500\u2500 Operator Evaluation Order\n\u2502   \u251c\u2500\u2500 Bitwise Operators/\n\u2502   \u2502   \u251c\u2500\u2500 Binary Representation\n\u2502   \u2502   \u251c\u2500\u2500 Conversion Between Decimal and Binary Systems\n\u2502   \u2502   \u251c\u2500\u2500 Conversion Between Decimal and Hexadecimal Systems\n\u2502   \u2502   \u251c\u2500\u2500 Conversion Between Decimal and Octal Systems\n\u2502   \u2502   \u251c\u2500\u2500 Examining Memory Representation in Practice\n\u2502   \u2502   \u251c\u2500\u2500 Bitwise Shift Operators\n\u2502   \u2502   \u251c\u2500\u2500 Bitwise Logic Operators/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Bitwise AND\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Bitwise OR\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Bitwise XOR\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Bitwise NOT\n\u2502   \u2502   \u2514\u2500\u2500 Writing Binary, Hexadecimal and Octal Values in C++\n\u2502   \u251c\u2500\u2500 Ternary Operator\n\u2502   \u251c\u2500\u2500 Operator Overloading\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 04 Functions/\n\u2502   \u251c\u2500\u2500 Function Creation\n\u2502   \u251c\u2500\u2500 Return Values/\n\u2502   \u2502   \u2514\u2500\u2500 Mandatory Return Values\n\u2502   \u251c\u2500\u2500 Multiple Return Values\n\u2502   \u251c\u2500\u2500 Parameter List\n\u2502   \u251c\u2500\u2500 Function Declaration vs. Definition\n\u2502   \u251c\u2500\u2500 Function Overloading\n\u2502   \u251c\u2500\u2500 Inline Functions\n\u2502   \u251c\u2500\u2500 Recursion\n\u2502   \u251c\u2500\u2500 Lambdas/\n\u2502   \u2502   \u251c\u2500\u2500 When to Use Lambdas\n\u2502   \u2502   \u2514\u2500\u2500 Lambda Use Case\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 05 Data Types/\n\u2502   \u251c\u2500\u2500 Static and Strong Typing\n\u2502   \u251c\u2500\u2500 Primitive Data Types/\n\u2502   \u2502   \u251c\u2500\u2500 Standard Integer Types\n\u2502   \u2502   \u251c\u2500\u2500 Fixed-Width Integer Types\n\u2502   \u2502   \u251c\u2500\u2500 Unsigned Integers\n\u2502   \u2502   \u251c\u2500\u2500 Floating-Point Types\n\u2502   \u2502   \u2514\u2500\u2500 Character Types\n\u2502   \u251c\u2500\u2500 Automatic Type Inference\n\u2502   \u251c\u2500\u2500 Determining the Byte Size of Variables\n\u2502   \u251c\u2500\u2500 Type Casting/\n\u2502   \u2502   \u251c\u2500\u2500 Conversions\n\u2502   \u2502   \u251c\u2500\u2500 C-Style Cast\n\u2502   \u2502   \u251c\u2500\u2500 C++ Casts/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Static Cast\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Dynamic Cast\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Constant Cast\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Reinterpret Cast\n\u2502   \u2502   \u2514\u2500\u2500 When to Cast\n\u2502   \u251c\u2500\u2500 Constants and Compile-Time Constructs/\n\u2502   \u2502   \u251c\u2500\u2500 Constexpr\n\u2502   \u2502   \u2514\u2500\u2500 Consteval and Constinit\n\u2502   \u251c\u2500\u2500 Padding and Alignment/\n\u2502   \u2502   \u2514\u2500\u2500 Difference Between Alignment and Byte Size\n\u2502   \u251c\u2500\u2500 Type Punning\n\u2502   \u251c\u2500\u2500 Dynamic Typing/\n\u2502   \u2502   \u251c\u2500\u2500 Optional Data\n\u2502   \u2502   \u251c\u2500\u2500 Multi-Type Data Holder\n\u2502   \u2502   \u2514\u2500\u2500 Any Data Type\n\u2502   \u251c\u2500\u2500 Run-Time Type Identification/\n\u2502   \u2502   \u251c\u2500\u2500 Type ID\n\u2502   \u2502   \u2514\u2500\u2500 Considerations When Using RTTI\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 06 Pointers and References/\n\u2502   \u251c\u2500\u2500 Memory Allocation\n\u2502   \u251c\u2500\u2500 Object Lifetimes\n\u2502   \u251c\u2500\u2500 Raw Pointers/\n\u2502   \u2502   \u251c\u2500\u2500 Declaring Pointers\n\u2502   \u2502   \u251c\u2500\u2500 Null Pointers\n\u2502   \u2502   \u251c\u2500\u2500 Accessing the Memory Address of a Variable\n\u2502   \u2502   \u251c\u2500\u2500 Dereferencing a Pointer\n\u2502   \u2502   \u251c\u2500\u2500 Dynamic Memory Allocation/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Initializing Heap Memory\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Heap Memory Management\n\u2502   \u2502   \u251c\u2500\u2500 Constant Pointers/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Pointer to Constant\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Constant Pointer\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Constant Pointer to Constant\n\u2502   \u2502   \u251c\u2500\u2500 Pointer to Pointer\n\u2502   \u2502   \u251c\u2500\u2500 Pointer Safety/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Dangling Pointers\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Memory Leaks\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Buffer Overflows\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Pointer Aliasing and Ownership\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Preventions\n\u2502   \u251c\u2500\u2500 Pointer Arithmetic\n\u2502   \u251c\u2500\u2500 References/\n\u2502   \u2502   \u251c\u2500\u2500 Reference vs. Address-of Operator\n\u2502   \u2502   \u251c\u2500\u2500 Pass by Value vs. Pass by Reference\n\u2502   \u2502   \u251c\u2500\u2500 When to Pass by Reference\n\u2502   \u251c\u2500\u2500 Function Pointer\n\u2502   \u251c\u2500\u2500 Where to Use Function Pointers\n\u2502   \u251c\u2500\u2500 Lvalues and Rvalues/\n\u2502   \u2502   \u251c\u2500\u2500 Lvalue Reference\n\u2502   \u2502   \u251c\u2500\u2500 Rvalue Reference\n\u2502   \u251c\u2500\u2500 Move Semantics/\n\u2502   \u2502   \u251c\u2500\u2500 Standard Move Function\n\u2502   \u2502   \u251c\u2500\u2500 Move Assignment Operator\n\u2502   \u251c\u2500\u2500 Smart Pointers/\n\u2502   \u2502   \u251c\u2500\u2500 Unique Pointer\n\u2502   \u2502   \u251c\u2500\u2500 Shared Pointer\n\u2502   \u2502   \u251c\u2500\u2500 Weak Pointer\n\u2502   \u2502   \u251c\u2500\u2500 When to Use Smart Pointers\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 07 Collections of Data/\n\u2502   \u251c\u2500\u2500 C-Style Arrays/\n\u2502   \u2502   \u251c\u2500\u2500 Access and Modify Elements\n\u2502   \u2502   \u251c\u2500\u2500 Iterate Over Arrays\n\u2502   \u2502   \u251c\u2500\u2500 Pointer Arithmetic on Arrays\n\u2502   \u2502   \u251c\u2500\u2500 Array Heap Allocation\n\u2502   \u2502   \u251c\u2500\u2500 Multidimensional Arrays/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Dynamically Allocate a 2D Array\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Deallocate a 2D Array\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Access Multidimensional Arrays\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Optimize Memory Access for Multidimensional Arrays\n\u2502   \u251c\u2500\u2500 Strings/\n\u2502   \u2502   \u251c\u2500\u2500 C-Style Strings\n\u2502   \u2502   \u251c\u2500\u2500 Modifiable C-Style Strings\n\u2502   \u2502   \u251c\u2500\u2500 C++ Strings\n\u2502   \u2502   \u251c\u2500\u2500 String Concatenation\n\u2502   \u2502   \u251c\u2500\u2500 String Literals/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Raw String Literals\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Unicode String Literals\n\u2502   \u2502   \u251c\u2500\u2500 Small Strings\n\u2502   \u2502   \u251c\u2500\u2500 Optimize Strings in C++/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Substring Operations Overhead\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 String Views\n\u2502   \u251c\u2500\u2500 C++ Static Array\n\u2502   \u251c\u2500\u2500 Dynamic Array/\n\u2502   \u2502   \u251c\u2500\u2500 Vector Optimization\n\u2502   \u251c\u2500\u2500 HashMap/\n\u2502   \u2502   \u251c\u2500\u2500 Hashing Function\n\u2502   \u2502   \u251c\u2500\u2500 Index Operator\n\u2502   \u251c\u2500\u2500 Linked List\n\u2502   \u251c\u2500\u2500 Stack and Queue\n\u2502   \u251c\u2500\u2500 Iterators/\n\u2502   \u2502   \u251c\u2500\u2500 Range-Based For Loops\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 08 User Defined Types\n\u2502   \u251c\u2500\u2500 Structs\n\u2502   \u251c\u2500\u2500 Unions\n\u2502   \u251c\u2500\u2500 Enums\n\u2502   \u251c\u2500\u2500 Classes/\n\u2502   \u2502   \u251c\u2500\u2500 Static Inside Classe\n\u2502   \u2502   \u251c\u2500\u2500 Static Outside Classe\n\u2502   \u2502   \u251c\u2500\u2500 Getters and Setters\n\u2502   \u2502   \u251c\u2500\u2500 Constant Member Functions\n\u2502   \u2502   \u251c\u2500\u2500 Constructors/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Member Initializer List\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Copy Constructor\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Copy Assignment Operator\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Move Constructor\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Move Assignment Operator\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Explicit Constructor\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Rule of Zero and Five\n\u2502   \u2502   \u251c\u2500\u2500 Destructors\n\u2502   \u2502   \u251c\u2500\u2500 Arrow Operator\n\u2502   \u2502   \u251c\u2500\u2500 Current Instance Pointer\n\u2502   \u251c\u2500\u2500 Inheritance and Polymorphism\n\u2502   \u251c\u2500\u2500 Singletons\n\u2502   \u2514\u2500\u2500 Exercises\n\nWorking on more...\n</pre>"},{"location":"01%20Introduction/","title":"01 Introduction","text":"<p>We pick C++ as the language for learning computer science because, for one, it's an incredibly powerful and versatile tool. C++ is used to build everything from command-line utilities and desktop apps to real-time systems and high-performance games. It's the language behind major AAA titles like Counter-Strike, Fortnite, and the Warcraft series. Game engines like Unreal Engine are built on it, and even modern operating systems\u2014including parts of Windows\u2014rely on C++ under the hood.</p> <p>Even if you're not aiming for game development or systems programming, learning C++ gives you a solid foundation in how computers actually work. This low-level understanding transfers to almost every other language or tech stack you\u2019ll encounter later.</p> <p>One of the big reasons C++ remains so relevant is its performance and portability. It runs natively on everything\u2014Windows, Linux, macOS, embedded devices, mobile platforms, game consoles\u2014you name it. It supports both 32-bit and 64-bit architectures and compiles directly to machine code, which means it can be very fast when written well.</p> <p>But here\u2019s the flip side: C++ gives you a lot of control\u2014especially over memory\u2014and that means it\u2019s also easier to shoot yourself in the foot. Sloppy code can lead to memory leaks, crashes, or bugs that are really tricky to track down. It\u2019s a language that rewards careful thinking and clean design.</p> <p>C++ is built on top of C, one of the oldest and most influential programming languages still in use today. In fact, a lot of valid C code is also valid C++. But C++ goes further, introducing features that help you write safer, more maintainable, and modern code\u2014without losing the performance edge that made C famous.</p> <p>In this book, we\u2019ll explore C++ from the ground up. When it makes sense, we\u2019ll also dip into some C concepts\u2014especially when we want to get closer to the hardware or squeeze out maximum performance.</p>"},{"location":"01%20Introduction/#environment-setup","title":"Environment Setup","text":"<p>To write and run C++ code on your computer, you need to install two essential components:</p> <ol> <li>Compiler: A program that translates your human-readable C++ source code\u2014essentially just plain text\u2014into machine-readable binary.    It acts as a bridge between your code and the hardware, enabling the CPU to execute your instructions.</li> <li>Code Editor or IDE (Integrated Development Environment): A tool that helps you write, edit, and manage your code.    Most IDEs also offer features like syntax highlighting, auto-completion, and debugging tools.</li> </ol>"},{"location":"01%20Introduction/#recommended-setup-for-windows","title":"Recommended Setup for Windows","text":"<p>The easiest way to get started with C++ on Windows is by using Microsoft Visual Studio. It\u2019s a fully featured IDE that comes preconfigured for C++ development and includes the MSVC compiler, so there's no need to install it separately like with other solutions\u2014it provides everything you need in a single package.</p> <p>Installation Steps</p> <ol> <li>Download Visual Studio Community Edition from the microsoft official website or Microsoft Store</li> <li>During installation, select \"Desktop development with C++\" to include the required compiler and tools.</li> <li>After installation, launch Visual Studio and follow these steps:<ol> <li>Click \"Create a new project\"</li> <li>In the project language filter, choose C++</li> <li>Select \"Console App\"</li> <li>Enter a your desired project name</li> <li>Choose a location for the project (default is usually <code>C:\\Users\\Username\\source\\repos</code>)</li> <li>Click Create</li> </ol> </li> <li>To test your setup, run the Console App sample program by clicking the green arrow button at the top center of the screen.</li> </ol> <p>If a terminal window appears showing \"Hello World!\", your installation is complete and working correctly.</p> <p>Tip</p> <p>To add a new file in Visual Studio, right-click on \"Source Files\" or \"Header Files\" in the \"Solution Explorer\", depending on what kind of file you need. Then choose \"Add\" \u2192 \"New Item\". Give your file any name you like, such as <code>something_like.cpp</code>.</p> <p>Keep in mind that \"Source Files\" and \"Header Files\" are just filters in the Solution Explorer\u2014they don\u2019t represent actual folders on your system. All the files you add will be placed in the same physical project directory on disk.</p> <p>Tip</p> <p>For a more advanced C++ development experience in Visual Studio, consider using Visual Assist. It enhances code navigation, refactoring, and auto-completion. It's not free (offers a 1-month trial or is free with a student ID), but it\u2019s highly recommended for serious C++ work. More info: https://www.wholetomato.com/</p>"},{"location":"01%20Introduction/#recommended-setup-for-macos","title":"Recommended Setup for macOS","text":"<p>The easiest way to get started with C++ on macOS is by using Xcode, Apple\u2019s official IDE. It includes the Clang compiler and provides everything you need to build and run C++ command-line programs\u2014all in one package.</p> <p>Installation Steps</p> <ol> <li>Open the Mac App Store and download Xcode.</li> <li>Once installed, launch Xcode.</li> <li>Follow these steps to create a C++ project:<ol> <li>Click \"Create a new Xcode project\"</li> <li>Under macOS, select \"Command Line Tool\" and click Next</li> <li>Enter a product name (e.g., <code>HelloCpp</code>)</li> <li>Set Language to C++</li> <li>Click \"Next\"</li> <li>Choose a location to save your project and click Create</li> </ol> </li> <li>To test the installation, run the sample code that is included in the project by clicking the \u201cRun\u201d button located at the top-left corner of the Xcode window.</li> </ol> <p>Once you see \"Hello, World!\" output in the console, your setup is complete.</p> <p>Tip</p> <p>If the console is not visible, go to View \u2192 Debug Area \u2192 Activate Console.</p>"},{"location":"01%20Introduction/#alternative-setup-via-web","title":"Alternative Setup via Web","text":"<p>If your computer is too slow to run heavy IDEs\u2014or if you simply don\u2019t want to install anything\u2014you can use an online C++ compiler to get started quickly. This is a convenient way to write and run code directly in your browser.</p> <p>However, keep in mind that most online compilers have limitations. They often don\u2019t support the latest C++ standards (such as C++17 or C++20), and they usually lack access to the local file system, meaning file input/output won\u2019t work as expected. Because of this, some features covered later here won\u2019t be usable in a web-based environment.</p> <p>One beginner-friendly example can be found here: https://www.programiz.com/cpp-programming/online-compiler/</p>"},{"location":"01%20Introduction/#how-c-works","title":"How C++ Works","text":"<p>Now that the setup is behind us\u2014and we've touched on why learning a lower-level language like C++ builds a solid understanding of how computers operate\u2014let's start exploring how a C++ program actually comes together under the hood.</p> <p>The files we write in C++ are just plain text, but they\u2019re typically separated by purpose. Source files\u2014usually with a <code>.cpp</code> extension though you might also see <code>.cc</code> or <code>.cxx</code>\u2014contain the actual logic and code of your program. Header files\u2014commonly ending in <code>.h</code>, <code>.hh</code>, or .<code>hpp</code>\u2014are used to declare functions, classes, and variables that can be shared across multiple source files.</p> <p>We\u2019ll go through all of these concepts\u2014like functions, classes, and variables\u2014step by step in the upcoming chapters. For now, just think of them as different parts of your program: some that do things, and others that describe what exists. Don\u2019t worry if words like \u201cdeclare\u201d or \u201cvariable\u201d sound unfamiliar\u2014we\u2019ll explain everything clearly as we go.</p> <p>Note</p> <p>In C++, file extensions are just a convention\u2014they don't affect how the compiler interprets the code. There are some common extensions, but technically, you could name your file anything. What matters is how the file is treated by the compiler. As long as you tell the compiler that it's a C++ file, it will process it correctly.</p> <p>To actually run on your computer, these files must be translated into a binary file that your machine can understand. This binary is usually either an executable like a <code>.exe</code> file on Windows or a library, which contains pre-written, pre-compiled code that can be linked to an executable such as <code>.lib</code> or <code>.dll</code> files. We\u2019ll explore these library formats and the linking process in more detail in later chapters.</p> <p>The next important thing to understand is that the compilation process\u2014translating human-readable code into machine-executable instructions\u2014involves two key settings: project configuration and target platform.</p> <p>Project configuration determines how the compiled binary behaves. The two most common options are:</p> Configuration Description Use Case Debug Includes extra information like error messages and debugging symbols. Ideal during development Release Optimized for speed; debugging info is removed. For final builds <p>Target platform refers to the system architecture your program is intended to run on, such as x86 (32-bit) or x64 (64-bit).</p> <p>Note</p> <p>Programs must be compiled separately for each target platform because a binary built for Windows will not run on macOS or Linux, and vice versa. Similarly, the architecture matters: a 32-bit program can generally run on a 64-bit system, but a 64-bit program cannot run on a 32-bit system.</p>"},{"location":"01%20Introduction/#entry-point","title":"Entry Point","text":"<p>Every C++ program needs an entry point\u2014the place where execution begins. There must be exactly one entry point, or the program won\u2019t compile. Without it, your program has no defined starting point.</p> <p>You\u2019ve already seen this entry point during setup, where a sample file was created for you.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>Note</p> <p><code>main.cpp</code> is the standard filename for the entry point of a C++ program.</p> <p>In this example, the entry point is the main function on line 3. This is where the program starts executing after it is launched. Everything inside the curly braces is the function body, which contains the instructions that run when the program begins.</p> <p>The <code>main</code> function is a special case in C++. Even though it declares that it returns an <code>int</code>, you might not see a return statement\u2014don\u2019t worry, we\u2019ll cover this in more detail later. Just remember that <code>main</code> is unique in this regard, and we\u2019ll emphasize why as we go along. This happens because modern compilers automatically insert <code>return 0;</code> at the end of <code>main</code> if you don\u2019t include it yourself. This behavior is specific to <code>main</code> and does not apply to other functions.</p>"},{"location":"01%20Introduction/#preprocessor-directives","title":"Preprocessor Directives","text":"<p>In C++, any line that begins with a <code>#</code> is called a preprocessor directive. These are instructions handled before actual compilation begins\u2014hence the name preprocessor. They aren\u2019t part of the C++ language itself but are understood by the preprocessor, which runs just before the compiler.</p> <p>You\u2019ve also already seen an example of a preprocessor directive in our earlier sample.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>The line <code>#include &lt;iostream&gt;</code> tells the preprocessor to find the file named <code>iostream</code> and copy-paste its entire contents into this file at that exact location. This makes all the functionality defined in <code>&lt;iostream&gt;</code> \u2014 such as input/output using <code>std::cout</code> (console output), <code>std::cin</code> (console input), and <code>std::endl</code> (newline) \u2014 available in our program.</p>"},{"location":"01%20Introduction/#compiler","title":"Compiler","text":"<p>The C++ compiler transforms your human-readable code into a format that computers can understand, but it does so in several intermediate steps.</p> <p>First, it creates intermediate files\u2014typically with a <code>.obj</code> extension on Windows or <code>.o</code> on macOS/Linux. These files are often found in your project directory under folders like x64 \u2192 Debug.</p> <p>During compilation, the compiler begins by processing all preprocessor directives (lines starting with #). Then, it tokenizes and parses your code. Parsing builds an internal structure called an Abstract Syntax Tree (AST), which represents the logic and meaning of your program.</p> <p>Once the AST is ready, the compiler generates machine code based on your original source file.</p> <p>Here\u2019s an example of what a raw <code>.obj</code> file might look like (shown as hexadecimal bytes).</p> main.obj<pre><code>00000000 64 86 5A 00 8B C5 06 68 87 EC 00 00 EF 01 00 00 d.Z....h..\n00000010 00 00 00 00 2E 64 72 65 63 74 76 65 00 00 00 00 .....drectve....\n00000020 00 00 00 00 90 01 00 00 24 0E 00 00 00 00 00 00 ....$.......\n00000030 00 00 00 00 00 00 00 00 00 0A 00 2E 64 65 62 00 ....... ..deb\n00000040 75 67 24 53 00 00 00 00 00 00 00 00 28 A6 00 00 ug$S........(..\n00000050 B4 0F 00 00 DC 85 00 00 00 00 00 00 04 00 00 00 ............\n00000060 40 00 10 42 2E 6D 73 76 63 6A 6D 63 00 00 00 00 @..B.msvcjmc....\n00000070 00 00 00 00 6A 00 00 00 24 BE 00 00 00 00 00 00 ....j...$.......\n00000080 00 00 00 00 00 00 00 00 40 00 10 C0 2E 74 65 78 ........@...tex\n\n... (truncated for brevity)\n</code></pre> main.asm<pre><code>.LC0:\n        .string \"Hello World!\"\nmain:\n        push    rbp\n        mov     rbp, rsp\n        mov     esi, OFFSET FLAT:.LC0\n        mov     edi, OFFSET FLAT:std::cout\n        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp;, char const*)\n        mov     esi, OFFSET FLAT:std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp; std::endl&lt;char, std::char_traits&lt;char&gt;&gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp;)\n        mov     rdi, rax\n        call    std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))\n        mov     eax, 0\n        pop     rbp\n        ret\n\n... (truncated for brevity)\n</code></pre> <p>You don\u2019t need to understand these low-level details right now\u2014they\u2019re just examples of how code is represented internally at different stages of compilation. Also, note that these examples don\u2019t directly correspond to each other, as they are just snippets from the actual full files.</p> <p>Tip</p> <p>You can easily explore the assembly output of nearly any code you write using different compilers at this website:  https://godbolt.org/</p> <p>Each source file is refered to as a translation unit. The compiler processes each translation unit independently, producing an intermediate object file. When your program consists of multiple source files, these translation units are later linked together to create the final executable or library. If your entire program is in a single source file, then there will be only one translation unit.</p>"},{"location":"01%20Introduction/#linker","title":"Linker","text":"<p>After the compiler processes each translation unit into object files, the linker\u2019s job is to bring everything together into a final executable. Without linking, each translation unit only knows about its own contents, so the program can\u2019t run as a whole.</p> <p>The linker connects all the pieces by resolving function calls, variables, and other symbols across translation units. Even if your program consists of a single translation unit, the linker still plays an important role\u2014it locates the program\u2019s entry point so the execution knows where to begin.</p> <p>Below is an example illustrating a common linker error.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint Multiply(int a, int b); // Function declaration\n// Missing function definition \n\nint main() {\n    std::cout &lt;&lt; Multiply(3, 7) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Linker Error: unresolved external symbol\n</code></pre> <p>Linker errors only appear when the program is compiled and linked as a whole, since the linker\u2019s job is to combine all parts together. Although each individual source file may compile successfully on its own, during the linking stage you might encounter a common error: unresolved external symbol.</p> <p>That happens because while the function declaration exists, the function definition (body) is missing. The linker is trying to connect the <code>Multiply</code> call to actual code, but it can\u2019t find it\u2014so it fails. You can fix the error by simply providing the function definition.</p> <pre><code>#include &lt;iostream&gt;\n\nint Multiply(int a, int b) {\n    return a * b;\n}\n\nint main() {\n    std::cout &lt;&lt; \"Multiplication: \" &lt;&lt; Multiply(3, 7) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Multiplication: 21\n</code></pre> <p>This might seem like a simple mistake, but when working on a large project with dozens of translation units and external libraries, it\u2019s surprisingly easy to overlook\u2014and linker errors like this can be tricky to debug.</p>"},{"location":"01%20Introduction/#header-files","title":"Header Files","text":"<p>In C++, header files are one of the two main types of files. The first are the source files, which we\u2019ve been working with so far. This file contains the actual code and logic of your program. It gets compiled into an object file, forming a translation unit.</p> <p>The second type is the header file. You\u2019ve already seen an example of one in the sample your IDE generated.</p> main.cpp<pre><code>#include &lt;iostream&gt; // header file\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>Header files are used mainly for declarations. They don\u2019t usually contain full implementations\u2014just the \"signatures\" or interfaces. These declarations are included in source files so that the compiler knows what exists.</p> <p>Without these headers, the compiler would be completely unaware of things like <code>std::cout</code> or <code>std::endl</code>, and you\u2019d get a long list of errors, as shown below.</p> output<pre><code>Main.cpp: In function \u2018int main()\u2019:\nMain.cpp:2:10: error: \u2018cout\u2019 is not a member of \u2018std\u2019\n    2 |     std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n      |          ^~~~\nMain.cpp:1:1: note: \u2018std::cout\u2019 is defined in header \u2018&lt;iostream&gt;\u2019; did you forget to \u2018#include &lt;iostream&gt;\u2019?\n  +++ |+#include &lt;iostream&gt;\n    1 | int main() {\nMain.cpp:2:41: error: \u2018endl\u2019 is not a member of \u2018std\u2019\n    2 |     std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n      |                                         ^~~~\nMain.cpp:1:1: note: \u2018std::endl\u2019 is defined in header \u2018&lt;ostream&gt;\u2019; did you forget to \u2018#include &lt;ostream&gt;\u2019?\n  +++ |+#include &lt;ostream&gt;\n    1 | int main() {\n</code></pre> <p>Including headers tells the compiler: \"Hey, this function or object is declared somewhere\u2014trust me, you'll find its full definition later during linking.\"</p> log.h<pre><code>#pragma once\n\nvoid Log(const char* message);\n</code></pre> log.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid Log(const char* message) {\n    std::cout &lt;&lt; message &lt;&lt; std::endl;\n}\n</code></pre> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#include \"log.h\"\n\nint main() {\n    Log(\"Using Logging Function!\");\n}\n</code></pre> output<pre><code>Using Logging Function!\n</code></pre> <p>In the example above, we can see how header files are used. As we\u2019ve already learned, <code>#include</code> is a preprocessor directive that tells the compiler to copy the contents of the specified file into the current translation unit.</p> <p>That\u2019s why <code>main.cpp</code> knows about the <code>Log</code> function\u2014even though it\u2019s implemented elsewhere. Without the header file, the compiler would have no idea what <code>Log</code> is and would throw an error during compilation, never making it to the linking stage.</p>"},{"location":"01%20Introduction/#header-guard","title":"Header Guard","text":"<p>You may have noticed a new directive at the top of <code>log.h</code>.</p> <pre><code>#pragma once\n</code></pre> <p>This is called a header guard. It ensures that the contents of the file are included only once per translation unit\u2014even if the file gets included multiple times through different paths. Without a header guard, the same declarations (such as functions or variables) could be included more than once, leading to redefinition errors during compilation.</p> <p>Header guards are especially important in larger projects, where headers may be chained together or included indirectly through other headers.</p> <p>The traditional (and more portable) approach uses the <code>#ifndef</code> directive. While a bit more verbose than <code>#pragma once</code>, it\u2019s still widely supported and commonly used.</p> log.h<pre><code>#ifndef _LOG_H_\n#define _LOG_H_\n\nvoid Log(const char* message);\n\n#endif\n</code></pre> <p>This pattern works by checking whether <code>_LOG_H_</code> has already been defined. If not, it defines it and includes the content inside. If the file has already been included elsewhere, the compiler skips its contents\u2014avoiding duplicate declarations.</p>"},{"location":"01%20Introduction/#header-search","title":"Header Search","text":"<p>In <code>main.cpp</code>, we used two different notations when including header files.</p> <pre><code>#include &lt;iostream&gt;\n#include \"log.h\"\n</code></pre> <p>The difference between them lies in where the compiler looks for the header file.</p> Syntax Search Path Typical Use Case <code>#include &lt;...&gt;</code> Searches system and standard library include paths. For standard headers like <code>&lt;iostream&gt;</code>. <code>#include \"...\"</code> Searches relative to the including file, usually starting with the current working directory. For project-specific headers like <code>log.h</code>."},{"location":"01%20Introduction/#code-comments","title":"Code Comments","text":"<p>Comments are lines in your code that are completely ignored by the compiler. This means they have no effect on how the program runs\u2014they're written solely for humans to read.</p> <p>Comments are useful because, as programs grow larger and more complex, it becomes necessary to document your code. This helps others or even your future self understand what the code is doing and why certain decisions were made.</p> <p>However, keep in mind that good code should be self-explanatory. Avoid writing comments that simply restate what the code is already clearly doing.</p> main.cpp<pre><code>// \"Main function\" is a bad comment\nint main() {\n    // code ...\n}\n</code></pre> <p>Instead, comments should be used to:</p> <ul> <li>Explain logic or reasoning behind complex code.</li> <li>Make notes for future improvements or reminders.</li> <li>Temporarily disable code (useful for debugging or testing).</li> <li>Provide documentation for advanced algorithms or non-obvious behavior.</li> </ul>"},{"location":"01%20Introduction/#types-of-comments","title":"Types of Comments","text":"<p>Single-line comments (<code>//</code>): Anything after <code>//</code> on the same line is considered a comment. </p> main.cpp<pre><code>#include &lt;iostream&gt; // This is a single-line comment\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>\"Hello World!\"\n</code></pre> <p>Multi-line comments (<code>/* ... */</code>): Used for longer explanations spanning multiple lines.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\n/* \n    This is a multi-line comment.\n    It can span multiple lines without needing // on each line. \n*/ \n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>\"Hello World!\"\n</code></pre>"},{"location":"01%20Introduction/#data-types-and-variables","title":"Data Types and Variables","text":"<p>In programming, data types and variables are fundamental concepts. That\u2019s because programming is ultimately about working with data\u2014and to work with data effectively, two things need to happen:</p> Requirement Description Storage The data must be placed somewhere in the computer's memory. Typing The program must understand what kind of data it's dealing with (e.g., a number, a character, and so on). <p>To represent different kinds of data, we use data types. To actually hold that data in memory, we use variables.</p> <p>Even though all data in memory is ultimately stored as binary, data types give those raw bits meaning. The main differences between data types come down to how much memory they use and how those bits are interpreted.</p> <p>Info</p> <p>Data types are important enough to deserve their own full chapter\u2014but for now, this brief introduction will do just fine.</p>"},{"location":"01%20Introduction/#primitive-data-types","title":"Primitive Data Types","text":"<p>The most basic data types in C++ are called primitive types. They form the foundation for all more complex types you'll encounter later.</p> Type Name Description Size <code>int</code> Integer Stores whole numbers Typically 4 bytes <code>float</code> Floating-point number Stores numbers with decimals. Precision is limited. 4 bytes <code>double</code> Double-precision float Similar to <code>float</code>, but with more precision. 8 bytes <code>char</code> Character Stores a single ASCII character (e.g., 'A', 'b', '#'). 1 byte <code>bool</code> Boolean Stores only <code>true</code> (1) or <code>false</code> (0). 1 byte (implementation-defined) <p>Tip</p> <p>In programming, instead of using spaces to separate large numbers for readability (which would cause a syntax error), you can group digits using single quotes. For example, instead of writing 1976834, you can write 1'976'834\u2014this makes the number easier to read, especially when dealing with thousands or millions.</p>"},{"location":"01%20Introduction/#ascii","title":"ASCII","text":"<p>ASCII (American Standard Code for Information Interchange) is a character encoding standard that represents text characters using numerical values. For example:</p> ASCII Code Character 65 A 66 B 97 a 48 0 <p>Full table can be found here: https://www.ascii-code.com/</p>"},{"location":"01%20Introduction/#declaring-and-naming-variables","title":"Declaring and Naming Variables","text":"<p>A variable is a named storage location for data in memory. When we create a variable, we assign it a data type and name so that we can refer to it later in our program.</p> <p>Rules for Naming Variables:</p> <ul> <li>Must start with a letter or underscore, but cannot start with a number.</li> <li>Can contain letters, numbers, and underscores, but no spaces.</li> <li>Cannot use C++ reserved keywords (e.g., <code>int</code>, <code>float</code>, <code>return</code>).</li> <li>Should be descriptive (e.g., <code>user_age</code> instead of <code>x</code>).</li> </ul> <p>We assign values to variables using the <code>=</code> symbol. There are a few important rules to keep in mind when assigning values:</p> <ul> <li>Floating-point numbers: Use a dot instead of a comma, e.g., <code>3.14</code>, <code>-2.71</code>.</li> <li>Characters: Must be enclosed in single quotes, e.g., <code>'A'</code>, <code>'b'</code>, <code>'#'</code>.</li> <li>Escape sequences such as <code>\\t</code> (tab) and <code>\\n</code> (new line) are special characters that affect text formatting.</li> </ul> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main () {\n    int user_age = 25;\n    const float pi = 3.14;    \n    char user_grade = 'A';\n    bool underaged = false;\n\n    std::cout &lt;&lt; \"User age: \" &lt;&lt; user_age &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"PI: \" &lt;&lt; pi &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"User grade: \" &lt;&lt; user_age &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Underaged? \" &lt;&lt; underaged &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>User age: 25\nPI: 3.14\nUser grade: 25\nUnderaged? 0\n</code></pre> <p>In C++, each declaration or statement must end with a semicolon <code>;</code>. This symbol tells the compiler that the statement is complete.</p> <p>Additionally, in the example above, you might have noticed a specific way of naming variables. This naming style is called snake_case, where all characters are lowercase and words are separated by underscores (e.g., user_age, player_score). This style improves readability, especially in longer variable names, and is commonly used in many C++ codebases.</p> <p>Info</p> <p>Throughout this guide, we will follow the Google C++ Style Guide, which recommends using snake_case for variable names and PascalCase for function and class names.</p> <p>You can learn more about these conventions and other best practices here:  https://google.github.io/styleguide/cppguide.html</p>"},{"location":"01%20Introduction/#constants","title":"Constants","text":"<p>Sometimes, we want our stored data to be read-only, especially when displaying information in a terminal, website, or other output formats. To achieve this, we use the <code>const</code> keyword in front of a variable declaration, which ensures the variable remains unchangeable after initialization.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    const int number = 54;\n\n    number = 34;\n\n    std::cout &lt;&lt; number &lt;&lt; std::endl; \n}\n</code></pre> output<pre><code>error: assignment of read-only variable \u2018number\u2019\n</code></pre> <p>As shown in the example above, a constant variable cannot be reassigned a value\u2014it results in an error.</p>"},{"location":"01%20Introduction/#terminal-input-and-output","title":"Terminal Input and Output","text":"<p>So far, we've focused on how programs store data internally. Equally important, though, is understanding how that data enters and exits the program. While data can come from sources like files, databases, or web APIs, the most fundamental method is through terminal input and output.</p> <p>In C++, this is handled using the standard library <code>iostream</code>, which provides tools for both displaying messages to the user and reading input from the terminal.</p> <p>The following example demonstrates how to use <code>std::cout</code> to prompt the user and <code>std::cin</code> to read their response.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int user_age;\n\n    std::cout &lt;&lt; \"Enter your age: \";\n    std::cin &gt;&gt; user_age;\n\n    std::cout &lt;&lt; \"User age: \" &lt;&lt; user_age &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>It depends on the input you provided\n</code></pre> <p>It can be tricky for beginners to remember which symbols to use for input (<code>&gt;&gt;</code>) and output (<code>&lt;&lt;</code>) streams. A helpful way to visualize them is to think of them as arrows showing the direction of data flow:</p> Statement Description <code>std::cin &gt;&gt; variable;</code> Data flows from the terminal into the variable. <code>std::cout &lt;&lt; message;</code> Data flows from the program out to the terminal."},{"location":"01%20Introduction/#exercises","title":"Exercises","text":"task 1answer <pre><code>Write a program that will print into the terminal\nyour name in one line and surname into another\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Name\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Surname\" &lt;&lt; std::endl;\n}\n</code></pre> task 2answer <pre><code>Write a program that will ask user for how old they are\nand store it in a variable that will be subsequantily\nprinted into the terminal\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int user_age;\n\n    std::cout &lt;&lt; \"Enter your age: \";\n    std::cin &gt;&gt; user_age;\n\n    std::cout &lt;&lt; \"User age: \" &lt;&lt; user_age &lt;&lt; std::endl; \n}\n</code></pre>"},{"location":"02%20Control%20Flow/","title":"02 Control Flow","text":"<p>Info</p> <p>This chapter goes hand in hand with the 03 Operators chapter. So keep in mind that the two chapters are closely related, and many concepts work together. If something seems skipped here, it's likely because it was better suited for that chapter.</p> <p>There always comes a point when our code needs to branch out \u2014 meaning we only want certain actions to happen if specific conditions are met.</p> <p>For example, in a game, we might want to restrict access to certain areas for low-level players to keep beginner zones separate from tougher ones. Or maybe a quest can only be completed if the player has a specific item. These decisions depend on conditions \u2014 and the possibilities are endless. It can also be used to check for errors \u2014 something we'll explore more deeply in the chapter focused on error handling \u2014 and you'll see it come up repeatedly throughout the early chapters as well.</p> <p>We manage this kind of behavior using control flow statements, which let us check a condition and decide what happens based on whether it\u2019s true or false. Think of them as checkpoints in your code: Before moving forward, the program asks if the condition true. If it is, the code inside the check runs; otherwise, it is skipped.</p>"},{"location":"02%20Control%20Flow/#if-statements","title":"If Statements","text":"<p>The most basic and essential control flow tool in programming is the <code>if</code> statement. It does exactly what it sounds like: it checks a condition and decides what to do based on the result.</p> <p>The condition is written inside parentheses immediately following the <code>if</code> keyword. We typically use comparison and logical operators to form this condition \u2014 it must evaluate to either <code>true</code> or <code>false</code>.</p> <p>If the condition is <code>true</code>, the code inside the curly braces (called the statement body, block, or scope) will execute. If the condition is <code>false</code>, that block is skipped.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int player_has_item = true;\n\n    if (player_has_item) {\n        std::cout &lt;&lt; \"Quest Completed!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> output<pre><code>Quest Completed!\n</code></pre> <p>It\u2019s also possible to extend an <code>if</code> statement with two additional keywords to form a complete conditional structure.</p> <p>The first is <code>else if</code>, which allows us to check another condition if the original if condition wasn\u2019t met. For example, if a player is too low-level, the first condition will block them from entering. But with <code>else if</code>, we can also check if the player is too high-level for a specific zone \u2014 and handle that differently, such as temporarily reducing their level or showing a warning.</p> <p>The final piece is <code>else</code>, which does not take a condition. It acts as a fallback: if none of the previous conditions were met, the code inside the else block will execute.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int player_level = 42;\n\n    if (player_level &lt; 20) {\n        std::cout &lt;&lt; \"Your level is too low to enter this zone.\\n\";\n    } else if (player_level &gt; 80) {\n        std::cout &lt;&lt; \"You are overleveled for this area! Consider a tougher challenge.\\n\";\n    } else {\n        std::cout &lt;&lt; \"You\u2019ve entered the zone. Good luck!\\n\";\n    }\n}\n</code></pre> output<pre><code>You\u2019ve entered the zone. Good luck!\n</code></pre>"},{"location":"02%20Control%20Flow/#switch-statements","title":"Switch Statements","text":"<p>When we need to compare a variable against several fixed values, writing a long chain of if-else statements can get messy and harder to read. In these situations, a <code>switch</code> statement offers a cleaner and often more efficient alternative.</p> <p>One reason <code>switch</code> can be faster is that many compilers optimize it using a jump table, allowing the program to instantly jump to the matching case without checking each condition one by one.</p> <p>Also, unlike an <code>if</code> statement, a <code>switch</code> doesn\u2019t evaluate full conditions inside its parentheses. Instead, it works with a single variable and checks its value against several predefined options, known as cases.</p> <p>You place the variable you want to match inside the parentheses of the <code>switch</code> statement, then list the possible values using <code>case</code> followed by each specific value. After each case, you write the code that should run when that value matches. Each case typically ends with a <code>break</code> to prevent the program from unintentionally continuing into the next case. If none of the cases match, you can include a <code>default</code> case at the end to handle all other values.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main()  {\n    char grade = 'C';\n\n    switch (grade) {\n        case 'A': \n            std::cout &lt;&lt; \"Excellent!\" &lt;&lt; std::endl;\n            break;\n        case 'B': \n            std::cout &lt;&lt; \"Good job!\" &lt;&lt; std::endl;\n            break;\n        case 'C': \n            std::cout &lt;&lt; \"You passed.\" &lt;&lt; std::endl;\n            break;\n        case 'D': \n            std::cout &lt;&lt; \"You should work harder.\" &lt;&lt; std::endl;\n            break;\n        case 'F': \n            std::cout &lt;&lt; \"You failed.\" &lt;&lt; std::endl;\n            break;\n        default:\n            std::cout &lt;&lt; \"Invalid grade.\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> output<pre><code>You passed.\n</code></pre> <p>Note</p> <p>The values a <code>switch</code> statement can match against must be integer types, such as <code>int</code> or <code>char</code>. Whole strings (text) cannot be used directly.</p> <p>In a <code>switch</code> statement, leaving out the <code>break</code> between cases causes what's called a fallthrough\u2014the execution \"falls through\" to the next case until it encounters a break or reaches the end of the <code>switch</code>. This can be intentional and useful when multiple cases should trigger the same behavior, like grouping <code>'A'</code>, <code>'B'</code>, and <code>'C'</code> to all print the same thing. However, be careful: unintentional fallthroughs can lead to bugs, and since the compiler doesn\u2019t always warn you, they can be tricky to catch.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main()  {\n    char grade = 'A';\n\n    switch (grade) {\n        case 'A':\n        case 'B':\n        case 'C': \n            std::cout &lt;&lt; \"You passed.\" &lt;&lt; std::endl;\n            break;\n        case 'D': \n            std::cout &lt;&lt; \"You should work harder.\" &lt;&lt; std::endl;\n            break;\n        case 'F': \n            std::cout &lt;&lt; \"You failed.\" &lt;&lt; std::endl;\n            break;\n        default:\n            std::cout &lt;&lt; \"Invalid grade.\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> output<pre><code>You passed.\n</code></pre>"},{"location":"02%20Control%20Flow/#go-to","title":"Go to","text":"<p>The <code>goto</code> statement is a control flow mechanism that allows you to jump to a labeled part of the code. While it does exist in C++, it's generally discouraged because it can make your code harder to read, understand, and maintain. Introducing arbitrary jumps in the program breaks the natural, structured flow of execution and often leads to what's known as \u201cspaghetti code.\u201d</p> <p>There are very few legitimate use cases for <code>goto</code>, such as breaking out of deeply nested loops in older codebases, but in modern C++, there are almost always better alternatives like functions, loops, and exception handling. In short: avoid using goto unless absolutely necessary \u2014 and in most cases, it won\u2019t be.</p> example<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value;\n\n    std::cout &lt;&lt; \"Enter a number (0 to exit): \";\n    std::cin &gt;&gt; value;\n\n    if (value == 0)\n        goto end;\n\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; value &lt;&lt; std::endl;\n\nend:\n    std::cout &lt;&lt; \"Program ended.\" &lt;&lt; std::endl;\n}\n</code></pre> <p>In the first example, it's easy to see how using <code>goto</code> makes the code feel awkward and harder to follow. It introduces an unnatural jump in the program\u2019s flow, which hurts readability \u2014 especially in larger projects.</p> <p>Instead, the second example uses a simple <code>if</code> statement, making the logic more structured and easier to understand. Whenever you find yourself reaching for goto, it\u2019s usually a sign that the code structure should be rethought. There's almost always a cleaner alternative.</p> example<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value;\n\n    std::cout &lt;&lt; \"Enter a number (0 to exit): \";\n    std::cin &gt;&gt; value;\n\n    if (value != 0) {\n        std::cout &lt;&lt; \"You entered: \" &lt;&lt; value &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"Program ended.\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"02%20Control%20Flow/#loops","title":"Loops","text":"<p>One of the most common challenges in programming is how to repeat a task multiple times without writing the same code over and over again.</p> <p>Sure, if we need to print a message a hundred times, we could write the same line of code a hundred times \u2014 but that would be tedious, error-prone, and completely impractical. And for example, what if we want to keep displaying something endlessly until the user closes the program, writing it out manually just isn\u2019t an option.</p> <p>Loops let us repeat a block of code as long as a certain condition is met, making repetitive tasks much cleaner and easier to manage.</p>"},{"location":"02%20Control%20Flow/#while-loops","title":"While Loops","text":"<p>The simplest type of loop in C++ is the <code>while</code> loop. It works similarly to an <code>if</code> statement, but instead of running just once, it repeatedly executes the code block as long as the condition remains true. This loop is especially useful when you don\u2019t know in advance how many times a task needs to be repeated\u2014for example, reading a password from a user or processing lines in a file where the total number of lines isn\u2019t known.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    while (true) {\n        std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> output<pre><code>Hello World!\nHello World!\nHello World!\nHello World!\nHello World!\n...\n</code></pre> <p>In this example, the condition is checked before each loop iteration. As long as the condition is <code>true</code>, the code inside the block continues to run. Since <code>true</code> never becomes <code>false</code>, this creates an infinite loop.</p> <p>There\u2019s also a variation called the do-while loop, where the code block is executed at least once, and the condition is checked afterward. It\u2019s essentially an inverted while loop that guarantees the code executes at least once before the condition is checked.</p> example<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value;\n\n    do {\n        std::cout &lt;&lt; \"Enter number: \" &lt;&lt; count &lt;&lt; std::endl;\n        std::cin &gt;&gt; value;\n    } while (value &gt; 0);\n}\n</code></pre> <p>As you can see, the condition in a <code>while</code> loop or do-while loop can be more complex than just a single variable or value, similar to an <code>if</code> statement. It can also involve expressions that evaluate to <code>true</code> or <code>false</code>.</p>"},{"location":"02%20Control%20Flow/#for-loops","title":"For Loops","text":"<p>When we don\u2019t know how many times a process should repeat\u2014because it depends on user input, external conditions, or when the program is closed\u2014we use a while loop. On the other hand, when we do know exactly how many times we want to repeat a process, a for loop is a cleaner and more concise choice.</p> <p>For example, if we want to print numbers from 1 to 10, a for loop is ideal. A for loop consists of three parts.</p> Part Description Initialization Sets the starting value of the loop variable. Condition Defines when the loop should stop executing. Increment/Decrement Controls how the loop variable changes after each iteration. <p>Because all three parts are combined in the loop header, a <code>for</code> loop keeps your code compact and easy to read, especially when the number of repetitions is fixed or known ahead of time.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    for (int i = 1; i &lt;= 10; ++i) {\n        std::cout &lt;&lt; i &lt;&lt; '\\t';\n    }\n}\n</code></pre> output<pre><code>1   2   3   4   5   6   7   8   9   10\n</code></pre>"},{"location":"02%20Control%20Flow/#nested-loops","title":"Nested Loops","text":"<p>Sometimes you\u2019ll need to repeat a loop inside another loop \u2014 this is called a nested loop. Each iteration of the outer loop runs the entire inner loop. This is useful for working with multi-dimensional data or creating patterns.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int rows = 5;\n\n    for (int i = 1; i &lt;= rows; ++i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            std::cout &lt;&lt; \"* \";\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n}\n</code></pre> output<pre><code>* \n* * \n* * * \n* * * * \n* * * * * \n</code></pre> <p>Warning</p> <p>Always use a different variable name for the inner loop. If the inner and outer loops share the same variable, it can cause unexpected behavior and logic errors.</p>"},{"location":"02%20Control%20Flow/#break-and-continue","title":"Break and Continue","text":"<p>Control flow inside loops can be further refined with the break and continue statements.</p> Keyword Description <code>break</code> Immediately exits the loop, skipping all remaining iterations. <code>continue</code> Skips the current iteration and jumps to the next one. <p>These are helpful to control loop execution without complicating conditions. </p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    for (int i = 1; i &lt;= 10; ++i) {\n        // Exit loop when i is 5\n        if (i == 5) {\n            break;\n        }\n\n        // Skip even numbers\n        if (i % 2 == 0) {\n            continue;\n        }\n\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n    }\n}\n</code></pre> output<pre><code>1 3 \n</code></pre>"},{"location":"02%20Control%20Flow/#shortened-notations","title":"Shortened Notations","text":"<p>These statements we went trough follow the same pattern and there fore this applies to all of them. And that is that They can also be written without curly braces when they contain only a single line of the code inside of the body.</p> example<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int count = 1;\n\n    // While loop without braces\n    while (count &lt;= 5)\n        std::cout &lt;&lt; count++ &lt;&lt; \" \";\n\n    std::cout &lt;&lt; std::endl;\n\n    // For loop without braces\n    for (int i = 1; i &lt;= 10; ++i)\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n\n    std::cout &lt;&lt; std::endl;\n\n    int x = 3;\n\n    // If statement without braces\n    if (x &gt; 0)\n        std::cout &lt;&lt; \"x is positive\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>1 2 3 4 5 \n1 2 3 4 5 6 7 8 9 10 \nx is positive\n</code></pre>"},{"location":"02%20Control%20Flow/#exercises","title":"Exercises","text":"task 1answer <p>Write a program that asks the user to enter an integer. Use an if-else statement to check whether the number is even or odd, and print the appropriate message.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int number;\n\n    std::cout &lt;&lt; \"Enter an integer: \";\n    std::cin &gt;&gt; number;\n\n    if (number % 2 == 0)\n        std::cout &lt;&lt; \"Number is even\" &lt;&lt; std::endl;\n    else\n        std::cout &lt;&lt; \"Number is odd\" &lt;&lt; std::endl;\n}\n</code></pre> task 2answer <p>Write a program that counts down from 10 to 1 using a <code>for</code> loop.</p> <ul> <li>Skip the number 5</li> <li>Stop the loop entirely when the number reaches 2</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    for (int i = 10; i &gt;= 1; --i) {\n        if (i == 5)\n            continue;\n\n        if (i == 2)\n            break;\n\n        std::cout &lt;&lt; i &lt;&lt; '\\t';\n    }\n}\n</code></pre> task 3answer <p>Write a program that prints a 5 \u00d7 5 square made of <code>#</code> characters.</p> <ul> <li>Skip the third row entirely so that it appears as a blank line in the output.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    for (int i = 0; i &lt; 5; ++i) {\n        if (i == 2) {\n            std::cout &lt;&lt; std::endl;\n            continue;\n        }\n\n        for (int j = 0; j &lt; 5; ++j) {\n            std::cout &lt;&lt; \"# \";\n        }\n\n        std::cout &lt;&lt; std::endl;\n    }\n}\n</code></pre> task 4answer <p>Write a program that prints a reversed pyramid of <code>@</code> characters, starting with 5 symbols in the first row and decreasing by one each subsequent row.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    for (int i = 5; i &gt; 0; --i) {\n        for (int j = i; j &gt; 0; --j) {\n            std::cout &lt;&lt; \"@ \";\n        }\n\n        std::cout &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"03%20Operators/","title":"03 Operators","text":"<p>In programming, operators are special symbols or keywords that perform actions on variables and values. They allow us to manipulate data, perform calculations, and control program logic. Whether it\u2019s adding numbers, comparing values, or modifying bits directly, operators are fundamental to how code behaves.</p> <p>At their core, operators resemble mathematical symbols, but they go far beyond basic arithmetic\u2014enabling everything from assignment and comparison to pointer manipulation and bitwise control.</p>"},{"location":"03%20Operators/#comparison-operators","title":"Comparison Operators","text":"<p>The first and most fundamental type of operators are comparison operators, which are commonly used in conditions\u2014such as inside <code>if</code> statements or loops. They are similar to those found in mathematics. These operators allow us to compare values and control the flow of a program by returning <code>true</code> or <code>false</code> based on the result.</p> Operator Description Example <code>&gt;</code> Greater than <code>a &gt; b</code> <code>&lt;</code> Less than <code>a &lt; b</code> <code>&gt;=</code> Greater than or equal to <code>a &gt;= b</code> <code>&lt;=</code> Less than or equal to <code>a &lt;= b</code> <code>==</code> Equal to <code>a == b</code> <code>!=</code> Not equal to <code>a != b</code> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int user_age = 10;\n\n    if (user_age &lt; 0)\n        std::cout &lt;&lt; \"Invalid age. Age cannot be negative.\" &lt;&lt; std::endl;\n    else if (user_age &lt; 12)\n        std::cout &lt;&lt; \"Sorry, you are too young to enter.\" &lt;&lt; std::endl;\n    else\n        std::cout &lt;&lt; \"Welcome to the game!\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Sorry, you are too young to enter.\n</code></pre>"},{"location":"03%20Operators/#logical-operators","title":"Logical Operators","text":"<p>Logical operators are used to combine multiple comparison expressions to form complex decision-making conditions. When used alongside comparison operators, they enable more precise control flow.</p> Operator Name Description <code>&amp;&amp;</code> Logical AND True only if both conditions are true. <code>||</code> Logical OR True if at least one condition is true. <code>!</code> Logical NOT Inverts the value of a condition (true \u2192 false, false \u2192 true). main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int x = 5;\n    bool isReady = false;\n\n    if (x &gt; 0 &amp;&amp; x &lt; 10)\n        std::cout &lt;&lt; \"x is between 1 and 9\" &lt;&lt; std::endl;\n\n    if (x &lt; 0 || x &gt; 100)\n        std::cout &lt;&lt; \"x is out of range\" &lt;&lt; std::endl;\n\n    if (!isReady)\n        std::cout &lt;&lt; \"Not ready yet!\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>x is between 1 and 9\nNot ready yet!\n</code></pre>"},{"location":"03%20Operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<p>Next in line are arithmetic operators. They function just like in mathematics, helping us perform basic mathematical operations such as addition, multiplication, and more.</p> Operator Description Example <code>+</code> Adds two values <code>a + b</code> <code>-</code> Subtracts one value from another <code>a - b</code> <code>*</code> Multiplies two values <code>a * b</code> <code>/</code> Divides one value by another <code>a / b</code> <code>%</code> Computes the remainder of a division <code>a % b</code> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10 * 10;\n    int b = 20;\n    int c = a + b;\n\n    std::cout &lt;&lt; \"Number C: \" &lt;&lt; c &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Number C: 120\n</code></pre> <p>Note</p> <p>If a program tries to divide by zero, it will result in a runtime error (crash) because division by zero is undefined.</p> <p>Note</p> <p>The division operator <code>/</code> behaves differently depending on the operand types.</p> <p>If both operands are integers, the result is also an integer, discarding the decimal part. If at least one operand is a floating-point number, the result retains decimals.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Integer division: \" &lt;&lt; 9 / 2 &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"One is floating point number: \" &lt;&lt; 9.0 / 2 &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Integer division: 4\nOne is floating point number: 4.5\n</code></pre> <p>The modulus operator <code>%</code> is only valid for integers and gives the remainder of a division. It is commonly used to check divisibility, such as determining whether a number is even or odd.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int x = 7;\n\n    if (x % 2 == 0)\n        std::cout &lt;&lt; \"Number is even\";\n    else\n        std::cout &lt;&lt; \"Number is odd\";\n}\n</code></pre> output<pre><code>Number is odd\n</code></pre>"},{"location":"03%20Operators/#shortened-notations","title":"Shortened Notations","text":"<p>There are also shorthand notations that make coding more concise. Instead of writing full expressions like <code>a = a + b</code>, we can use compound assignment operators to simplify the syntax.</p> <p>For example, if we want to increase or multiply <code>a</code> by <code>b</code>, we can use the following shorthand notations:</p> Operator Description Equivalent Expression <code>+=</code> Adds and assigns <code>a = a + b</code> <code>-=</code> Subtracts and assigns <code>a = a - b</code> <code>*=</code> Multiplies and assigns <code>a = a * b</code> <code>/=</code> Divides and assigns <code>a = a / b</code> <code>%=</code> Remainder and assigns <code>a = a % b</code> <p>In addition to these, we have increment and decrement operators.</p> Operator Description Equivalent Expression <code>++</code> Increases a variable by <code>1</code> <code>a = a + 1</code> <code>--</code> Decreases a variable by <code>1</code> <code>a = a - 1</code> <p>Difference between postfix increment and prefix increment:</p> <ul> <li><code>++a</code> is the prefix increment: the variable is incremented first, then its new value is used in the expression.</li> <li><code>a++</code> is the postfix increment: the variable\u2019s current value is used first, and then it is incremented.</li> </ul> <p>For clarity, prefer using the prefix (<code>++a</code>) method when the previous value is not needed. In console outputs or function arguments, postfix (<code>a++</code>) can be misleading, as it will display or use the old value before incrementing.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10;\n    int b = 5;\n\n    a += b;\n    std::cout &lt;&lt; \"Number A after +=: \" &lt;&lt; a &lt;&lt; std::endl; \n\n    a *= 2;\n    std::cout &lt;&lt; \"Number A after *=: \" &lt;&lt; a &lt;&lt; std::endl;\n\n    a++;\n    std::cout &lt;&lt; \"Number A after ++: \" &lt;&lt; a++ &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Number A after +=: 15\nNumber A after *=: 30\nNumber A after ++: 31\n</code></pre>"},{"location":"03%20Operators/#operator-evaluation-order","title":"Operator Evaluation Order","text":"<p>When working with operators in C++, understanding how they are evaluated is crucial to avoid unexpected behavior. Operator evaluation determines the order in which operations are performed and how expressions are processed.</p> <p>C++ follows a set of rules to decide which operators take precedence over others in an expression. These rules dictate whether multiplication happens before addition, or how logical and comparison operators interact.</p> Term Definition Operator precedence Defines which operator is evaluated first in an expression. Operator associativity Determines the order of evaluation when multiple operators of the same precedence appear in an expression. <p>Note</p> <p>Arithmetic operators follow standard mathematical rules: multiplication and division are evaluated before addition and subtraction, and expressions inside parentheses are evaluated always first.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nbool first() {\n    std::cout &lt;&lt; \"First\" &lt;&lt; std::endl;\n    return false;\n}\n\nbool second() {\n    std::cout &lt;&lt; \"Second\" &lt;&lt; std::endl;\n    return true;\n}\n\nint main() {\n    if (first() &amp;&amp; second()) {\n    }\n}\n</code></pre> output<pre><code>First\n</code></pre> <p>The output remains unchanged because the <code>if</code> statement uses the logical AND operator, which evaluates conditions from left to right. Since <code>first()</code> returns <code>false</code>, the entire condition can never be true, so the second function is never called. This behavior is known as short-circuit evaluation.</p>"},{"location":"03%20Operators/#bitwise-operators","title":"Bitwise Operators","text":"<p>While arithmetic operators work with base-10 numbers, bitwise operators operate on numbers in base-2 (binary), manipulating each individual bit. A bit is the smallest unit of memory and can be either 0 or 1. This is because they operate on transistors, which have only two states: ON (1) or OFF (0). These bits are grouped into bytes, where 8 bits = 1 byte. A half byte (4 bits) is referred to as a nibble.</p>"},{"location":"03%20Operators/#binary-representation","title":"Binary Representation","text":"<p>As computers store values using binary (base-2), meaning unlike our familiar decimal (base-10) system, where numbers are represented using digits from 0 to 9, they can only use the numbers 0 and 1. </p> <p>Below is a comparison of base-10 numbers and their binary (base-2) equivalents.</p> Base 10 Base 2 0 0 1 1 2 10 3 11 4 100 5 101 <p>Each new bit (binary digit) doubles the range of representable numbers, just as adding a new digit in base-10 increases the place value.</p> <p>Tip</p> <p>You can experiment with binary, hexadecimal, and other number representations using the Windows Calculator in Programmer mode.</p> <p>A 32-bit integer (regular <code>int</code>) storing the number <code>5</code> would be represented in memory like displayed below. <pre><code>0000 0101 | 0000 0000 | 0000 0000 | 0000 0000 \n</code></pre></p> <p>You might wonder why the number doesn\u2019t start from the right, as that might seem more intuitive. This depends on the endianness of your CPU. Most modern CPUs use little-endian ordering, meaning less significant bytes are stored at lower memory addresses, while more significant bytes are stored at higher addresses. If we were to compile the same program on a big-endian CPU, the memory layout would be reversed.</p> <pre><code>0000 0000 | 0000 0000 | 0000 0000 | 0000 0101\n</code></pre> <p>Endianness affects the order of bytes, not the order of bits within a byte, so you wouldn\u2019t see something like this for number <code>5</code>.</p> <pre><code>0000 0000 | 0000 0000 | 0000 0000 | 0101 0000\n</code></pre>"},{"location":"03%20Operators/#conversion-between-decimal-and-binary-systems","title":"Conversion Between Decimal and Binary Systems","text":"<p>To convert a decimal number into binary, we repeatedly divide the number by 2 until 0 is reached and keeping track of the remainders. The binary representation is formed by reading these remainders from bottom to top.</p> <p>For example, converting <code>5</code> from decimal to binary.</p> <pre><code>5 / 2 = 2 -&gt; reminder 1\n2 / 2 = 1 -&gt; reminder 0\n1 / 2 = 0 -&gt; reminder 1\n</code></pre> <p>Reading the remainders from bottom to top, <code>5</code> in decimal is <code>101</code> in binary.</p> <p>To convert a binary number into decimal, each position in the binary representation corresponds to a power of 2, starting from 2\u2070 at the rightmost bit. The decimal value is calculated by summing up these powers where 1s appear.</p> <p>For example, converting <code>101</code> from binary to decimal:</p> <pre><code>  1          0          1\n1 \u00d7 2\u00b2  +  0 \u00d7 2\u00b9  +  1 \u00d7 2\u2070\n  4     +    0     +    1    =  5\n</code></pre>"},{"location":"03%20Operators/#conversion-between-decimal-and-hexadecimal-systems","title":"Conversion Between Decimal and Hexadecimal Systems","text":"<p>To convert a decimal number into hexadecimal, we repeatedly divide the number by 16 until 0 is reached and keeping track of the remainders. The hexadecimal representation is then formed by reading these remainders from bottom to top.</p> <p>Hexadecimal uses digits <code>0\u20139</code> and letters <code>A\u2013F</code> to represent values from <code>0\u201315</code>.</p> <pre><code>0 1 2 3 4 5 6 7 8 9 A B C D E F\n</code></pre> <p>For example, converting <code>192</code> from decimal to hexadecimal:</p> <pre><code>192 / 16 = 12 -&gt; remainder  0 -&gt; 0\n12  / 16 =  0 -&gt; remainder 12 -&gt; C\n</code></pre> <p>Reading the remainders from bottom to top, <code>192</code> in decimal is <code>C0</code> in hexadecimal.</p> <p>To convert hexadecimal back into decimal, each digit is multiplied by a power of 16, starting from the rightmost digit (which is multiplied by 16\u2070).</p> <p>For example, converting <code>C0</code> from hexadecimal to decimal:</p> <pre><code>   C         0\n C \u00d7 16\u00b9 + 0 \u00d7 16\u2070\n12 \u00d7 16  + 0 \u00d7  1  = 192\n</code></pre>"},{"location":"03%20Operators/#conversion-between-decimal-and-octal-systems","title":"Conversion Between Decimal and Octal Systems","text":"<p>To convert a decimal number into octal, divide the number repeatedly by 8 until 0 is reached and keep track of the remainders. The octal number is then formed by reading the remainders from bottom to top.</p> <p>Octal is base-8, so it uses digits from <code>0</code> to <code>7</code>.</p> <p>For example, converting <code>65</code> from decimal to octal:</p> <pre><code>65 / 8 = 8 remainder 1\n8  / 8 = 1 remainder 0\n1  / 8 = 0 remainder 1\n</code></pre> <p>Reading the remainders from bottom to top, <code>65</code> in decimal is <code>101</code> in octal.</p> <p>To convert octal back to decimal, multiply each digit by a power of 8, starting from the rightmost digit (8\u2070).</p> <p>For example, converting <code>101</code> from octal to decimal:</p> <pre><code>  1        0        1\n1 \u00d7 8\u00b2 + 0 \u00d7 8\u00b9 + 1 \u00d7 8\u2070\n 64    +   0    +   1    = 65`\n</code></pre>"},{"location":"03%20Operators/#examining-memory-representation-in-practice","title":"Examining Memory Representation in Practice","text":"<p>Now that we understand how binary works, we can examine how memory is structured using Visual Studio by writing a simple program. This examination was done in Visual Studio, but it can be performed in almost any code editor or IDE.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    std::cout &lt;&lt; a &lt;&lt; std::endl; // Place breakpoint at this line\n}\n</code></pre> <p>When this simple script is pasted into your code editor or IDE, place a breakpoint at the highlighted line by clicking on the empty space to the left of the line number. This will pause the program at that exact point, right after the variable declaration, allowing us to inspect memory.</p> <p>Run the program, and you\u2019ll see it pause. Then, in the top utility bar, navigate to Debug \u2192 Windows \u2192 Memory \u2192 Memory 1. This will open a memory panel where you\u2019ll find an address search field. Enter <code>&amp;a</code> to jump to the memory address where the variable is stored.</p> <p>At this memory location, you\u2019ll see our number 5, but instead of just <code>0</code>s and <code>1</code>s, you\u2019ll also notice characters like <code>F</code> and <code>B</code>. That\u2019s because memory is displayed using hexadecimal (base-16) instead of binary.</p> <p>Using pure binary would be inefficient for reading and searching, as long sequences of <code>0</code>s and <code>1</code>s are hard to interpret. Hexadecimal (base-16) is useful because it aligns perfectly with binary, each hex digit represents exactly 4 bits, meaning two hex digits make up one byte. This significantly shortens binary representation.</p> <pre><code>   0    5 |    0    0 |    0    0 |    0    0\n0000 0101 | 0000 0000 | 0000 0000 | 0000 0000 \n</code></pre> <p>For comparison, in decimal (base-10), 8 bits can represent values up to 255, requiring three digits (e.g., <code>255</code>). In hexadecimal, however, <code>255</code> is simply <code>FF</code>, retaining the one hex digit per 4 bits rule. This makes hexadecimal more efficient for representing memory values.</p> <p>While these concepts primarily apply to integers, they can also be used with floating-point numbers. However, working with floats at the binary level requires specifying the correct data type to interpret the stored bits correctly. In most cases, though, bitwise operations are used with integers only.</p>"},{"location":"03%20Operators/#bitwise-shift-operators","title":"Bitwise Shift Operators","text":"<p>Shift operators are simple and intuitive they move the bits within a number by one to the left or the right, effectively doubling or halving the value.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int b = 7;\n\n    a &lt;&lt;= 2;\n    b &gt;&gt;= 2;\n\n    std::cout &lt;&lt; \"Number A: \" &lt;&lt; a &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Number B: \" &lt;&lt; b &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Number A: 20\nNumber B: 1\n</code></pre> explanation<pre><code>&lt;&lt;2 0101 = 5     \n--------\n  010100 = 20\n\n\n&gt;&gt;2 0111 = 7\n--------\n      01 = 1\n</code></pre> <p>In the examples, we can see that when a bit shifts out of scope, it is replaced with a zero on the opposite side of the shift direction.</p> <p>Note</p> <p>It is not necessary to use bit shifting instead of multiplying normally because the compiler is smart. When normal multiplication is involved and optimization is possible, the compiler will use the bit-shifting method automatically. Therefore, it is better to keep the code simple, understandable, and readable.</p>"},{"location":"03%20Operators/#bitwise-logic-operators","title":"Bitwise Logic Operators","text":"<p>Similar to regular logical operators that compare two variables, bitwise logic operators operate directly on individual bits and compare them between each other. Each logical operation can be described using a truth table.</p>"},{"location":"03%20Operators/#bitwise-and","title":"Bitwise AND","text":"<p>Bitwise AND (<code>&amp;</code>) is used for masking and isolating specific bits. This is exactly what happens, for example, in IPv4 networking when masks are used to separate the network and host portions of an address.</p> A B AND 0 0 0 0 1 0 1 0 0 1 1 1 main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int b = 13;\n    a &amp;= b;\n\n    std::cout &lt;&lt; \"Number A: \" &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Number A: 5\n</code></pre> explanation<pre><code>  0101   = 5\n&amp; 1101   = 13\n--------\n  0101   = 5\n</code></pre> <p>Let\u2019s go through how masking works using the bitwise AND operator. We\u2019ll use the example of a private IPv4 address: <code>192.168.0.10</code> with a <code>/24</code> prefix. </p> <p>If you have no background in networking, don\u2019t worry \u2014 we\u2019ll briefly explain what\u2019s going on.</p> <p>The address is a 32-bit number, divided into 4 octets separated by dots (<code>.</code>). It represents the address of a host device, such as a laptop.</p> <p>The prefix (in this case <code>/24</code>) indicates how many bits belong to the network part of the address.</p> explanation<pre><code>  1100 0000 . 1010 1000 . 0000 0000 . 0000 1010 = 192.168.0.10  -&gt; host address\n&amp; 1111 1111 . 1111 1111 . 1111 1111 . 0000 0000 = 255.255.255.0 -&gt; prefix /24\n  ---------------------------------------------\n  1100 0000 . 1010 1000 . 0000 0000 . 0000 0000 = 192.168.0.0   -&gt; network address\n</code></pre> <p>This way, we can determine which network the IP address belongs to and how many bits remain for identifying host devices within that network.</p> <p>In our example, the <code>/24</code> prefix means that the first 24 bits (3 full octets) are used to identify the network, while the remaining 8 bits are reserved for host addresses. That gives us:</p> Type Address Network address <code>192.168.0.0</code> Range of host addresses <code>192.168.0.1</code> to <code>192.168.0.254</code> Broadcast address <code>192.168.0.255</code> <p>This technique of using a bitmask (in this case, <code>255.255.255.0</code>) allows computers and routers to efficiently determine whether two IP addresses are part of the same network, which is essential for routing traffic.</p>"},{"location":"03%20Operators/#bitwise-or","title":"Bitwise OR","text":"<p>Bitwise OR (<code>|</code>) is used for setting and combining bits. It\u2019s helpful when you want to ensure that certain bits are turned on (set to 1) without affecting the others.</p> A B OR 0 0 0 0 1 1 1 0 1 1 1 1 main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int b = 13;\n    a |= b;\n\n    std::cout &lt;&lt; \"Number A: \" &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Number A: 13\n</code></pre> explanation<pre><code>  0101   = 5\n| 1101   = 13\n--------\n  1101   = 13\n</code></pre> <p>With bitwise OR in combination with a bitwise left shift (<code>&lt;&lt;</code>), we can reconstruct a number after part of it was masked using a bitwise AND. This is particularly useful in low-level programming tasks like restoring structured binary data, combining partial values, or decoding packed data fields.</p> <p>The idea is that if you previously split a number into two parts \u2014 for example, by masking the lower bits and extracting the upper bits \u2014 you can later restore the original by placing the upper part back into its correct position (via shifting) and using <code>|</code> to merge both parts.</p> explanation<pre><code>      00000101             -&gt; Lower 4 bits (e.g., extracted via AND)\n&lt;&lt; 4  10110000             -&gt; Shift upper 4 bits back into place\n--------------\n      10110000\n|     00000101             -&gt; Combine both with OR\n--------------\n      10110101             -&gt; Reconstructed original value\n</code></pre>"},{"location":"03%20Operators/#bitwise-xor","title":"Bitwise XOR","text":"<p>Bitwise XOR (<code>^</code>) is commonly used in low-level programming for toggling bits, clearing flags, and also in more advanced applications like encryption, checksums, and hashing.</p> A B XOR 0 0 0 0 1 1 1 0 1 1 1 0 main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int b = 13;\n    a ^= b;\n\n    std::cout &lt;&lt; \"Number A: \" &lt;&lt; a &lt;&lt; std::endl; \n}\n</code></pre> output<pre><code>Number A: 8\n</code></pre> explanation<pre><code>  0101  = 5\n^ 1101  = 13\n------\n  1000  = 8\n</code></pre> <p>An interesting property of XOR is that when a number is XORed with itself, the result is always zero.</p> <p>Another powerful aspect of XOR is its reversibility, if you XOR a number with another value and then XOR the result with the same value again, you get back the original number. This enables swapping values without a temporary variable.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int b = 13;\n\n    std::cout &lt;&lt; \"Before swap: a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt; std::endl;\n\n    a ^= b;\n    b ^= a;\n    a ^= b;\n\n    std::cout &lt;&lt; \"After swap:  a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Before swap: a = 5, b = 13\nAfter swap:  a = 13, b = 5\n</code></pre> explanation<pre><code>  0101  = 5\n^ 1101  = 13\n------\n  1000  = 8   -&gt; new value of 'a'\n^ 1101  = 13\n------\n  0101  = 5   -&gt; new value of 'b'\n^ 1000  = 8\n------\n  1101  = 13  -&gt; new value of 'a'\n</code></pre>"},{"location":"03%20Operators/#bitwise-not","title":"Bitwise NOT","text":"<p>Bitwise NOT (<code>~</code>) is used to invert all bits in a number.</p> A NOT 0 1 1 0 main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    std::cout &lt;&lt; \"Original: \" &lt;&lt; std::bitset&lt;4&gt;(a) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Inverted: \" &lt;&lt; std::bitset&lt;4&gt;(~a) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Original: 0101\nInverted: 1010\n</code></pre> explanation<pre><code>~ 0101  = 5\n------\n  1010  = 10\n</code></pre>"},{"location":"03%20Operators/#writing-binary-hexadecimal-and-octal-values-in-c","title":"Writing Binary, Hexadecimal and Octal Values in C++","text":"<p>We covered an introduction to binary number representation and how bitwise operators manipulate individual bits. So far, we\u2019ve used integers assigned through the decimal system, but it\u2019s also possible to assign values directly using binary, hexadecimal, or even octal notation. This is done by prefixing the number with <code>0b</code> for binary, <code>0x</code> for hexadecimal, or a leading <code>0</code> for octal, followed by the appropriate value.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 0b0101;\n    int b = 0xff;\n    int c = 015;\n\n    std::cout &lt;&lt; \"Number A: \" &lt;&lt; a &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Number B: \" &lt;&lt; b &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Number C: \" &lt;&lt; c &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Number A: 5\nNumber B: 255\nNumber C: 13\n</code></pre> <p>This can also be done in reverse, we can assign values using decimal numbers and output their binary, hexadecimal, and octal representations. However, for the binary representation, we will need the <code>&lt;bitset&gt;</code> library.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n\nint main() {\n    int a = 5;\n    int b = 13;\n\n    std::cout &lt;&lt; \"Decimal: \"   &lt;&lt; a\n              &lt;&lt; \" | Binary: \" &lt;&lt; std::bitset&lt;4&gt;(a)\n              &lt;&lt; \" | Hex: \"    &lt;&lt; std::hex &lt;&lt; a\n              &lt;&lt; \" | Octal: \"  &lt;&lt; std::oct &lt;&lt; a &lt;&lt; std::dec &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Decimal: \"   &lt;&lt; b\n              &lt;&lt; \" | Binary: \" &lt;&lt; std::bitset&lt;4&gt;(b)\n              &lt;&lt; \" | Hex: \"    &lt;&lt; std::hex &lt;&lt; b\n              &lt;&lt; \" | Octal: \"  &lt;&lt; std::oct &lt;&lt; b &lt;&lt; std::dec &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Decimal: 5 | Binary: 0101 | Hex: 5 | Octal: 5\nDecimal: 13 | Binary: 1101 | Hex: d | Octal: 15\n</code></pre> <p>The new function used here is <code>std::bitset&lt;T&gt;(int)</code>, which converts an integer into its binary representation as a string. Replace <code>T</code> with the number of bits you want to display, and provide the integer value as the argument.</p> <p>For hexadecimal output, we use <code>std::hex</code>, which tells the stream to display numbers in base 16. Similarly, <code>std::oct</code> is used for base 8 representation.</p> <p>Warning</p> <p>Remember to reset the output stream back to decimal using <code>std::dec</code>, as the formatting change is persistent. If you don\u2019t reset it, the program will continue printing numbers in the last format you set.</p>"},{"location":"03%20Operators/#ternary-operator","title":"Ternary Operator","text":"<p>The ternary operator is a shorthand for an <code>if-else</code> statement, often called an inline if statement. It provides a more concise way to express simple conditional expressions.</p> <p>It uses the <code>?</code> operator to check a condition and the <code>:</code> operator to separate the two possible results (true case and false case).</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int number = 5;\n\n    if (number % 2 == 0)\n        std::cout &lt;&lt; \"number is even\" &lt;&lt; std::endl;\n    else\n        std::cout &lt;&lt; \"number is odd\" &lt;&lt; std::endl;\n\n    number % 2 == 0 ? std::cout &lt;&lt; \"number is even\" &lt;&lt; std::endl \n                    : std::cout &lt;&lt; \"number is odd\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>number is odd\nnumber is odd\n</code></pre>"},{"location":"03%20Operators/#operator-overloading","title":"Operator Overloading","text":"<p>Info</p> <p>This section is considered more advanced at this point, as it requires knowledge of functions and user-defined types. If you're not yet comfortable with those concepts, feel free to skip this section and return to it later once you're more confident.</p> <p>Behind the scenes the operators are just functions and similar to them they can be in the same sense overloaded.</p>"},{"location":"03%20Operators/#chapter-summary","title":"Chapter Summary","text":"<p>In this chapter, we explored the core set of operators in C++ that form the basis for performing calculations, comparisons, and logic in programming.</p>"},{"location":"04%20Functions/","title":"04 Functions","text":"<p>In programming, we often run into situations where we need to reuse the same logic multiple times. Take, for example, calculating the hypotenuse using the Pythagorean theorem. If we need to perform this calculation several times\u2014say, four times\u2014we wouldn\u2019t want to rewrite the same code each time.</p> <p>Not only would that be inefficient, but if we ever needed to make a change, we\u2019d have to update every copy of the code manually. This creates extra work and increases the chance of introducing bugs.</p> <p>Instead, we aim to make our code more reusable and readable\u2014and that\u2019s exactly where functions come in. Functions let us define a block of code once and reuse it by simply calling its name. This avoids duplication and makes our code easier to maintain and reason about.</p> <p>You\u2019ve already seen one example of a function: the main function. It\u2019s the special entry point of every C and C++ program. However, main is unique in that it only appears once per program and cannot be renamed.</p>"},{"location":"04%20Functions/#function-creation","title":"Function Creation","text":"<p>A function in C++ is made up of two parts; the declaration, which specifies how to call the function, and the definition, which contains the actual code that runs when the function is called.</p> <p>The declaration, also called the function signature, includes four key elements.</p> Part Description Return Type The data type of the value the function returns. If nothing is returned, it uses the <code>void</code> type. Function Name A unique identifier to call the function. Parameter List Input values the function accepts (can be empty if no inputs are needed). Function Body The block of code executed when the function is called. <p>When creating functions, it\u2019s important to declare them before they are used to avoid errors. Also, keep each function focused on a single task as it helps make your code easier to read, maintain, and reuse.</p> signiture<pre><code>&lt;return_type&gt; &lt;function_name&gt;(&lt;parameter_type&gt; &lt;parameter_name&gt;, ...) {\n    &lt;function_body&gt;\n}\n</code></pre> <p>Functions receive input and output data, but there is no rule that requires them to take arguments or return a value. If a function doesn't return any data, we use a unique data type called <code>void</code>, which explicitly indicates that the function does not return a value.</p> <p>Functions with a <code>void</code> return type are primarily used for performing actions such as outputting to the terminal or working with pointers and references, where returning a value is unnecessary.</p> <p>Example of the simplest function used to reduce the amount of code needed to print output to the terminal.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid PrintText() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"I am learning C++\" &lt;&lt; std::endl;\n}\n\nint main() {\n    PrintText();\n    PrintText();\n    PrintText();\n    PrintText();\n}\n</code></pre> output<pre><code>Hello World!\nI am learning C++\nHello World!\nI am learning C++\nHello World!\nI am learning C++\nHello World!\nI am learning C++\n</code></pre>"},{"location":"04%20Functions/#return-values","title":"Return Values","text":"<p>If we want to retrieve information from an operation performed inside a function and store it in a variable in the <code>main</code> function, we use the <code>return</code> keyword. This sends data, such as a number, a variable's value, or a direct expression, back to the caller. However, the function's return type must match the type of data being returned.</p> <p>Here, we will calculate the value of the hypotenuse using the Pythagorean theorem and return the result of the expression back to the caller for output.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nfloat PythagoreanTheorem() {\n    return std::sqrt(pow(3, 2) + std::pow(4, 2));\n}\n\nint main() {\n    std::cout &lt;&lt; \"Hypotenuse = \" &lt;&lt; PythagoreanTheorem() &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hypotenuse = 5\n</code></pre> <p>Note</p> <p>This example introduces the <code>&lt;cmath&gt;</code> header, which provides functions for a wide range of mathematical operations. For any math function, <code>&lt;cmath&gt;</code> is the go-to header.</p> <p>See the full list of its math functions here: https://cplusplus.com/reference/cmath/</p>"},{"location":"04%20Functions/#mandatory-return-values","title":"Mandatory Return Values","text":"<p>When a function has a non-void return type, it must return a value of the specified data type. Failing to do so results in undefined behavior.</p> <p>The only exception to this rule is the <code>main</code> function. Even though <code>main</code> is typically declared as returning <code>int</code>, we don\u2019t always see an explicit return statement. This is because modern C++ compilers automatically add <code>return 0;</code> at the end of <code>main</code>, indicating that the program executed successfully.</p>"},{"location":"04%20Functions/#multiple-return-values","title":"Multiple Return Values","text":"<p>Info</p> <p>This section is considered more advanced at this point, as it requires knowledge of user-defined types. If you're not yet comfortable with those concepts, feel free to skip this section and return to it later once you're more confident.</p> <p>There are situations where we need to return more than one value from a function. For example, in a game, you might want a function to return a player's position \u2014 <code>x</code>, <code>y</code>, and <code>z</code> coordinates. It would be inefficient and messy to create a separate function for each coordinate.</p> <p>This problem can be solved in several ways, but the most preferred and readable solution is using a structure, which groups related values into a single type.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vec3 {\n    float x;\n    float y;\n    float z;\n};\n\nVec3 GetPlayerCoords() {\n    return Vec3 {\n        .x = 43.4,\n        .y = 38.2,\n        .z = 29.5\n    };\n}\n\nint main() {\n    Vec3 player_position = GetPlayerCoords();\n\n    std::cout &lt;&lt; \" x: \" &lt;&lt; player_position.x &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" y: \" &lt;&lt; player_position.y &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" z: \" &lt;&lt; player_position.z &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code> x: 43.4\n y: 38.2\n z: 29.5\n</code></pre> <p>While using a <code>struct</code> is not the only way to return multiple values in C++, it is often the clearest and most maintainable option.</p> <p>C++ also provides other tools for returning multiple values, such as:</p> <ul> <li><code>std::tuple</code> \u2013 a general-purpose container for fixed-size groups of values.</li> <li><code>std::pair</code> \u2013 similar to a tuple but limited to two values.</li> </ul> <p>These options will be discussed later, but for now, <code>struct</code> is a great starting point for clean and understandable code.</p>"},{"location":"04%20Functions/#parameter-list","title":"Parameter List","text":"<p>To make the function even more reusable, it would be useful to pass our own values into it. This is possible through the parameter list. The parameter list is created by declaring empty variables inside the parentheses of the function declaration, these are called parameters.</p> <p>Also, parameters and arguments are often used interchangeably, but technically:</p> <ul> <li>Parameters refer to the variables in the function declaration.</li> <li>Arguments are the actual values passed when calling the function.</li> </ul> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nfloat PythagoreanTheorem(float a, float b) {\n    return std::sqrt(pow(a, 2) + std::pow(b, 2));\n}\n\nint main() {\n    std::cout &lt;&lt; \"Hypotenuse = \" &lt;&lt; PythagoreanTheorem(3, 4) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hypotenuse = 5\n</code></pre> <p>Parameters are assigned values during the function call, following the exact order in which they were defined. These values can be either direct numbers or variables, but their types must always match the function's parameter types.</p>"},{"location":"04%20Functions/#function-declaration-vs-definition","title":"Function Declaration vs. Definition","text":"<p>The difference between a declaration and a definition is that a declaration only specifies the function\u2019s signature (return type, name, and parameters) and essentially informs the compiler that the function exists. The definition, on the other hand, includes the actual implementation and logic of the function.</p>"},{"location":"04%20Functions/#keep-functions-practical","title":"Keep Functions Practical","text":"<p>While functions are essential for code reusability and readability, it's important not to overuse them. Creating functions for every minor operation can lead to cluttered code that is difficult to maintain.</p> <p>Additionally, every time a function is called, the compiler generates a call instruction, which introduces overhead. The program must:</p> <ol> <li>Create a stack frame for the function</li> <li>Push the parameters onto the stack</li> <li>Store the return address</li> <li>Jump to a different part of the binary to execute the function</li> </ol> <p>All these memory operations can slow down the program, especially if the function isn't inlined (meaning that the implementation is tranformed into code that is inserted in the function stead) by the compiler.</p> <p>A good rule of thumb is that if you find yourself repeating the same logic multiple times, it\u2019s likely a good candidate for a function.</p>"},{"location":"04%20Functions/#function-overloading","title":"Function Overloading","text":"<p>Function overloading occurs when we define multiple functions with the same name but different types or counts of parameters, allowing the function to perform the same action for different types of input.</p> <p>For example, imagine we want to create a function for printing to the terminal that can handle multiple data types, such as integers or strings. If a function is defined to accept only an int, passing a string, float, or char might cause data loss or a compiler error.</p> <p>To solve this, we can overload the function\u2014define multiple versions of it, each tailored to handle a different type of input. The compiler will then automatically choose the correct one based on the arguments you pass.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nvoid Print(int value) {\n    std::cout &lt;&lt; \"Integer only version: \" &lt;&lt; value &lt;&lt; std::endl;\n}\n\nvoid Print(double value) {\n    std::cout &lt;&lt; \"Double only version: \" &lt;&lt; value &lt;&lt; std::endl;\n}\n\nvoid Print(int value1, double value2) {\n    std::cout &lt;&lt; \"Combined version: \" &lt;&lt; value1 &lt;&lt; \" | \" &lt;&lt; value2 &lt;&lt; std::endl;\n}\n\nint main() {\n    Print(11);\n    Print(74.53);\n    Print(11, 74.53);\n}\n</code></pre> output<pre><code>Integer only version: 11\nString only version: Hello, World!\nCombined version: 11 | Hello World!\n</code></pre>"},{"location":"04%20Functions/#inline-functions","title":"Inline Functions","text":"<p>When we define a function, even if it's just a single line, every time we call it, the program performs a jump to the function's memory location, runs the code, and then jumps back. This adds a bit of overhead, especially when calling very small functions repeatedly.</p> <p>To reduce this overhead for short, frequently-used functions, we can use the <code>inline</code> keyword. Instead of making the program jump, the compiler replaces the function call with the actual code of the function\u2014essentially copying and pasting it at the call site.</p> <p>This technique can slightly improve performance by avoiding function call overhead, especially in tight loops or small helper functions.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\ninline int Square(int x) {\n    return x * x;\n}\n\nint main() {\n    std::cout &lt;&lt; Square(4) &lt;&lt; std::endl;\n    std::cout &lt;&lt; Square(7) &lt;&lt; std::endl;\n\n    /*\n        In both cases, because we used the inline keyword,\n        the function calls will be replaced by the compiler\n        with the actual expression\n\n        std::cout &lt;&lt; 4 * 4 &lt;&lt; std::endl;\n        std::cout &lt;&lt; 7 * 7 &lt;&lt; std::endl;\n    */\n}\n</code></pre> <p>Note</p> <p>The <code>inline</code> keyword is a suggestion to the compiler, not a command. Modern compilers are smart enough to decide whether inlining is worth it, even without the keyword.</p> <p>Inline functions are best used for very short functions (like getters, setters, or simple calculations).</p> <p>Avoid using <code>inline</code> on large functions\u2014it can increase code size, which may negatively affect performance due to cache misses.</p>"},{"location":"04%20Functions/#lambdas","title":"Lambdas","text":"<p>Lambdas, also known as anonymous functions, let you define small, unnamed functions directly at the point of use. They're mainly intended for short, one-off operations and behave like disposable function objects. Lambdas are especially useful when you need to run a quick piece of logic without declaring a full function elsewhere. They can also capture and use variables from the surrounding scope, making them both powerful and flexible.</p>"},{"location":"04%20Functions/#when-to-use-lambdas","title":"When to use lambdas","text":"<p>Whenever you have a function pointer, you can use a lambda in C++. The best example of this is when we need to pass a function to an API so that it can call the function at a later time. Lambdas are ideal for defining code that should run in the future.</p> <p>This is useful when:</p> <ul> <li>The function requires data that isn\u2019t available yet.</li> <li>We want to defer execution but still specify which function to call when needed.</li> </ul> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n\nvoid ForEach(const std::vector&lt;int&gt;&amp; values, const std::function&lt;void(int)&gt;&amp; func) {\n    for (int value : values)\n        func(value);\n}\n\nint main() {\n    std::vector&lt;int&gt; values = {27, 64, 3, 89, 51};\n\n    std::function&lt;void(int)&gt; lambda = [](int value) { \n        std::cout &lt;&lt; value &lt;&lt; '\\t'; \n    };\n\n    ForEach(values, lambda);\n}\n</code></pre> output<pre><code>27  64  3   89  51  \n</code></pre> <p>The square brackets before a lambda expression are called capture clauses. They allow the lambda to access variables from the surrounding scope using different capture modes, which are specified with various symbols.</p> Capture Syntax Description <code>[]</code> No capture \u2013 the lambda has no access to outer variables. <code>[variable]</code> Capture by value \u2013 creates a copy of <code>variable</code>. <code>[&amp;variable]</code> Capture by reference \u2013 modifies the original <code>variable</code>. <code>[=]</code> Capture all by value \u2013 copies all outer variables used. <code>[&amp;]</code> Capture all by reference \u2013 references all outer variables. <code>[variable1, &amp;variable2]</code> Mixed capture \u2013 <code>variable1</code> by value, <code>variable2</code> by reference. <p>These captured variables are read-only by default when captured by value. If you want to modify them inside the lambda, you need to use the <code>mutable</code> specifier after the parameter list.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int count = 10;\n\n    auto lambda = [count]() mutable { \n        count++;  // Allowed because of `mutable`\n        std::cout &lt;&lt; \"Lambda modified count: \" &lt;&lt; count &lt;&lt; std::endl;\n    };\n\n    lambda();\n\n    std::cout &lt;&lt; \"Original count: \" &lt;&lt; count &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Lambda modified count: 11\nOriginal count: 10\n</code></pre>"},{"location":"04%20Functions/#lambda-use-case","title":"Lambda Use Case","text":"<p>A common use case for lambda expressions is within algorithm functions, such as <code>std::find_if</code>. This function, which is part of the <code>&lt;algorithm&gt;</code> header, is used to find a specific value in an iterable data structure based on a given condition.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    std::vector&lt;int&gt; values = {1, 5, 4, 2, 3};\n\n    auto it = std::find_if(values.begin(), values.end(), [](int value) { \n        return value &gt; 3;\n    });\n\n    std::cout &lt;&lt; \"First number bigger than 3: \" &lt;&lt; *it &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>First number bigger than 3: 5\n</code></pre>"},{"location":"04%20Functions/#chapter-summary","title":"Chapter Summary","text":"<p>In this chapter, we explored the fundamental concepts of functions in C++, from their declaration to advanced topics like lambdas.</p> <ul> <li>Function Declarations and Definitions: A function must be declared before use and defined properly to ensure correctness.</li> <li>Return Values: Every function that returns a value must do so explicitly, and multiple return values can be achieved using structures.</li> <li>Parameter Lists: Functions can accept parameters by value, reference, or pointer, affecting performance and memory usage.</li> <li>Practicality: Functions should be small, well-defined, and reusable to improve readability and maintainability.</li> <li>Lambdas provide a concise way to define small, inline functions, making them useful for callbacks, functional programming, and local scope operations.</li> </ul>"},{"location":"05%20Data%20Types/","title":"05 Data Types","text":"<p>By now, we've covered the absolute basics. As part of that foundation, we introduced fundamental primitive data types such as integers, characters, and floating-point numbers, along with the kinds of values they can represent.</p> <p>In the next few chapters, we\u2019ll start working more closely with memory. As we go deeper into the language, it becomes increasingly important to understand how memory behaves\u2014especially when working with a lower-level language like C++. At this point, it\u2019s not just about writing code that works; it\u2019s about knowing what\u2019s really happening behind the scenes.</p> <p>As part of our earlier foundation, we introduced primitive data types, which act as the building blocks for all data structures. Now, it\u2019s time to look more closely at how these basic types can be refined and extended into more specialized or optimized forms, depending on the needs of your data.</p>"},{"location":"05%20Data%20Types/#static-and-strong-typing","title":"Static and Strong Typing","text":"<p>C++ is a statically typed language. This means that the data type of every variable must be explicitly declared and known at compile time. In other words, the compiler needs to know what kind of data each variable will hold before the program runs.</p> <p>This requirement brings a few important benefits. First, it allows the compiler to catch many type-related errors early\u2014before the code ever executes. Second, it enables more efficient memory usage and better optimization. After all, the data type of a variable determines how much memory it occupies and how that memory is interpreted during execution\u2014which in turn affects how the program interacts with the system\u2019s memory layout.</p> <p>Compared to dynamically typed languages such as Python and JavaScript, where types are resolved at runtime. C++\u2019s static typing provides stronger guarantees and performance benefits\u2014though at the cost of some flexibility.</p> <p>C++ is also considered a strongly typed language. This refers to how strictly the language enforces type rules. While C++ allows you to perform type conversions (also called casting), the compiler won't let you mix incompatible types without an explicit cast. This helps prevent unintended behavior or subtle bugs caused by incorrect assumptions about how data is represented in memory.</p>"},{"location":"05%20Data%20Types/#primitive-data-types","title":"Primitive Data Types","text":"<p>In the introduction chapter, we introduced some of the primitive data types to kick-start your learning\u2014but that was just the absolute core. To give you more control and flexibility, C++ actually offers a broader range of primitive types, enabling more precise management of memory and data.</p>"},{"location":"05%20Data%20Types/#standard-integer-types","title":"Standard Integer Types","text":"Type Size Signed Range <code>char</code> 1 byte -128 to 127 <code>short</code> 2 bytes -32,768 to 32,767 <code>int</code> 4 bytes -2,147,483,648 to 2,147,483,647 <code>long</code> 4 or 8 bytes Depends on the system <code>long long</code> 8 bytes -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 <p>Note</p> <p>On many 64-bit systems, <code>int</code> and <code>long</code> are both 4 bytes, but this can vary depending on the compiler and platform.</p>"},{"location":"05%20Data%20Types/#fixed-width-integer-types","title":"Fixed-Width Integer Types","text":"<p>These types guarantee their size across different systems and compilers. But to use the fixed-width integer types ending with <code>_t</code>, you need to include the <code>&lt;cstdint&gt;</code> header.</p> Type Size Signed Range / Purpose <code>int8_t</code> 1 byte -128 to 127 <code>int16_t</code> 2 bytes -32,768 to 32,767 <code>int32_t</code> 4 bytes -2,147,483,648 to 2,147,483,647 <code>int64_t</code> 8 bytes -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 <code>size_t</code> 4 or 8 bytes Represents the size of any object in memory (always unsigned) <p>Note</p> <p>Types like <code>intptr_t</code> and <code>uintptr_t</code> are integer types capable of storing pointer values. They\u2019re mostly useful in low-level or systems programming, such as writing memory managers or interfacing with hardware. Most C++ applications will never need them.</p> <p>Note</p> <p>Similarly, <code>intmax_t</code> and <code>uintmax_t</code> represent the largest signed and unsigned integer types available on a given platform. While they sound powerful, they\u2019re rarely used in everyday programming and are mainly helpful in highly portable libraries or template-heavy code. For most use cases, fixed-width types like <code>int64_t</code> or <code>size_t</code> are a better fit.</p>"},{"location":"05%20Data%20Types/#unsigned-integers","title":"Unsigned Integers","text":"<p>Signed integers divide their range between positive and negative numbers, effectively splitting their capacity in half.</p> <p>However, in many cases, negative numbers are unnecessary or nonsensical. For example, color channels use values from 0 to 255, and array sizes or memory addresses are always non-negative.</p> <p>In these scenarios, using a signed integer like int8_t would be wasteful because half of the range goes unused.</p> <p>To allocate the entire bit range exclusively for non-negative values you can use unsigned types. For example, <code>uint8_t</code> ranges from 0 to 255, doubling the maximum value you can store in the same memory size.</p> Type Unsigned Range <code>unsigned char</code> 0 to 255 <code>unsigned short</code> 0 to 65,535 <code>unsigned int</code> 0 to 4,294,967,295 <code>unsigned long</code> Depends on system <code>unsigned long long</code> 0 to 18,446,744,073,709,551,615 <code>uint8_t</code> 0 to 255 <code>uint16_t</code> 0 to 65,535 <code>uint32_t</code> 0 to 4,294,967,295 <code>uint64_t</code> 0 to 18,446,744,073,709,551,615"},{"location":"05%20Data%20Types/#floating-point-types","title":"Floating-Point Types","text":"Type Size Precision (Approx.) Range <code>float</code> 4 bytes ~6-7 decimal digits \u00b11.5 \u00d7 10\u207b\u2074\u2075 to \u00b13.4 \u00d7 10\u00b3\u2078 <code>double</code> 8 bytes ~15-16 decimal digits \u00b15.0 \u00d7 10\u207b\u00b3\u00b2\u2074 to \u00b11.8 \u00d7 10\u00b3\u2070\u2078 <code>long double</code> 8-16 bytes Varies Higher precision than <code>double</code> <p>Note</p> <p><code>double</code> is the default choice for floating-point arithmetic, providing more precision with minimal performance loss. However, when memory usage is critical, float may be preferred. To use floats, you must explicitly specify them by appending the value with an <code>f</code> suffix (e.g., 3.14f). Otherwise, the compiler treats floating-point literals as double by default.</p>"},{"location":"05%20Data%20Types/#character-types","title":"Character Types","text":"<p>So far, we have introduced only ASCII character encoding, which supports 128 characters (or 256 in extended ASCII). However, ASCII is insufficient for representing the full range of characters used worldwide.</p> <p>To address this, other encodings were developed, with UTF-8 becoming the most widely used due to its flexibility and backward compatibility with ASCII.</p> <p>UTF-8 can represent a wide variety of characters, including:</p> <ul> <li>Latin characters with diacritics: <code>\u00e9, \u00f1, \u00fc, \u010d, \u0161</code></li> <li>Mathematical symbols: <code>\u221e, \u2211, \u03c0, \u221a</code></li> <li>Currency symbols: <code>\u20ac, \u00a5, \u20b9, \u20bf</code></li> <li>Emoji: <code>\ud83d\ude00, \u2764\ufe0f, \ud83d\ude80, \ud83d\udd25</code></li> <li>Non-Latin scripts: <code>\u4f60\u597d (Chinese), \u041f\u0440\u0438\u0432\u0435\u0442 (Russian), \u0928\u092e\u0938\u094d\u0924\u0947 (Hindi), \u0627\u0644\u0639\u0631\u0628\u064a\u0629 (Arabic)</code></li> </ul> Type Size Prefix Description <code>char</code> 1 byte None Holds a single character (typically ASCII) <code>wchar_t</code> 2 or 4 bytes <code>L'A'</code> Wide character (Unicode, size platform-dependent) <code>char8_t</code> 1 byte <code>u8'A'</code> UTF-8 character (C++20) <code>char16_t</code> 2 bytes <code>u'A'</code> UTF-16 character (Unicode) <code>char32_t</code> 4 bytes <code>U'A'</code> UTF-32 character (Unicode) <p>These specialized types require prefixes before assigning literals to indicate their encoding.</p> <p>Handling non-ASCII characters in the terminal can be tricky, especially on Windows. To support UTF-8 output, you need to include the <code>windows.h</code> header and adjust settings via its functions. On Linux and macOS, this usually works without additional setup.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;windows.h&gt;\n\n#pragma execution_character_set(\"utf-8\")\n\nint main() {\n    SetConsoleOutputCP(CP_UTF8);\n\n    std::cout &lt;&lt; \"Testing unicode: \" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" - English\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" - \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" - Espa\u00f1ol\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" - \u0420\u0443\u0441\u0441\u043a\u0438\u0439\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" - a\u00e4bcdefghijklmno\u00f6pqrs\u00dftu\u00fcvwxyz\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Testing unicode:\n - English\n - \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac\n - Espa\u00f1ol\n - \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n - a\u00e4bcdefghijklmno\u00f6pqrs\u00dftu\u00fcvwxyz\n</code></pre> <p>Note</p> <p>It\u2019s  best to avoid non-ASCII characters in your source code unless necessary (e.g., in GUI applications). Non-ASCII characters can complicate compatibility across different environments and are rarely required in typical C++ code.</p>"},{"location":"05%20Data%20Types/#automatic-type-inference","title":"Automatic Type Inference","text":"<p>Before diving into this section, it\u2019s helpful to have a grasp of data structures, since type inference often involves more complex types like containers and iterators.</p> <p>In C++, data types determine what kind of data a variable can hold and how much memory it uses. Manually specifying types can sometimes be tedious or verbose\u2014especially when the type is obvious from the context. That\u2019s where the auto keyword comes in: it lets the compiler automatically deduce the variable\u2019s type based on its initializer, assignment, or the return value of a function.</p> <p>Using auto can simplify your code and make it more concise, but it\u2019s not without trade-offs. Overusing it may reduce readability, making it harder to quickly understand what a variable represents. It can also introduce subtle bugs if the inferred type doesn\u2019t match your intentions, especially as your code evolves over time.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstd::string GetName() {\n    return \"name\";\n}\n\nint main() {\n    auto name = GetName(); // inferred as std::string\n\n    // safe, std::string supports .size()\n    std::cout &lt;&lt; \"String size: \" &lt;&lt; name.size();\n}\n</code></pre> output<pre><code>String size: 4\n</code></pre> <p>Here, name is correctly inferred as <code>std::string</code>. However, if the return type of <code>GetName()</code> were changed to <code>const char*</code>, this code would no longer compile\u2014C-style strings don\u2019t support the .size() method.</p> <p>This is a good example of how type inference can become fragile when the underlying return type changes. In such cases, using an explicit type can help make your code more predictable.</p> <p>One place where auto truly shines is in range-based for loops, where the element type is usually obvious and unlikely to change.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nint main() {\n    std::array&lt;int, 5&gt; array{17, 48, 92, 64, 88};\n\n    for (const auto&amp; element : array)\n        std::cout &lt;&lt; element &lt;&lt; '\\t';\n}\n</code></pre> output<pre><code>17  48  92  64  88\n</code></pre> <p>Here, <code>auto</code> makes the loop cleaner and more readable, without sacrificing clarity or safety. Since the type of element is tightly bound to the container, there's little risk of confusion or error.</p>"},{"location":"05%20Data%20Types/#determining-the-byte-size-of-variables","title":"Determining the Byte Size of Variables","text":"<p>You can get the byte size of any variable using the <code>sizeof</code> operator. Even compound structures like C-style arrays can be measured this way, which is useful because it lets you calculate the number of elements in the array using a simple formula: the total byte size of the array divided by the byte size of a single element.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int array[] = {37, 82, 14, 69, 5};\n\n    int size_of_array = sizeof(array) / sizeof(array[0]);\n\n    for (int i = 0; i &lt; size_of_array; ++i)\n        std::cout &lt;&lt; array[i] &lt;&lt; '\\t';\n}\n</code></pre> output<pre><code>37  82  14  69  5\n</code></pre> <p>The <code>sizeof</code> operator can also be used with data types directly. So, instead of dividing by <code>sizeof(array[0])</code>, you could divide by <code>sizeof(int)</code>:</p> <pre><code>int size_of_array = sizeof(array) / sizeof(int);\n</code></pre> <p>This works the same, but it's a bit more error-prone. If you change the array's type, you'd need to update int in multiple places. By dividing by sizeof(array[0]), your code automatically adapts to whatever type the array holds\u2014making it safer and more maintainable.</p>"},{"location":"05%20Data%20Types/#type-casting","title":"Type Casting","text":"<p>Sometimes, we need to reinterpret the data a variable holds by changing its type. This process is called type casting. Type casting is especially important in C++ because it's a statically typed language. As a result, conversions are often necessary when working with different data types together, whether to ensure compatibility or to match the expected type in a specific context.</p> <p>But not all types in C++ are directly compatible, and trying to mix them without conversion can lead to errors or unexpected behavior. Fortunately, C++ provides two main ways to perform type conversions:</p> <ul> <li>Implicit Conversion (Automatic):   In many cases, the compiler can handle type conversions for you\u2014this is called implicit conversion.   For example, assigning an <code>int</code> to a <code>double</code> works automatically, because the compiler knows how to safely widen the value without losing information.</li> <li>Explicit Conversion (Casting):   When a conversion isn\u2019t safe or obvious, C++ requires you to perform an explicit cast.   This tells the compiler, \u201cYes, I know what I\u2019m doing\u2014convert this anyway.\u201d There are several ways to do this, and we\u2019ll cover them.</li> </ul>"},{"location":"05%20Data%20Types/#conversions","title":"Conversions","text":"<p>In C++, conversions are implicit. They occur when the compiler automatically converts one type to another without data loss, such as in arithmetic operations between different types or when assigning a <code>double</code> to an <code>int</code>.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    double pi = 3.14;\n    int value = pi; // Implicit conversion: fractional part is lost\n\n    char a = 'A';\n    int b = a; // Implicit conversion: 'b' is assigned 65 (ASCII value of 'A')\n\n    std::cout &lt;&lt; \"Double to integer conversion: \" &lt;&lt; value &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Character to integer conversion: \" &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Double to integer conversion: 3\nCharacter to integer conversion: 65\n</code></pre>"},{"location":"05%20Data%20Types/#c-style-cast","title":"C-Style Cast","text":"<p>Since C++ is built on top of C, it inherits nearly all of its features, including its casting techniques. The C-style cast is one of the most commonly used casting methods, even in other programming languages, due to its simplicity and ease of use. It is applied by prefixing a variable with a type in parentheses.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int number = 42;\n    void* ptr = &amp;number; // Implicit conversion allowed (int* -&gt; void*)\n\n    int* ptr_num = (int*)ptr; // Explicit cast\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; *ptr_num &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Value: 42\n</code></pre>"},{"location":"05%20Data%20Types/#c-casts","title":"C++ Casts","text":"<p>C-style casts are simple but potentially dangerous. They allow almost any kind of conversion without checks, which can easily lead to undefined behavior. That\u2019s why C++ introduced its own casting operators\u2014<code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, and <code>reinterpret_cast</code>.</p> <p>It\u2019s important to understand that C++ casts don\u2019t add new capabilities beyond what C-style casts can do. Instead, they provide safer and more controlled ways to perform conversions. By using explicit keywords, C++ casts make your intent clear and help the compiler enforce stricter type checks. This reduces the risk of accidental or unsafe conversions.</p> <p>Another benefit is maintainability. Because each cast uses a specific keyword, it's easier to search for and reason about casting operations in your code. That makes tasks like debugging or refactoring much more manageable.</p> <p>In short, C++ casts offer the same power as C-style casts, but with better safety and clarity. While C-style casts are still widely used, especially in older code, you should prefer C++ casts in modern C++ projects. They\u2019re more explicit, more readable overall.</p>"},{"location":"05%20Data%20Types/#static-cast","title":"Static Cast","text":"<p>C++ equivalent of a traditional C-style cast is the <code>static_cast</code>. Unlike C-style casts, it provides better type safety by restricting certain conversions (e.g., removing <code>const</code> or casting between incompatible pointer types) that could lead to undefined behavior.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value = 42;\n    void* void_ptr = &amp;value;\n\n    int* int_ptr = static_cast&lt;int*&gt;(void_ptr);\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; *int_ptr &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Value: 42\n</code></pre>"},{"location":"05%20Data%20Types/#dynamic-cast","title":"Dynamic Cast","text":"<p>Info</p> <p>It is recommended to go through user-defined structures before proceeding further, as the upcoming examples will focus on class behavior and involve casting between classes.</p> <p><code>dynamic_cast</code> adds another layer of safety to <code>static_cast</code> by performing runtime validation. If the cast is unsuccessful, it returns a <code>nullptr</code>. Unlike <code>static_cast</code>, which is evaluated at compile-time, <code>dynamic_cast</code> is evaluated at runtime, making it slightly slower but significantly safer when working with polymorphic class hierarchies.</p> <p>Imagine we have three classes in our game: <code>Entity</code> (the base class), <code>Player</code> and <code>Enemy</code> (both derived from <code>Entity</code>). Casting a <code>Player</code> to <code>Entity</code> is straightforward, as <code>Player</code> already inherits all the properties of <code>Entity</code>, only losing its own unique members in the process.</p> <p>The challenge arises when trying to cast an <code>Entity</code> to a <code>Player</code>. The compiler has no way of knowing whether the <code>Entity</code> instance actually represents a <code>Player</code>, an <code>Enemy</code>, or just a base <code>Entity</code>. With <code>static_cast</code>, the compiler trusts the programmer, but if the cast is incorrect, accessing <code>Player</code>-specific members can lead to a crash.</p> <p>This is where <code>dynamic_cast</code> becomes valuable. If we have an <code>Entity</code> instance that is actually an <code>Enemy</code> and try to cast it to <code>Player</code> using <code>dynamic_cast</code>, the cast will fail and return <code>nullptr</code>, allowing us to safely check the result before accessing <code>Player</code>-specific members.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Entity {\npublic:\n    // Necessary for dynamic_cast to work (ensures a vtable)\n    virtual void PrintName() {\n    }\n};\n\nclass Player : public Entity {\n};\n\nclass Enemy : public Entity {\n};\n\nint main() {\n    // Implicit Cast (correct): Upcasting is safe\n    // Player* player = new Player();\n    // Entity* entity = player;\n\n    // Implicit Cast (incorrect): Attempting to cast an Enemy to a Player\n    Entity* unknown_entity = new Enemy();\n\n    // Explicit C-style Cast (incorrect): It is unsafe without validation\n    // Player* player_cast = (Player*)unknown_entity;\n\n    // Correct usage of dynamic_cast\n    Player* safe_player = dynamic_cast&lt;Player*&gt;(unknown_entity);\n\n    // We can perform a simple check because dynamic_cast returns nullptr if the cast fails\n    if (safe_player) {\n        std::cout &lt;&lt; \"Cast successful\";\n        safe_player-&gt;PrintName();\n    } else {\n        std::cout &lt;&lt; \"Cast failed\";\n    }\n}\n</code></pre> output<pre><code>Cast failed\n</code></pre>"},{"location":"05%20Data%20Types/#constant-cast","title":"Constant Cast","text":"<p>Constant cast serves a single purpose: adding or removing the <code>const</code> qualifier from a variable. This might sound simple, but it has important use cases, especially when dealing with legacy code, function parameters, or APIs that don\u2019t support <code>const</code> properly.</p> <p>Imagine you have a <code>const</code> variable, but you need to modify its value. Normally, C++ prevents this to ensure safety, but <code>const_cast</code> allows you to override this restriction. However, this should only be done when you\u2019re absolutely sure it\u2019s safe, modifying truly <code>const</code> values leads to undefined behavior.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid ChangeValue(const int* ptr) {\n    int* modifiable_ptr = const_cast&lt;int*&gt;(ptr);\n    *modifiable_ptr = 99;\n}\n\nint main() {\n    int value = 42;\n\n    ChangeValue(&amp;value);\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Value: 99\n</code></pre>"},{"location":"05%20Data%20Types/#reinterpret-cast","title":"Reinterpret Cast","text":"<p>Info</p> <p>It is recommended to go through user-defined types before proceeding further, as the upcoming examples will focus on class behavior and involve casting between classes.</p> <p>Reinterpret cast is the most dangerous of all C++ casts, as it allows converting any pointer type to any other pointer type, even if they are unrelated. Unlike <code>static_cast</code>, which ensures some level of type safety, <code>reinterpret_cast</code> simply reinterprets the memory without any validation.</p> <p>The <code>reinterpret_cast</code> is commonly used in low-level programming, such as bit manipulation, working with hardware registers, or handling network protocols. It allows for type punning, which enables treating a block of memory as a different type. However, this cast should be used with caution, as improper usage can lead to undefined behavior and memory corruption.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Data {\n    int x;\n    float y;\n};\n\nint main() {\n    Data data = { 42, 3.14f };\n\n    int* int_ptr = reinterpret_cast&lt;int*&gt;(&amp;data);\n\n    std::cout &lt;&lt; \"Interpreted int: \" &lt;&lt; *int_ptr &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Interpreted int: 42\n</code></pre> <p><code>reinterpret_cast</code> can also convert a pointer into an integer type (<code>uintptr_t</code>), which may be useful in low-level debugging or custom memory management, but should generally be avoided in high-level C++ code.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\nint main() {\n    int value = 42;\n    int* ptr = &amp;value;\n\n    uintptr_t address = reinterpret_cast&lt;uintptr_t&gt;(ptr);\n\n    std::cout &lt;&lt; \"Memory address: \" &lt;&lt; address &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Memory address: 140727907748748\n</code></pre>"},{"location":"05%20Data%20Types/#when-to-cast","title":"When to Cast","text":"<p>Casting should be avoided whenever possible. If explicit conversion is required, consider alternative approaches before resorting to a cast. C++ provides safer mechanisms, such as uniform initialization syntax and automatic type inference, which can help minimize unnecessary conversions.</p> <p>General Guidelines for Casting:</p> <ul> <li>Prefer explicit casting over implicit casting whenever possible.</li> <li>Use uniform initialization (<code>T2{T1}</code>) and <code>auto</code> to reduce unnecessary implicit conversions.</li> <li>During code reviews, scrutinize casts carefully and require clear documentation explaining their necessity. Polymorphism is a valid justification.</li> <li>If casting is unavoidable, document its usage with well-written comments next to each cast or group of casts.</li> <li>Avoid C-style casts (<code>(T)expression</code>), as they are unsafe, bypass type checks, and make code harder to maintain.</li> <li>Do not misuse <code>reinterpret_cast</code> unless you fully understand the potential consequences.</li> <li>Do not remove <code>const</code> qualifiers unless absolutely necessary, as it can lead to unintended side effects.</li> </ul>"},{"location":"05%20Data%20Types/#constants-and-compile-time-constructs","title":"Constants and Compile-Time Constructs","text":"<p>In the introduction chapter, we introduced the idea of constants\u2014variables that are meant to remain unchanged throughout a program's execution. However, we later saw that <code>const</code> can be bypassed with <code>const_cast</code>, which means it doesn't provide absolute immutability. This is generally a bad design choice, as it violates the principle that constants should truly be constant.</p> <p>To ensure a variable or function is genuinely immutable and can be evaluated at compile time, modern C++ provides the <code>constexpr</code> keyword. This is also a type-safe alternative to the old preprocessor macros like <code>#define</code> and offers a more reliable way to express intent in your code.</p>"},{"location":"05%20Data%20Types/#constexpr","title":"Constexpr","text":"<p>The <code>constexpr</code> keyword guarantees that a variable or function is evaluated at compile time. This is especially useful for constants, mathematical functions, and lookup tables that should not change during the program\u2019s lifetime.</p> <p>Unlike <code>const</code>, which merely promises not to modify a variable after initialization, <code>constexpr</code> enforces that the value is computed before runtime. It Allows the compiler to optimize your code by \"hard baking\" the result directly into the binary.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\n// Compile-time constant\nconstexpr int value = 20;\n\n// Compile-time function\nconstexpr int Add(int a, int b) {\n    return a + b + value;\n}\n\nint main() {\n    std::cout &lt;&lt; Add(5, 10) &lt;&lt; std::endl;\n\n    /*\n        After compilation, it becomes this:\n        std::cout &lt;&lt; 5 + 10 + 20 &lt;&lt; std::endl;\n    */\n}\n</code></pre> output<pre><code>35\n</code></pre>"},{"location":"05%20Data%20Types/#consteval-and-constinit","title":"Consteval and Constinit","text":"<p>Warning</p> <p>This is a feature of C++20, so make sure you are using a compatible compiler version to avoid build errors.</p> <p>Modern compilers have become quite good at determining which expressions can be evaluated at compile time, making <code>constexpr</code> slightly less explicit than it once was. However, if you need to guarantee that a function or variable is evaluated at compile time, you should use <code>consteval</code> for functions and <code>constinit</code> for variables.</p> <ul> <li><code>consteval</code> ensures a function is always evaluated at compile time. It cannot accept runtime values as arguments, making it ideal for functions that should never execute at runtime.</li> <li><code>constinit</code> guarantees that a variable is initialized at compile time. It can only be used with static or thread-local variables and requires a constant expression as its initializer, like a literal or a <code>consteval</code> function. It cannot be used in function scope, as it is specifically intended for variables with static storage duration.</li> </ul> <p>Keep in mind that <code>constinit</code> cannot be used with automatic (local) variables, and trying to initialize it with a runtime value will result in a compile error.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nconsteval int GetValue() {\n    return 42;\n}\n\nconstinit int global_value = GetValue();\n\nint main() {\n    std::cout &lt;&lt; global_value &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>42\n</code></pre>"},{"location":"05%20Data%20Types/#padding-and-alignment","title":"Padding and Alignment","text":"<p>Info</p> <p>This section covers advanced memory management concepts, including how data is organized in memory and how to optimize it. This knowledge is generally not required unless you are working in performance-critical or low-level systems.</p> <p>Padding and alignment refer to how data is organized in memory. Every data type has specific alignment requirements, meaning it must be stored at memory addresses divisible by its size to ensure efficient access. If these requirements are not met, the compiler adds padding to fill the gaps, potentially wasting memory.</p> <p>For example, an <code>int</code> typically requires 4-byte alignment, meaning it must start at a memory address divisible by 4.</p> <pre><code>byte: 00 -&gt; If an `int` is placed here, it will occupy 4 bytes\nbyte: 01\nbyte: 02\nbyte: 03\nbyte: 04 -&gt; The next `int` can start here\nbyte: 05\nbyte: 06\nbyte: 07\nbyte: 08 -&gt; Or here\n</code></pre> <p>We can retrieve the alignment requirement of any data type by including the <code>&lt;type_traits&gt;</code> header, which provides the <code>std::alignment_of_v&lt;T&gt;</code> operator. The <code>_v</code> suffix stands for \"value\" and is a shorthand that gives you the result directly, rather than as a type like <code>int</code>.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Alignment of integer: \"&lt;&lt; std::alignment_of_v&lt;int&gt; &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Alignment of integer: 4\n</code></pre> <p>This concept is especially important when creating structs. If the alignment is not correct, the compiler will automatically add padding to ensure proper alignment, potentially wasting otherwise usable memory.</p> <p>Tip</p> <p>To detect padding and alignment issues, you can use Clang's <code>-Wpadded</code> compile flag, which will emit warnings for potentially inefficient struct layouts. Additionally, clang-tidy offers checks like <code>clang-analyzer-optin.performance.Padding</code> for deeper analysis. Unfortunately, MSVC and GCC do not have direct equivalents, so manual inspection or static analysis tools may be necessary for those compilers.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Entity {              // Total: 19 bytes \n    char rank;               // 1 byte\n    int level;               // 4 bytes\n    char type;               // 1 byte\n    int health;              // 4 bytes\n    long long experience;    // 8 bytes\n    char status;             // 1 byte\n};\n\nint main() {\n    std::cout &lt;&lt; \"Size of entity: \" &lt;&lt; sizeof(Entity) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Size of entity: 32\n</code></pre> <p>As we can see from this example, the original struct wastes 13 bytes of memory due to padding, resulting in approximately 75% overhead. This happens because each member must be aligned according to its alignment requirements, leaving gaps in memory.</p> <pre><code>byte: 00 -&gt; 'rank'       (1 byte)  \nbyte: 01 -&gt; padding  \nbyte: 02 -&gt; padding  \nbyte: 03 -&gt; padding  \nbyte: 04 -&gt; 'level'      (4 bytes) - 3 bytes lost  \n...  \nbyte: 08 -&gt; 'type'       (1 byte)  \nbyte: 09 -&gt; padding  \nbyte: 10 -&gt; padding  \nbyte: 11 -&gt; padding  \nbyte: 12 -&gt; 'health'     (4 bytes) - 3 bytes lost  \n...  \nbyte: 16 -&gt; 'experience' (8 bytes) - 4 bytes lost  \n...  \nbyte: 24 -&gt; 'status'     (1 byte)  - 3 bytes lost  \nbyte: 25 -&gt; padding  \nbyte: 26 -&gt; padding  \nbyte: 27 -&gt; padding\n</code></pre> <p>We can significantly reduce padding by reordering the struct members from largest to smallest data types. This approach minimizes internal fragmentation, though some padding may still remain at the end, as it is platform-dependent and cannot be completely eliminated.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct Entity {              // Total: 19 bytes \n    long long experience;    // 8 bytes\n    int level;               // 4 bytes\n    int health;              // 4 bytes\n    char rank;               // 1 byte\n    char status;             // 1 byte\n    char type;               // 1 byte\n};\n\nint main() {\n    std::cout &lt;&lt; \"Size of entity: \" &lt;&lt; sizeof(Entity) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Size of entity: 20 or 24\n</code></pre>"},{"location":"05%20Data%20Types/#difference-between-alignment-and-size","title":"Difference Between Alignment and Size","text":"<p>While <code>sizeof</code> gives you the total memory size (in bytes) that a type occupies\u2014including any internal padding\u2014<code>std::alignment_of_v&lt;T&gt;</code> tells you the alignment requirement of the type T.</p> Expression Description <code>sizeof(T)</code> How much space an object of type <code>T</code> takes up <code>std::alignment_of_v&lt;T&gt;</code> How that object must be aligned in memory <p>Alignment ensures that variables are placed in memory in a way that\u2019s efficient for the CPU. On many systems, certain types must be aligned to memory addresses divisible by 4, 8, 16, etc. Misalignment can lead to performance penalties or even runtime errors on strict architectures.</p>"},{"location":"05%20Data%20Types/#type-punning","title":"Type Punning","text":"<p>Info</p> <p>This section covers advanced memory management concepts, including how data is organized in memory and how to optimize it. This knowledge is generally not required unless you are working in performance-critical or low-level systems.</p> <p>C++ is considered a strongly typed language, but it still allows for certain implicit conversions\u2014such as converting integers to floating-point numbers or pointers between compatible types. While variables in C++ have explicitly defined data types, the language also provides low-level memory access, giving us the ability to reinterpret data in ways that would typically be restricted in stricter languages. This flexibility comes from the ability to directly access and manipulate memory, allowing a block of memory to be treated as a different type when necessary.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 50;\n    double value = *(double*)&amp;a;\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; std::endl; \n}\n</code></pre> output<pre><code>Value: 2.47033e-322\n</code></pre> <p>The reason why the output is so strange is that we pass the address of <code>a</code>, which is an integer (4 bytes), to an double pointer. The pointer tells the compiler that the value under this address is a <code>double</code> (8 bytes). Therefore, when we try to output it, the program reads 4 bytes past our value and accesses some unknown memory.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Entity {\n    int x;\n    int y;\n};\n\nint main() {\n    Entity e{5, 8};\n\n    int result = *(int*)((char*)&amp;e + 4);\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Value: 8\n</code></pre> <p>What is done in this example is called raw memory manipulation. This is also one of the reasons why C++ is such a powerful language: it can manipulate memory very easily and freely. While the code in this example should probably never exist in a real-world application, it demonstrates how data types are represented in memory and how they can be manipulated.</p> <p>However, what can be useful is the representation and access to memory. In the last example, we moved through the struct's values using raw memory manipulation, but it could also be easily interpreted as a C-style array, for example.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Entity {\n    int x, y;\n\n    int* CreateArrayFromEntity() {\n        return &amp;x;\n    }\n};\n\nint main() {\n    Entity e{5, 8};\n\n    int* array = e.CreateArrayFromEntity();\n\n    std::cout &lt;&lt; \"Second array value: \" &lt;&lt; array[1] &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Second array value: 8\n</code></pre> <p>Here, we just manipulate it using indices. This is possible because the <code>int</code> pointer is pointing to the address of <code>x</code>, and if it moves by four bytes (which is specified by the <code>[1]</code>), it will then point to the variable <code>y</code>. This works because structs are also organized in contiguous memory.</p>"},{"location":"05%20Data%20Types/#dynamic-typing","title":"Dynamic Typing","text":"<p>C++ is known as a statically-typed language; however, it also provides mechanisms that allow for a certain level of dynamic typing, meaning the data types of variables can be determined at runtime.</p>"},{"location":"05%20Data%20Types/#optional-data","title":"Optional Data","text":"<p>Warning</p> <p>This is a feature of C++17, so make sure you are using a compatible compiler version to avoid build errors.</p> <p>What often happens when reading from a file or another dynamic source is that the function responsible needs to return a value if it finds some text or not. The common approach is to return a signal that nothing was found \u2014 for example, returning an empty string if a file is empty or missing content. However, this isn't ideal, as it makes it hard to distinguish between missing data and intentionally empty data.</p> <p>This is where <code>std::optional</code> becomes useful; to use it, you must include the <code>&lt;optional&gt;</code> header. It is a type that holds a value that may or may not be present, stored on the stack. It provides a clear and type-safe way to represent optional data, making your code more expressive and reliable when handling uncertain results.</p> example<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nstd::string ReadFileToString(const std::string&amp; path) {\n    std::fstream stream(path);\n    if (stream) {\n        std::string result;\n\n        // Code for reading a file\n\n        stream.close();\n\n        return result;\n    }\n\n    return \"\";\n}\n\nint main() {\n    std::string data = ReadFileToString(\"data.txt\");\n    if (data != \"\") {\n        // code ...\n    }\n}\n</code></pre> <p>This approach isn\u2019t necessarily wrong, but it\u2019s not ideal either\u2014it\u2019s somewhat clunky and lacks clarity. It's similar to adding a separate flag variable to indicate whether the output was successful.</p> <p>These kinds of workarounds are unnecessary in modern C++. The cleaner solution is to use <code>std::optional</code>, which directly expresses the idea of a value that might not be present.</p> example<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;optional&gt;\n\nstd::optional&lt;std::string&gt; ReadFileToString(const std::string&amp; path) {\n    std::fstream stream(path);\n    if (stream) {\n        std::string result;\n\n        // Code for reading a file\n\n        stream.close();\n\n        return result;\n    }\n\n    return {};\n}\n\nint main() {\n    std::optional&lt;std::string&gt; data = ReadFileToString(\"data.txt\");\n    if (data) {\n        std::cout &lt;&lt; \"File was read successfully: \" &lt;&lt; *data &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"File was not read successfully!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>In this example, the use of <code>std::optional</code> explicitly indicates that the returned data may or may not be present.</p> <p>The check for the presence of data is clean and straightforward: we simply check if the <code>std::optional</code> contains a value. If it does, we dereference the optional variable to access the data. If the file reading process fails, the function returns an empty <code>std::optional</code> (i.e., the default constructor), indicating the absence of data.</p> <p>Using <code>std::optional</code> is often preferable to returning an empty string, as it avoids unnecessary string construction and copying, effectively representing a \"no value\" state without the overhead of a full string object.</p> <p>If the file could not be read and you want to set the data to a default value, you can use the <code>.value_or</code> method. This ensures that if <code>data</code> contains a value, it will be used; otherwise, the provided default value will be assigned.</p> example<pre><code>std::string value = data.value_or(\"default value\");\n</code></pre> <p>Beyond its primary use case of representing \"no value\" or a missing result, <code>std::optional</code> is also extremely useful when you need to delay initialization of a variable, especially in situations where immediate construction isn\u2019t possible or desirable.</p> <p>For example, in game development or GUI applications, you often have to wait until certain systems are initialized (like a rendering context or asset loader) before you can safely create certain objects. Instead of using raw pointers, manual flags, or heap allocation, you can wrap your object in a <code>std::optional</code> and initialize it later with the <code>.emplace()</code> method when the conditions are right.</p> example<pre><code>#include &lt;optional&gt;\n\nstruct Texture {\n    // code ... \n};\n\nstd::optional&lt;Texture&gt; player_texture;\n\nvoid LoadResources() {\n    player_texture.emplace(/* load texture here */);\n}\n</code></pre>"},{"location":"05%20Data%20Types/#multi-type-data-holder","title":"Multi-Type Data Holder","text":"<p>Warning</p> <p>This is a feature of C++17, so make sure you are using a compatible compiler version to avoid build errors.</p> <p>What often happens when handling inputs from external sources\u2014like files, command-line arguments, or network responses\u2014is that the data may come in different types. For example, a value might be a string in one case, a number in another, or something else entirely.</p> <p>This is where <code>std::variant</code> becomes useful. It allows you to store a value that could be one of several types, all in a single, type-safe variable. Think of it as a modern, type-safe union\u2014making your code more flexible without sacrificing safety or clarity.</p> <p>To use <code>std::variant</code>, you must include the <code>&lt;variant&gt;</code> header.</p> <p>Also the union is still useful for low-level optimization but does not offer type safety. When absolute optimization is not required, <code>std::variant</code> should be preferred.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;variant&gt;\n\nint main() {\n    std::variant&lt;std::string, int&gt; data;\n\n    data = \"Random\";\n    std::cout &lt;&lt; \"String variant: \" &lt;&lt; std::get&lt;std::string&gt;(data) &lt;&lt; std::endl;\n\n    data = 3;\n    std::cout &lt;&lt; \"Integer variant: \" &lt;&lt; std::get&lt;int&gt;(data) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>String variant: Random\nInteger variant: 3\n</code></pre> <p>This is a simple example of using <code>std::variant</code> and how to retrieve its data using <code>std::get&lt;T&gt;()</code>. However, if the stored type doesn't match the requested type, it throws a bad variant access exception. To avoid this, you can use <code>std::get_if&lt;T&gt;()</code> to safely access the value only if it holds the correct type.</p> example<pre><code>// Initializer inside the statement is a C++17 feature\nif (auto value = std::get_if&lt;std::string&gt;(&amp;data)) {\n    std::cout &lt;&lt; \"String value: \" &lt;&lt; *value &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"Data does not hold a string.\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"05%20Data%20Types/#any-data-type","title":"Any Data Type","text":"<p>Warning</p> <p>This is a feature of C++17, so make sure you are using a compatible compiler version to avoid build errors.</p> <p>What often happens in flexible systems\u2014like plugin architectures, event dispatchers, or scripting layers\u2014is the need to store and pass around values of any type, without knowing in advance what that type will be.</p> <p>This is where <code>std::any</code> becomes useful. It is a type-safe alternative to <code>void*</code>, allowing you to store any value while preserving its type information.</p> <p>To use <code>std::any</code>, include the <code>&lt;any&gt;</code> header.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;any&gt;\n\nint main() {\n    std::any data;\n\n    data = 3;\n    std::cout &lt;&lt; \"Now holding integer: \" &lt;&lt; std::any_cast&lt;int&gt;(data) &lt;&lt; std::endl;\n\n    data = std::string(\"String\");\n    std::cout &lt;&lt; \"Now holding string: \" &lt;&lt; std::any_cast&lt;std::string&gt;(data) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Now holding integer: 3\nNow holding string: String\n</code></pre> <p>At first glance, <code>std::any</code> may seem similar to <code>std::variant</code>, with the key difference being that <code>std::any</code> doesn't require you to specify possible types in advance. However, this flexibility is also its biggest drawback\u2014<code>std::variant</code> is often the better choice because its explicitly defined type list ensures type safety at compile time.</p> <p>For example, in the code above, we had to assign the string using <code>std::string(\"String\")</code>. If we had written just <code>\"String\"</code>, it would have been stored as a <code>const char*</code>, which could lead to a type mismatch when retrieving it with <code>std::any_cast&lt;std::string&gt;(data)</code>. With <code>std::variant</code>, this problem doesn't arise\u2014because the type must be one of the predefined options, <code>\"String\"</code> would be implicitly converted to <code>std::string</code> when matched against the allowed types.</p> <p>Additionally, <code>std::variant</code> can be more memory-efficient when working with large data types, especially if you're passing them by reference. <code>std::any</code>, on the other hand, always stores a copy of the value, which can introduce unnecessary overhead.</p> <p>In short, <code>std::any</code> should only be used when you truly need type-erased behavior and cannot determine the set of possible types in advance. Even then, the design should be reconsidered\u2014<code>std::variant</code> is in most cases the safer alternative.</p>"},{"location":"05%20Data%20Types/#rtti-run-time-type-identification","title":"RTTI (Run-Time Type Identification)","text":"<p>Run-Time Type Identification (RTTI) is a feature in C++ that allows you to determine the actual type of an object at runtime. This is useful in scenarios involving inheritance and polymorphism, particularly when working with base class pointers or references that may point to derived class objects.</p> <p>RTTI supports two key tools:</p> <ul> <li><code>typeid</code> operator</li> <li><code>dynamic_cast</code> operator</li> </ul>"},{"location":"05%20Data%20Types/#type-id","title":"Type Id","text":"<p>The <code>typeid</code> operator returns a reference to a <code>std::type_info</code> object, which contains information about the type of the expression passed to it. To use <code>typeid</code>, include the <code>&lt;typeinfo&gt;</code> header.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nclass Base { \n    virtual void dummy() {\n    }\n};\n\nclass Derived : public Base {\n};\n\nint main() {\n    Base* base_ptr = new Derived;\n\n    std::cout &lt;&lt; \"Type: \" &lt;&lt; typeid(*base_ptr).name(); // Output: Derived\n\n    delete base_ptr;\n}\n</code></pre> output<pre><code>Type: 7Derived\n</code></pre> <p>Although the output may look odd at first glance, <code>7Derived</code> is the mangled name of the <code>Derived</code> type. In many C++ compilers (like GCC or Clang), <code>typeid(...).name()</code> returns an encoded string where:</p> <ul> <li><code>7</code> indicates the number of characters in the class name (Derived has 7 letters).</li> <li>Derived is the actual class name.</li> </ul> <p>This process is called name mangling, and it's used by compilers to encode type information for linking and overloading support.</p>"},{"location":"05%20Data%20Types/#considerations-when-using-rtti","title":"Considerations When Using RTTI","text":"<ul> <li>RTTI increases memory overhead because types need to store additional information about themselves.</li> <li>Each time a <code>dynamic_cast</code> is performed, a runtime check is required to validate whether the cast is correct.</li> </ul> <p>It is possible to disable RTTI, but the process varies depending on the compiler. When RTTI is turned off, the compiler will typically generate a warning after building the project, indicating that RTTI is disabled. Additionally, <code>dynamic_cast</code> will exhibit unpredictable behavior, potentially leading to crashes or undefined results.</p>"},{"location":"05%20Data%20Types/#chapter-summary","title":"Chapter Summary","text":"<p>By completing this chapter, you should now have a solid understanding of data types in C++\u2014from the basic building blocks like integers, floating-point numbers, and characters, to more advanced tools like RTTI and type punning.</p> <p>You\u2019ve also explored how data types affect memory layout, performance, and the overall type safety of your programs.</p> <p>In particular, you've learned:</p> <ul> <li>How to safely convert between types using modern C++ casting operators like <code>static_cast</code> and <code>dynamic_cast</code>, which offer greater clarity and safety than traditional C-style casts.</li> <li>The flexibility of dynamic typing through <code>std::optional</code>, <code>std::variant</code>, and <code>std::any</code>, each suited for different scenarios where type uncertainty or variability is involved.</li> <li>How type punning allows you to reinterpret data at a low level, and how RTTI (Run-Time Type Information) can help identify types at runtime\u2014while being mindful of their performance implications.</li> </ul>"},{"location":"06%20Pointers%20and%20References/","title":"06 Pointers and References","text":"<p>Now, we arrive at one of the most feared topics in C++, pointers. Many people associate pointers with confusion, often because they tend to overthink them. In reality, pointers are quite simple once you understand the core concept.</p> <p>In computing, memory management is crucial. Every application you open is loaded into memory (RAM), and all the data the computer processes is stored there. Without memory, nothing would function, variables, programs, and even the operating system itself rely on it.</p> <p>A pointer is essentially an integer that holds a memory address. Think of computer memory as a long, one-dimensional array of bytes, each with a unique address, like houses lined up along a street. Just as you wouldn't physically move a house to show someone its location, but rather give them its address, a pointer stores the address of a specific memory block. This approach allows programs to work directly with data without unnecessary duplication.</p> Address 1 2 3 4 ... Byte Byte 1 Byte 2 Byte 3 Byte 4 ... Value 0000 0101 0000 1001 0000 0010 0000 0000 ... <p>Pointers are extremely important because everything in computing involves reading and writing to memory. While you can write C++ code without directly using pointers, they offer a powerful way to manage memory.</p> <p>Also pointers themselves aren\u2019t tied to specific data types. Whether you're dealing with characters, booleans, integers, or any other data type, a pointer is still just a number representing a memory address. The reason we specify a type for pointers in C++ is to indicate how much data should be read or written at that memory location.</p>"},{"location":"06%20Pointers%20and%20References/#memory-allocation","title":"Memory Allocation","text":"<p>Memory (RAM) is where our program is loaded and where it stores data. It is divided into two distinct regions: the stack and the heap. The stack is typically a fixed-size memory area, often around 2 MB, while the heap also has a predefined size but can grow dynamically as the application runs.</p> <p>A common misconception is that the stack and heap are stored in the CPU cache, but they actually reside in RAM. These regions serve as the primary storage areas for variables and other essential data during program execution.</p> <p>While both stack and heap memory allow us to read and write data, they differ significantly in how memory is allocated and managed. For example, when storing an integer (typically 4 bytes), stack memory is automatically allocated and freed based on scope\u2014once the scope is exited, the memory is released. In contrast, heap memory must be explicitly allocated and deallocated by the programmer, and it persists until it is manually freed. This act of requesting memory is known as memory allocation.</p>"},{"location":"06%20Pointers%20and%20References/#object-lifetimes","title":"Object Lifetimes","text":"<p>The stack region in memory can be imagined as a stack of books, to access a book in the middle, you must first remove the ones on top. In a computers, instead of books, we push stack frames onto the stack.</p> <p>When a function is called, a stack frame is created to store local variables, function parameters, return address, and other necessary information like saved registers and the previous stack frame pointer. This structure allows the function to execute and return properly, maintaining the state of the program during its execution. Once the function ends, the stack frame is automatically removed, and all variables within it are cleared from memory.</p> <p>Scopes in C++ are not limited to functions; classes, statements, and loops also have their own scopes. Additionally, we can create an isolated scope by enclosing code within curly brackets inside the <code>main</code> function or any other part of the program. Variables declared inside such a block exist only within that scope and are destroyed once the block ends.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    {\n        int number = 16;\n        std::cout &lt;&lt; number &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; number &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Error: 'number' was already cleared from memory because the scope in which it was declared has ended.\n</code></pre> <p>On the other hand, objects allocated on the heap persist until they are manually deallocated or handled by automatic mechanisms like smart pointers. Failing to free heap memory can lead to memory leaks, where allocated memory is never reclaimed, or heap exhaustion, where excessive allocations exceed the available heap space, potentially causing a crash.</p> example<pre><code>int* CreateArray() {\n    int array[50];  // Local array on the stack\n    return array;   // Returning a pointer to stack memory (dangerous!)\n}\n\nint main() {\n    int* array = CreateArray(); // Dangling pointer!\n}\n</code></pre> <p>This is a very common mistake, returning a pointer to a local stack-allocated array. Since the array is created inside the function, it only exists within that function's scope. Once the function returns, the stack frame is destroyed, and the array no longer exists, leaving us with a dangling pointer that points to invalid (or corrupted) memory.</p>"},{"location":"06%20Pointers%20and%20References/#raw-pointers","title":"Raw Pointers","text":"<p>We will start by introducing <code>void*</code> (void pointer), a generic pointer that is not associated with any specific data type. It can store the address of any variable, but since it lacks type information, we cannot directly read from or write to the memory it points to\u2014we don't know how many bytes belong to it without first converting it to a specific pointer type. This reinforces the idea that pointers are simply memory addresses, independent of data types.</p>"},{"location":"06%20Pointers%20and%20References/#declaring-pointers","title":"Declaring Pointers","text":"<p>Pointers are declared by appending an asterisk to a data type, followed by the variable name. The <code>*</code> symbol is known as the dereference operator, which allows us to access the value stored at the memory address the pointer holds.</p> example<pre><code>int main() {\n    void* ptr = 0;\n\n    void* ptr = NULL;\n\n    void* ptr = nullptr;\n}\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#null-pointers","title":"Null Pointers","text":"<p>In the example above, we assigned <code>0</code> to a pointer. Since memory addresses do not start at zero, <code>0</code> is an invalid memory address. However, having an invalid address is a perfectly acceptable state for a pointer, as it indicates that the pointer is not currently pointing to valid memory.</p> <p>We also used <code>NULL</code>, which is simply a macro-defined constant representing <code>0</code>. While it functions the same as writing <code>0</code> directly, it improves readability.</p> <p>Additionally, we introduced <code>nullptr</code>, a C++ keyword specifically designed to represent an invalid pointer. Unlike <code>NULL</code>, <code>nullptr</code> has stronger type safety, making it the preferred choice in modern C++.</p>"},{"location":"06%20Pointers%20and%20References/#accessing-the-address-of-a-variable","title":"Accessing the Address of a Variable","text":"<p>Earlier, we mentioned that everything created in a program has a memory address where its data is stored. This applies even to simple integer variables, each variable resides at a unique location in memory.</p> <p>We can access a variable's address by prefixing it with <code>&amp;</code>, which is called the address-of operator (sometimes referred to as the reference operator). This operator returns the memory address of the variable, allowing us to work with its location directly.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value = 8;\n    void* ptr = &amp;value; // Storing the memory address of 'value'\n\n    std::cout &lt;&lt; &amp;value &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>0x7ffceeb396ac\n</code></pre> <p>Note</p> <p>The actual address printed will vary every time you run the program. This is due to Address Space Layout Randomization (ASLR) \u2014 a security feature used by modern operating systems to randomize memory addresses, making certain types of attacks harder to perform.</p> <p>In this example, we assign a valid memory address to the pointer by using the address-of operator on a variable. This ensures that the pointer correctly stores the location of <code>value</code> in memory.</p>"},{"location":"06%20Pointers%20and%20References/#dereferencing-a-pointer","title":"Dereferencing a Pointer","text":"<p>We have now reached the point where we may want to retrieve the data stored at the memory address held by a pointer. To do this, we use the dereference operator as a prefix to the pointer variable. This allows us to access and manipulate the value stored at that memory location, just as we would with a regular variables.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value = 8;\n    void* ptr = &amp;value;\n\n    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Error: cannot dereference a void pointer\n</code></pre> <p>This will produce an error because <code>void*</code> represents a generic memory address without a specific type. While it can store the address of any data type, it cannot be dereferenced because the compiler does not know how many bytes belong to the variable at that address.</p> <p>To fix this, we need to create an <code>int*</code> pointer for an <code>int</code> value. This way, the compiler knows that 4 bytes (on most modern systems) after the address belong to the integer, allowing proper reading and writing of the data.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value = 8;\n    int* ptr = &amp;value;\n\n    // Correct: Dereferencing an int pointer\n    std::cout &lt;&lt; \"Value of pointer: \" &lt;&lt; *ptr &lt;&lt;std::endl;\n}\n</code></pre> output<pre><code>Value of pointer: 8\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#dynamic-memory-allocation","title":"Dynamic Memory Allocation","text":"<p>Up to this point, all variables have been allocated on the stack, meaning their lifetime is tied to their current scope. This is generally safe, but it also means they are automatically deleted once the scope ends, limiting their lifespan.</p> <p>To preserve the existence of important values beyond their original scope, we can use pointers in combination with the <code>new</code> keyword. This reserves memory on the heap and returns a pointer to the allocated memory.</p> <p>Using <code>new</code>, we can create variables on the heap, ensuring they remain accessible even after their original scope ends\u2014provided we manage them correctly.</p> example<pre><code>int main() {\n    char* buffer = new char[8]; // Allocate 8 bytes on the heap\n}\n</code></pre> <p>In the example above:</p> <ul> <li>We create a pointer of type <code>char*</code>.</li> <li>We use the <code>new</code> keyword to allocate 8 bytes of memory on the heap.</li> <li>Since a <code>char</code> is 1 byte in size, allocating an array of 8 chars reserves 8 contiguous bytes in memory.</li> <li>The pointer <code>buffer</code> stores the address of the first element in this allocated memory block.</li> </ul>"},{"location":"06%20Pointers%20and%20References/#initializing-heap-memory","title":"Initializing Heap Memory","text":"<p>Heap memory is not automatically initialized, meaning it can contain garbage values. To initialize memory, we can use the <code>memset</code> function from the <code>&lt;cstring&gt;</code> header file.</p> example<pre><code>#include &lt;cstring&gt;\n\nint main() {\n    char* buffer = new char[8]; // Allocate 8 bytes on the heap\n    memset(buffer, '\\0', 8);    // Set all bytes to the ASCII null character\n}\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#heap-memory-management","title":"Heap Memory Management","text":"<p>Memory allocated on the heap is not automatically freed when a variable goes out of scope. Unlike stack memory, which is managed by the compiler, heap memory must be manually deallocated to prevent memory leaks. A situation where memory is allocated but never freed, causing a program to consume increasing amounts of memory over time and potential heap overflow, which occurs when the program exhausts all available heap memory and can no longer allocate new data.</p> <p>To properly free heap memory, we use the <code>delete</code> keyword followed by the pointer holding the allocated address.</p> example<pre><code>#include &lt;cstring&gt;\n\nint main() {\n    // Allocate a single integer on the heap\n    int* ptr = new int(10);\n\n    // Allocate an array of 8 characters on the heap\n    char* buffer = new char[8];\n    memset(buffer, 0, 8);\n\n    delete ptr;       // Deallocate memory for the single integer\n    delete[] buffer;  // Deallocate memory for the character array\n}\n</code></pre> <p>When deallocating a dynamically allocated single object, we use <code>delete</code>. However, when deallocating a dynamically allocated array, we must use <code>delete[]</code> to ensure the entire block of memory is freed correctly.</p>"},{"location":"06%20Pointers%20and%20References/#constant-pointers","title":"Constant Pointers","text":"<p>By now, we understand how pointers work, how to create, manipulate, and delete them. However, there are cases where we need to enforce restrictions on either the pointer itself or the data it points to.</p> <p>A constant pointer applies specific constraints, ensuring that either the pointer\u2019s address remains unchanged, the pointed-to value cannot be modified, or both.</p>"},{"location":"06%20Pointers%20and%20References/#pointer-to-constant","title":"Pointer to Constant","text":"<p>This type of pointer cannot modify the value it points to, but it can be reassigned to another address.</p> <p>Use case: When you want to protect the data from being modified but allow the pointer to point elsewhere.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10;\n    int b = 20;\n\n    const int* ptr = &amp;a; // Pointer to a constant value\n\n    // *ptr = 15; // Error: Cannot modify the value through the pointer\n    ptr = &amp;b;     // Allowed: Pointer can be reassigned\n\n    std::cout &lt;&lt; \"Reassigned pointer to B: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Reassigned pointer to B: 20\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#constant-pointer","title":"Constant Pointer","text":"<p>This type of pointer cannot be reassigned, but it can modify the value it points to.</p> <p>Use case: When you want a pointer to always point to the same object but still allow modifications to the object.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10;\n    int b = 20;\n\n    int* const ptr = &amp;a; // Constant pointer to an integer\n\n    *ptr = 15;   // Allowed: Can modify the value through the pointer\n    // ptr = &amp;b; // Error: Cannot reassign a constant pointer\n\n    std::cout &lt;&lt; \"Modified variable A: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Modified variable A: 15\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#constant-pointer-to-constant","title":"Constant Pointer to Constant","text":"<p>This type of pointer cannot be reassigned and cannot modify the value it points to.</p> <p>Use case: When you want a pointer to always point to the same object and ensure that the object cannot be modified through the pointer.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10;\n    int b = 20;\n\n    const int* const ptr = &amp;a; // Constant pointer to a constant value\n\n    // *ptr = 15; // Error: Cannot modify value\n    // ptr = &amp;b; // Error: Cannot reassign pointer\n\n    std::cout &lt;&lt; \"Unchanged pointer value: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Unchanged pointer value: 10\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#pointer-to-pointer","title":"Pointer to Pointer","text":"<p>Since pointers are just variables that store memory addresses, it is possible to create a pointer that points to the location of another pointer. This is known as a pointer to a pointer. While it is theoretically possible to create multiple levels of pointers, doing so is impractical and rarely useful in real-world applications.</p> <p>A pointer to a pointer is created by adding an additional asterisk to a regular pointer variable. This means the first pointer stores the address of the second pointer, and the second pointer stores the address of the actual data.</p> main.cpp<pre><code>#include &lt;cstring&gt;\n\nint main() {\n    char* buffer = new char[8];\n    memset(buffer, 0, 8);\n\n    char** pointer_to_buffer = &amp;buffer; // A pointer to the pointer 'buffer'\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>In this example:</p> <ul> <li><code>buffer</code> is a pointer to a block of memory on the heap.</li> <li><code>pointer_to_buffer</code> is a pointer to a pointer that holds the address of <code>buffer</code>.</li> </ul> <p>While pointers to pointers can exist, they are rarely needed and should be used only when there is a valid use case. For most applications, a single pointer is sufficient.</p>"},{"location":"06%20Pointers%20and%20References/#pointer-safety","title":"Pointer Safety","text":"<p>Working directly with addresses and heap memory comes with risks. If not handled correctly, it can lead to serious memory management errors, such as dangling pointers, memory leaks, buffer overflows, and undefined behavior.</p> <p>In this section, we will cover common pitfalls when working with pointers and best practices to write safer and more reliable C++ code.</p>"},{"location":"06%20Pointers%20and%20References/#dangling-pointers","title":"Dangling Pointers","text":"<p>A dangling pointer is a pointer that references memory that has already been freed or is no longer valid. Accessing such memory leads to undefined behavior, which can result in crashes, corrupted data, or security vulnerabilities.</p> <p>How Dangling Pointers Occur:</p> <ol> <li>Deleted Memory Access - A pointer still holds an address to memory that has already been deallocated.</li> <li>Returning Pointers to Local Variables - A pointer to a local variable is returned from a function, but the variable is destroyed when the function exits.</li> <li>Uninitialized Pointers - A pointer is used without being properly initialized, leading it to point to an arbitrary or invalid location.</li> </ol>"},{"location":"06%20Pointers%20and%20References/#memory-leaks","title":"Memory Leaks","text":"<p>A memory leak occurs when dynamically allocated memory is not properly deallocated, causing the program to consume more memory over time without releasing it. If a program continuously leaks memory, it may slow down, crash, or exhaust system resources.</p> <p>Memory leaks are particularly dangerous in long-running applications, such as servers or embedded systems, where unmanaged memory growth can lead to performance degradation or failure.</p>"},{"location":"06%20Pointers%20and%20References/#buffer-overflows","title":"Buffer Overflows","text":"<p>A buffer overflow occurs when a program writes more data into a buffer (such as an array) than it was allocated to hold. This results in overwriting adjacent memory, potentially causing program crashes, security vulnerabilities, or unpredictable behavior.</p> <p>Buffer overflows are particularly dangerous because they can corrupt data, cause segmentation faults, or be exploited by attackers to execute malicious code.</p>"},{"location":"06%20Pointers%20and%20References/#pointer-aliasing-and-ownership","title":"Pointer Aliasing and Ownership","text":"<p>Pointer aliasing occurs when multiple pointers reference the same memory location. While this can be useful, it can also lead to unintended side effects, such as modifying a value unexpectedly or causing performance issues due to compiler optimizations being invalidated.</p>"},{"location":"06%20Pointers%20and%20References/#preventions","title":"Preventions","text":"<p>Most pointer-related safety issues stem from raw pointer management and manual memory handling, which are prone to errors like memory leaks, dangling pointers, and undefined behavior.</p> <p>To avoid these risks, modern C++ provides:</p> <ul> <li>Smart Pointers (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>) - Automatically manage memory and prevent leaks.</li> <li>STL Containers (<code>std::vector</code>, <code>std::array</code>, etc.) - Provide automatic memory management and prevent buffer overflows.</li> </ul>"},{"location":"06%20Pointers%20and%20References/#pointer-arithmetic","title":"Pointer Arithmetic","text":"<p>After becoming familiar with raw pointers, one of the next important aspects to understand is how to use them in practical scenarios. This is where pointer arithmetic becomes extremely useful. Pointer arithmetic allows us to perform mathematical operations on pointers to navigate through memory locations, particularly when working with arrays or structs.</p> <p>Pointer arithmetic works by adding or subtracting integer values to pointers, which effectively adjusts the memory address they point to. The pointer itself does not store the data but holds the address of the data in memory. By performing arithmetic on pointers, we can access different elements in arrays or traverse contiguous blocks of memory.</p> <p>In the example below, pointer arithmetic is used to iterate through an array of structures.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Person {\n    char name[64];\n    int age;\n};\n\nint main() {\n    Person people[5];\n\n    Person* p_person = people; // Pointer to the first element of the array\n\n    for (int i = 0; i &lt; 5; ++i) {\n        p_person-&gt;age = 53;      // Access and modify the age of the person\n        p_person-&gt;name[0] = 'R'; // Access and modify the name of the person\n\n        p_person++; // Move the pointer to the next Person object in memory\n    }\n\n    for (int i = 0; i &lt; 5; ++i)\n      std::cout &lt;&lt; people[i].name[0] &lt;&lt; '\\t' &lt;&lt; people[i].age &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>R   53\nR   53\nR   53\nR   53\nR   53\n</code></pre> <p>Pointer arithmetic takes into account the size of the object the pointer is pointing to. In this case, when we increment <code>p_person</code>, it doesn\u2019t just move by 1 byte. It moves by the size of a <code>Person</code> object, which is 68 bytes (64 bytes for <code>name</code> and 4 bytes for <code>age</code>). This is why the pointer moves to the next <code>Person</code> in the array, not just the next byte in memory.</p> <p>This topic is further built upon in the section [[07 Data Types#Type Punning|Type Punning]].</p>"},{"location":"06%20Pointers%20and%20References/#references","title":"References","text":"<p>Pointers and references in C++ are fundamentally similar in terms of what the computer actually does. However, semantically, they have subtle differences. A reference is essentially a syntax shortcut for a pointer, making the code more readable and easier to follow.</p> <p>As the name suggests, a reference is used to refer to an existing variable. Unlike pointers, a reference cannot be null and must always be bound to a valid variable. This means you cannot set a reference to <code>nullptr</code>, and it must always refer to an existing object.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10;\n    int&amp; b = a;  // b is a reference to a\n\n    std::cout &lt;&lt; \"Reference to A: \" &lt;&lt; b &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Reference to A: 10\n</code></pre> <p>In this example, <code>b</code> is a reference to <code>a</code>, meaning it acts as an alias for <code>a</code>. Any modifications to <code>b</code> will directly affect <code>a</code>, and vice versa.</p>"},{"location":"06%20Pointers%20and%20References/#reference-vs-address-of-operator","title":"Reference vs. Address-of Operator","text":"<p>In C++, the reference operator (<code>&amp;</code>) and the address-of operator (<code>&amp;</code>) can sometimes be confusing, but they serve distinct purposes depending on their usage.</p> <ul> <li>When <code>&amp;</code> is appended to the data type, it signifies a reference. A reference is simply an alias for an existing variable, meaning it acts as another name for that variable.</li> <li>When <code>&amp;</code> is used as a prefix before a variable name, it means the address-of operator, which returns the memory address of the variable. </li> </ul>"},{"location":"06%20Pointers%20and%20References/#pass-by-value-vs-pass-by-reference","title":"Pass by Value vs. Pass by Reference","text":"<p>In C++, there are two common ways to pass data into a function: pass-by-value and pass-by-reference. Each method has its own behavior and implications.</p> <p>In pass-by-value, when we pass a variable to a function, a copy of the variable is created. The function then works with this copy, and any changes made to the parameter within the function do not affect the original variable.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid Increment(int number) {\n    number++;\n}\n\nint main() {\n    int number = 5;\n\n    Increment(number);\n\n    std::cout &lt;&lt; \"Number: \" &lt;&lt; number &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Number: 5\n</code></pre> <p>In this case, the <code>Increment()</code> function receives a copy of the <code>number</code> from <code>main()</code>. Inside the function, the copy of <code>number</code> is incremented, but the original <code>number</code> in <code>main()</code> remains unchanged. As a result, the value of <code>number</code> in <code>main()</code> stays at <code>5</code>.</p> <p>In pass-by-reference, instead of passing a copy of the variable, we pass the actual variable itself. This allows the function to modify the original variable directly, and any changes made to the parameter within the function will affect the original variable outside of the function as well.</p> <p>To pass a variable by reference, we use the reference operator in the function parameter list. </p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid Increment(int&amp; number) {\n    number++;\n}\n\nint main() {\n    int number = 5;\n\n    Increment(number);\n\n    std::cout &lt;&lt; \"Number: \" &lt;&lt; number &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Number: 6\n</code></pre> <p>In this case, the <code>Increment()</code> function receives a reference to <code>number</code>, meaning it works directly with the original <code>number</code> in <code>main()</code>. As a result, after the function call, the value of <code>number</code> in <code>main()</code> is updated to <code>6</code>.</p>"},{"location":"06%20Pointers%20and%20References/#when-to-pass-by-reference","title":"When to Pass by Reference","text":"<p>There are four main scenarios where pass-by-reference is preferred over pass-by-value:</p> <ol> <li>Modifying Arguments<ul> <li>If a function needs to modify its arguments, you should use pass-by-reference or pass-by-pointer.</li> </ul> </li> <li>Avoiding Unnecessary Copies (Efficiency)<ul> <li>When a function accepts a large object as a parameter, it's better to use pass-by-const-reference.</li> </ul> </li> <li>Copy &amp; Move Constructors<ul> <li>Copy and move constructors must always take a reference to avoid unnecessary object creation and to ensure proper copying or moving of objects.</li> </ul> </li> <li>Working with Polymorphism (Avoiding Object Slicing)<ul> <li>When working with polymorphic classes, it's essential to pass objects by reference or pointer rather than by value.</li> <li>Passing by value may lead to object slicing, where the derived class data is lost when copied into a base class object.</li> </ul> </li> </ol>"},{"location":"06%20Pointers%20and%20References/#function-pointer","title":"Function Pointer","text":"<p>So far, we have only called functions directly to execute logic. A function serves as a symbol that we invoke whenever we want to perform a specific action. We can also pass arguments to a function and retrieve values from it, which allows us to write more dynamic code.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid HelloWorld() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n\nint main() {\n    HelloWorld();\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>In this example, we have a regular function declaration with a simple definition. However, since functions are stored in memory, we can assign them to pointers.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid HelloWorld() {\n  std::cout &lt;&lt; \"Hello World!\";\n}\n\nint main() {\n\n    // Declare a function pointer 'function' and assign it the address of the 'HelloWorld' function \n    void(*function)() = HelloWorld;\n\n    function();\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>In the code above, we use function pointer. The syntax may seem a bit complex at first, so let's break it down:</p> <ol> <li>The return type of the function comes first (<code>void</code>).</li> <li>Inside the first set of parentheses, we declare the pointer (<code>*function</code>).</li> <li>The second set of parentheses defines the function parameters (which are empty in this case).</li> </ol> <p>This declaration can be simplified using the <code>auto</code> keyword, which automatically deduces the correct type.</p> <p>Another way to simplify this syntax is by creating a type alias using <code>using</code>, especially when the same type is used repeatedly.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid HelloWorld() {\n  std::cout &lt;&lt; \"Hello World!\";\n}\n\nint main() {\n    using HelloWorldFunction = void(*)();\n\n    HelloWorldFunction function = HelloWorld;\n\n    function();\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#where-to-use-function-pointers","title":"Where to Use Function Pointers","text":"<p>In this example, we define a function pointer and pass it to another function for use, showcasing how function pointers can add flexibility to code.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvoid PrintValue(const int value) {\n    std::cout &lt;&lt; value &lt;&lt; std::endl;\n}\n\nvoid ForEach(const std::vector&lt;int&gt;&amp; values, void(*func)(const int)) {\n    for (const int&amp; value : values)\n        func(value);\n}\n\nint main() {\n    std::vector&lt;int&gt; values = {1, 2, 3, 4, 5};\n\n    ForEach(values, PrintValue);\n}\n</code></pre> output<pre><code>1\n2\n3\n4\n5\n</code></pre> <p>In the example above, we pass the <code>PrintValue</code> function as a pointer to the <code>ForEach</code> function, which then uses the pointer to invoke <code>PrintValue</code> for each element in the vector.</p> <p>While function pointers can still be useful in specific cases, such as when interacting with C libraries, modern C++ prefers lambda expressions and <code>std::function</code> for more flexible, type-safe, and readable code.</p>"},{"location":"06%20Pointers%20and%20References/#lvalues-and-rvalues","title":"Lvalues and Rvalues","text":"<p>In C++, understanding lvalues and rvalues is crucial because they are fundamental concepts that appear frequently in compiler warnings, error messages, and in modern C++ features like move semantics and temporary values.</p> <p>An lvalue refers to a location value, something that has a persistent memory address. You can think of it as an object or a variable that you can modify or access.</p> <p>In contrast, an rvalue represents a temporary value, usually something that does not have a lasting memory address. These can be literals or the results of function calls that return a temporary value.</p> main.cpp<pre><code>int main() {\n    int a = 10;\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>In the example above, <code>a</code> is an lvalue because it is a variable with a specific memory location where the rvalue <code>10</code> is stored.</p> <ul> <li>An lvalue typically appears on the left side of the <code>=</code> (assignment) operator.</li> <li>You can assign values to lvalues because they have a defined memory location.</li> </ul> <p>An rvalue, however, can be more than just a literal. For example, it can be the result of a function call that returns a value. Rvalues do not refer to objects with persistent memory addresses and are typically used to represent temporary values.</p> main.cpp<pre><code>int GetValue() {\n    return 10;\n}\n\nint main() {\n    int a = GetValue();\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>In this example, the function <code>GetValue()</code> returns an rvalue because the value <code>10</code> is a temporary result. The rvalue cannot be assigned directly to another rvalue but can be assigned to an lvalue like <code>a</code>.</p>"},{"location":"06%20Pointers%20and%20References/#lvalue-reference","title":"Lvalue Reference","text":"<p>We explained that an rvalue is not limited to just literals; it can also be the result of a function call that returns a value. Additionally, we can assign a value to the result of a function call.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint PrintValue() {\n    std::cout &lt;&lt; 10 &lt;&lt; std::endl;\n}\n\nint main() {\n    PrintValue() = 5;\n}\n</code></pre> output<pre><code>Error: expression must be a modifiable lvalue\n</code></pre> <p>The error happens because a function typically returns an rvalue, meaning a temporary value that cannot be assigned to. However, this is not always true, when a function contains a static variable, that variable persists across function calls and can be modified. By returning a reference to a static variable, we allow the function to return an lvalue, making it possible to modify the value directly.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint&amp; GetValue() {\n    static int value = 1;\n    return value;\n}\n\nint main() {\n    GetValue() = 5; // Reassing PrintValue() static variable to 5\n\n    std::cout &lt;&lt; \"Function value: \" &lt;&lt; GetValue() &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Function value: 5\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#rvalue-reference","title":"Rvalue Reference","text":"<p>We have learned that when passing variables as function arguments, they are copied into a new variable created inside the function. While passing them as lvalue references can improve performance, it also prevents passing literal values because an lvalue reference cannot bind to an rvalue (a temporary value). To work around this, we can declare the parameter as <code>const</code>, which allows temporary values (rvalues) to be assigned to a temporary variable behind the scenes. The compiler creates a temporary variable, assigns the literal value to it, and then binds it to the lvalue reference.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid PrintFunction(const int&amp; value) {\n    std::cout &lt;&lt; value &lt;&lt; std::endl;\n}\n\nint main() {\n    int a = 10;\n\n    PrintFunction(a); // Normal pass by reference\n    PrintFunction(5); // Pass rvalue by reference\n}\n</code></pre> <p>That is why most C++ functions declare parameters as <code>const</code> lvalue references (<code>const type&amp;</code>), allowing them to efficiently accept both lvalues and rvalues. However, it is also possible to create a function parameter that accepts only temporary values (rvalues) by appending the type with <code>&amp;&amp;</code>, which is known as an rvalue reference.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid AcceptLvalueAndRvalue(const int&amp; value) {} // Accepts both\nvoid AcceptOnlyRvalue(int&amp;&amp; value) {}           // Accepts only rvalues\n\nint main() {\n    int x = 5;\n\n    AcceptLvalueAndRvalue(x);  \n    AcceptLvalueAndRvalue(10);\n\n    AcceptOnlyRvalue(10);\n}\n</code></pre> <p>It is considered good practice to overload a function in modern medium-to-large projects if we want to support both lvalues and rvalues while maximizing performance. By having an overload for <code>const lvalue reference</code> (which can accept both lvalues and rvalues) and another for <code>rvalue reference</code>, the compiler will always prefer the more specific overload when an rvalue is passed. The key difference is that an rvalue reference (<code>&amp;&amp;</code>) allows moving resources from the source, as it indicates that the variable is temporary and will not persist for long. On the other hand, a <code>const lvalue reference</code> (<code>const int&amp;</code>) signals that the variable is important, cannot be modified, and is passed by reference to avoid unnecessary copying.</p>"},{"location":"06%20Pointers%20and%20References/#move-semantics","title":"Move Semantics","text":"<p>To fully understand this chapter, it is recommended to first reviewing and familiarizing yourself with [[08 Data Structures#Strings|Strings]] and [[09 User-Defined Types]].</p> <p>So far, we have been introduced to lvalues and rvalues, but this is where their true purpose becomes clear. Move semantics allows us to transfer ownership of resources from one object to another, rather than copying or referencing them. This is particularly useful when we want to avoid the overhead of creating a duplicate and instead reuse existing resources, transferring ownership to a new scope.</p> <p>Note</p> <p>The original object is typically left in a moved-from state, meaning it is still valid but its contents are unspecified.</p> <p>For example, when passing an object into a function that takes ownership, we would normally copy it. The same applies when returning an object from a function, we first create the object in the current stack frame and then copy it into the caller's scope. This is not ideal, as we must construct it in one place and copy it to another, leading to unnecessary overhead.</p> <p>For simple types like numbers or small structs, this overhead is minimal. However, for complex classes, such as <code>std::string</code>, copying becomes expensive due to heap allocations. Move semantics solves this problem by transferring ownership instead of copying the object, significantly reducing memory operations and improving performance.</p> main.cpp<pre><code>#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n\n#include &lt;iostream&gt;\n\nclass String {\npublic:\n    String() : data_(nullptr), size_(0) {\n        // remains empty\n    }\n\n    // Constructor that creates a new string from a C-string\n    String(const char* string) {\n        printf(\"Created!\\n\");\n        size_ = strlen(string);\n        data_ = new char[size_ + 1];\n        memcpy(data_, string, size_);\n        data_[size_] = '\\0';\n    }\n\n    // Copy constructor\n    String(const String&amp; other) {\n        printf(\"Copied!\\n\");\n        size_ = other.size_;\n        data_ = new char[size_ + 1];\n        memcpy(data_, other.data_, size_);\n        data_[size_] = '\\0';\n    }\n\n    // Move constructor\n    String(String&amp;&amp; other) noexcept\n        : data_(other.data_), size_(other.size_) {\n        printf(\"Moved!\\n\");\n        other.data_ = nullptr;  // Reset the other object\u2019s data pointer\n        other.size_ = 0;        // Reset the other object\u2019s size\n    }\n\n    ~String() {\n        printf(\"Destroyed!\\n\");\n        delete[] data_;\n    }\n\n    void Print() const {\n        printf(\"%s\\n\", data_);\n    }\n\n    const char* GetData() const {\n        return data_;\n    }\n\nprivate:\n    char* data_;\n    uint32_t size_;\n};\n\nclass Entity {\npublic:\n    // Copy constructor\n    Entity(const String&amp; name)\n        : name_(name) {\n    }\n\n    // Move constructor\n    Entity(String&amp;&amp; name)\n        : name_(std::move(name)) {\n    }\n\n    void PrintName() const {\n        printf(\"%s\\n\", name_.GetData());\n    }\n\nprivate:\n    String name_;\n};\n\nint main() {\n    // Creating an entity with an rvalue (temporary String object)\n    Entity entity(String(\"Random String\"));\n    entity.PrintName();\n}\n</code></pre> output<pre><code>Created!\nMoved!\nDestroyed!\nRandom String\nDestroyed!\n</code></pre> <p>This is a large example of implementing a custom string class. However, it should not be considered a proper way to build a string class for real-world applications. It uses a lot of C-style memory management, which is not ideal for production code. The purpose of this example is purely to demonstrate how copying and moving work in C++.</p> <p>By adding logs inside the copy constructor and move constructor, we can clearly observe the difference between copying and moving an object:</p> <ul> <li>The copy constructor (<code>String(const String&amp; other)</code>) duplicates the resource by allocating new memory and copying the data from the source object.</li> <li>The move constructor (<code>String(String&amp;&amp; other) noexcept</code>) steals the resource from the temporary object (<code>other</code>) by transferring the pointer to the new object, rather than copying the data. After the transfer, the original object is detached by setting its pointer to <code>nullptr</code> and its size to <code>0</code>.</li> </ul> <p>This behavior makes moving much more efficient than copying, especially for large objects that allocate memory on the heap, such as strings or vectors. By moving rather than copying, we avoid unnecessary memory allocations and reduce performance overhead.</p>"},{"location":"06%20Pointers%20and%20References/#standard-move-function","title":"Standard Move Function","text":"<p>After understanding rvalue references, move constructors, and their benefits, it\u2019s time to introduce <code>std::move</code>, a function that allows us to explicitly move objects instead of copying them.</p> <p>We\u2019ll refer back to the <code>String</code> example from the section [[#Move Semantics|Move Semantics]], where we used <code>std::move</code> to transfer ownership of a temporary string into <code>m_Name</code> inside the <code>Entity</code> class. To simplify the explanation, we\u2019ll now demonstrate <code>std::move</code> using just variables of our custom <code>String</code> class.</p> main.cpp<pre><code>int main() {\n    String string1 = \"Random\";\n    String string2 = string1; // string1 is copied into string2\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>In this example, <code>string1</code> is copied into <code>string2</code> because it is an lvalue (a named variable). However, if we want to move its resources to <code>string2</code> instead of copying them, we need to treat <code>string1</code> as a temporary value (rvalue), because the move constructor requires an rvalue reference.</p> <p>One way to do this is by casting <code>string1</code> to an rvalue reference using <code>(String&amp;&amp;)</code>. However, this approach is not ideal and does not work with variables deduced using <code>auto</code>.</p> <p>To solve this, we use <code>std::move</code>, which efficiently converts an lvalue into an rvalue, allowing us to move the resource without unnecessary copies. It also makes the intention clear in the code, signaling that we are intentionally transferring ownership rather than copying.</p> main.cpp<pre><code>int main() {\n    // Not recommended: Casting to rvalue reference\n    // String string1 = \"Random\";\n    // String string2((String&amp;&amp;)string1);\n\n    String string1 = \"Random\";\n    String string2(std::move(string1)); // Proper way to move\n}\n</code></pre> output<pre><code>None\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#move-assignment-operator","title":"Move Assignment Operator","text":"<p>Using <code>std::move</code> inside a constructor is not the same as using it after an assignment operator. Constructors are responsible for creating objects, while the assignment operator replaces an existing object's contents. Since operators behave like regular functions, we need to explicitly define a move assignment operator to enable move semantics during assignment.</p> main.cpp<pre><code>class String {\n    // Implementation of Regular, Copy, and Move Constructor from before\n\n    String&amp; operator=(String&amp;&amp; other) {\n        printf(\"Moved!\\n\");\n\n        if (this != &amp;other) {\n            delete[] data_;\n\n            data_ = other.data_;\n            size_ = other.size_;\n\n            other.data_ = nullptr;\n            other.size_ = 0;\n        }\n\n        return *this;\n    }\n};\n</code></pre> <p>The self-assignment check (<code>if (this != &amp;other)</code>) is crucial. If we mistakenly attempt to move an object into itself.</p> <pre><code>str = std::move(str); // Dangerous\n</code></pre> <p>Without this check, the move logic would detach the object\u2019s own data, leaving it in an invalid state. This could lead to double deletion when the destructor runs, causing undefined behavior. By verifying that <code>this</code> and <code>other</code> are different objects, we prevent accidental self-moves.</p> <p>A move constructor is used when creating a new object from an existing one, while a move assignment operator is used when an existing object is reassigned.</p> <p>A general rule in C++ is that if you implement a move constructor, you should also provide a move assignment operator, as both serve distinct but complementary purposes.</p>"},{"location":"06%20Pointers%20and%20References/#smart-pointers","title":"Smart Pointers","text":"<p>So far, we have relied on C-style raw pointers with <code>new</code> and <code>delete</code>, requiring manual memory management. However, this approach is error-prone, as forgetting to call <code>delete</code> can lead to memory leaks, while deleting memory incorrectly can cause undefined behavior.</p> <p>To address these issues, C++ introduced smart pointers, which automate memory allocation and deallocation. Smart pointers wrap around raw pointers and, depending on their type, automatically free memory when it is no longer needed.</p> <p>Instead of using <code>new</code> directly, smart pointers provide factory functions (e.g., <code>std::make_unique</code>, <code>std::make_shared</code>), which should be preferred as they:</p> <ul> <li>Improve exception safety by ensuring memory is allocated and assigned in one step.</li> <li>Simplify code by eliminating explicit calls to <code>new</code> and <code>delete</code>.</li> </ul> <p>To use smart pointers, include the <code>&lt;memory&gt;</code> header from the C++ Standard Library.</p>"},{"location":"06%20Pointers%20and%20References/#unique-pointer","title":"Unique Pointer","text":"<p>A unique pointer is a scoped smart pointer, meaning it automatically deallocates the allocated memory when it goes out of scope. This eliminates the need for manual <code>delete</code> calls and helps prevent memory leaks.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass Entity {\npublic:\n    Entity() {\n        std::cout &lt;&lt; \"Entity Created!\" &lt;&lt; std::endl;\n    }\n\n    ~Entity() {\n        std::cout &lt;&lt; \"Entity Destroyed!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    /*\n        Not recommended: manual allocation with new is valid but incorrect\n        std::unique_ptr&lt;Entity&gt; entity(new Entity());\n    */\n\n    // Preferred approach: using std::make_unique\n    std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;();\n\n    std::cout &lt;&lt; \"End of main scope\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Entity Created!\nEnd of main scope\nEntity Destroyed!\n</code></pre> <p>Here, the <code>Entity</code> class logs its creation and destruction, allowing us to observe when the unique pointer automatically deallocates the object at the end of <code>main</code>.</p> <p>A <code>std::unique_ptr</code> cannot be copied, ensuring exclusive ownership of the resource. Attempting to copy it will result in a compilation error. However, ownership can be transferred using <code>std::move()</code>.</p> <p>If multiple parts of a program need access to the same resource, consider using <code>std::shared_ptr</code> instead.</p>"},{"location":"06%20Pointers%20and%20References/#shared-pointer","title":"Shared Pointer","text":"<p>A <code>std::shared_ptr</code> works differently from a <code>std::unique_ptr</code> and has more complexity under the hood. It relies on reference counting, which keeps track of how many <code>shared_ptr</code> instances are pointing to the same resource. When the reference count reaches zero, meaning no more <code>shared_ptr</code> instances are using the resource, the allocated memory is automatically freed.</p> <p>Instances of <code>std::shared_ptr</code> are also destroyed at the end of their scope, but only the pointer itself, not the actual object it manages, unless the reference count reaches zero. If there are other <code>shared_ptr</code> instances still referencing the same object, the object will remain alive until the last <code>shared_ptr</code> is destroyed or reset. Therefore, they are also called strong references because they prevent the object from being destroyed.</p> <p>Additionally, you should not use <code>new</code> to create a <code>shared_ptr</code>. Instead, it's recommended to use <code>std::make_shared()</code>. This is because <code>std::make_shared()</code> performs a single allocation for both the object and the control block (which stores the reference count), leading to better performance and exception safety compared to manually calling <code>new</code>.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass Entity {\npublic:\n    Entity() {\n        std::cout &lt;&lt; \"Entity Created!\" &lt;&lt; std::endl;\n    }\n\n    ~Entity() {\n        std::cout &lt;&lt; \"Entity Destroyed!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::shared_ptr&lt;Entity&gt; e;\n\n    {\n        std::shared_ptr&lt;Entity&gt; shared_entity = std::make_shared&lt;Entity&gt;();\n\n        e = shared_entity;\n\n        std::cout &lt;&lt; \"End of isoleted scope\" &lt;&lt; std::endl;\n    }\n\n    /* \n        The inner scope ends here, and `shared_entity` goes out of scope\n        and is destroyed, but the object is not deleted because `e`\n        still holds a reference to it.\n\n        The object will only be deleted when `e` goes out of scope and \n        the reference count reaches zero, i.e., when the last `std::shared_ptr`\n        is destroyed.\n\n        The `Entity Destroyed!` message will be printed\n        when `e` goes out of `main()` scope.\n    */\n\n    std::cout &lt;&lt; \"End of main scope\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Entity Created!\nEnd of isoleted scope\nEnd of main scope\nEntity Destroyed!\n</code></pre> <p>In this example, there are two instances of <code>std::shared_ptr&lt;Entity&gt;</code>, one in the main scope (<code>e</code>) and one inside the inner scope (<code>sharedEntity</code>).</p> <p>Even though the inner scope ends and <code>sharedEntity</code> is destroyed, the object is not deleted because <code>e</code> still holds a reference to it. The object will only be destroyed when the last shared pointer managing it is destroyed or reset, which in this case happens when <code>e</code> goes out of scope at the end of <code>main()</code>.</p>"},{"location":"06%20Pointers%20and%20References/#weak-pointer","title":"Weak Pointer","text":"<p>Weak pointers are used in combination with shared pointers. They also allow sharing access to a resource, but they do not keep the resource alive because they do not increase the reference count.</p> <p>This can be useful when you need to observe or manipulate a shared resource (e.g., sorting a list of objects) without taking ownership of it.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass Entity {\npublic:\n    Entity() {\n        std::cout &lt;&lt; \"Entity Created!\" &lt;&lt; std::endl;\n    }\n\n    ~Entity() {\n        std::cout &lt;&lt; \"Entity Destroyed!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::weak_ptr&lt;Entity&gt; e;\n\n    {\n        std::shared_ptr&lt;Entity&gt; shared_entity = std::make_shared&lt;Entity&gt;();\n\n        e = shared_entity;\n\n        std::cout &lt;&lt; \"End of isoleted scope\" &lt;&lt; std::endl;\n    }\n\n    /*\n        The inner scope ends here, and `sharedEntity` goes out of scope,\n        is destroyed and the object is deleted immediately because `e`\n        is a weak pointer and does not increase the reference count.\n\n        Since no other `shared_ptr` exists after the inner scope ends,\n        the resource is freed immediately, and the `Entity Destroyed!`\n        message will be printed at the end of the isolated scope.\n    */\n\n    std::cout &lt;&lt; \"End of main scope\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Entity Created!\nEnd of isoleted scope\nEntity Destroyed!\nEnd of main scope\n</code></pre> <p>In this example, the Entity instance will be destroyed at the end of the inner scope, not at the end of <code>main()</code>. This happens because we assigned it to a weak pointer, which does not increase the reference count.</p> <p>Since no other <code>shared_ptr</code> exists after the inner scope ends, the resource is freed immediately.</p>"},{"location":"06%20Pointers%20and%20References/#when-to-use-smart-pointers","title":"When to use Smart Pointers","text":"<p>Smart pointers should be preferred over raw pointers as they provide better memory safety and help prevent memory leaks. Use <code>std::unique_ptr</code> when a heap allocation is necessary. <code>std::shared_ptr</code> should only be used when multiple owners are required, as it comes with additional overhead due to reference counting and internal management.</p> <p>However, there may be low-level cases where smart pointers are not sufficient, but these are uncommon in most high-level applications.</p>"},{"location":"06%20Pointers%20and%20References/#chapter-summary","title":"Chapter Summary","text":"<p>By completing this lesson, you should now have a solid understanding of computer memory and how objects are allocated on the stack and heap. You\u2019ve also learned why one might be more beneficial than the other in different situations.</p> <p>Additionally, you now understand ownership, how it works, why it matters, and when it can be useful. Finally, we explored smart pointers, which simplify memory management and help prevent memory leaks, making C++ programs more safe.</p>"},{"location":"07%20Collections%20of%20Data/","title":"07 Collections of Data","text":"<p>Info</p> <p>To understand how collections work in C++\u2014called containers\u2014it\u2019s essential to be comfortable with pointers and references, as these underpin how elements are stored and accessed in memory.</p> <p>As programs grow in complexity, working with individual variables quickly becomes impractical. Often, we need to sort data, search through or loop over it in different ways depending on the situation\u2014and that simply isn\u2019t feasible with standalone variables.</p> <p>That\u2019s exactly what data collections are for. They allow us to group and manage related values, following predefined rules based on our needs.</p> <p>In C++, collections come in the form of STL containers\u2014data structures designed to hold multiple elements of the same or related type. These structures make it possible to organize, access, and manipulate data in flexible and scalable ways. Whether you\u2019re storing a list of names, a grid of game tiles, or a queue of tasks to process, these containers provide the right tool for the job.</p> <p>We've already seen them pop up a few times\u2014C++ containers are templated, which means they use a special syntax with angle brackets to fix the type they store. This makes them usable with any type. For example, <code>std::variant</code> was one of them\u2014it even took more than one type at once.</p> <p>Now we\u2019ll explore practical, built-in solutions\u2014like arrays, strings, and powerful containers from the C++ Standard Template Library (STL)\u2014along with the logic behind how they work and how to optimize them. These implementations are fast, reliable, and used in real-world software every day\u2014so you don\u2019t have to reinvent the wheel. That said, it\u2019s not uncommon for large companies to use or develop their own versions of the STL, such as EA STL, Qt\u2019s container classes, or Unreal Engine\u2019s custom collections.</p>"},{"location":"07%20Collections%20of%20Data/#c-style-arrays","title":"C-Style Arrays","text":"<p>First, we'll look at C-style arrays\u2014one of the most basic, yet surprisingly powerful, data structures in C++. They originate from the C language (hence the name) and are often referred to as static arrays.</p> <p>A C-style array is a fixed-size collection of elements stored in contiguous memory, where every element must be of the same data type. This layout allows for fast access using indexing and straightforward traversal, as shown in the diagram below.</p> <p>Because all elements are of the same type and placed in continuous memory, they are simply offset by a fixed number of bytes\u2014the size of the data type. This makes it easy to move from one element to the next just by stepping through memory.</p> Index 0 1 2 4 5 Value <code>10</code> <code>20</code> <code>30</code> <code>40</code> <code>50</code> Address <code>0x1000</code> <code>0x1004</code> <code>0x1008</code> <code>0x100C</code> <code>0x1010</code> <p>That\u2019s why arrays are incredibly useful when working with multiple related values. Instead of declaring dozens of individual variables, we can group them together into a single structure\u2014simplifying both storage and access. For example, initializing 50 elements to zero would be tedious if done manually, but with an array, it\u2019s just a simple loop.</p> <p>That said, C-style arrays have important limitations. Their size is fixed at compile time, and they don\u2019t provide built-in bounds checking. This means it\u2019s easy to accidentally access memory outside the array\u2019s limits, which can lead to bugs or crashes if not handled carefully.</p> example<pre><code>int main() {\n    /*\n        Declaring multiple separate variables\n        is inefficient and repetitive.\n\n        int num1 = 0;\n        int num2 = 0;\n        int num3 = 0;\n        ...\n    */\n\n    // Use an array to store multiple values efficiently.\n    int arr[5];\n\n    /*\n        This syntax also initializes the array\n        immediately after declaration:\n\n        int arr[5] = {0, 0, 0, 0, 0};\n    */\n}\n</code></pre> <p>Note</p> <p>The syntax <code>int arr[5];</code> declares an array and reserves space for five integers, but it does not automatically initialize the elements\u2014they will contain garbage (random) values.</p> <p>Also remember that if you initialize the array with values (e.g., <code>int arr[] = {1, 2, 3};</code>), you can omit the size. In such cases, the compiler determines the size based on the number of elements provided.</p>"},{"location":"07%20Collections%20of%20Data/#accessing-and-modifying-elements","title":"Accessing and Modifying Elements","text":"<p>In the example above, we only allocated memory for five integers. To change individual elements after declaration, we use an index, which specifies the position of the element in the sequence. Because of how pointer arithmetic works, the first element is at index 0 not 1\u2014this corresponds to the memory address held by the array variable. This is because <code>int arr[]</code> is treated like a pointer by default.</p> <p>The syntax for accessing an element is simple: append square brackets to the array name and place the index inside.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int arr[5];\n\n    arr[0] = 10; // Assigns 10 to the first element\n    arr[2] = 30; // Assigns 30 to the third element\n\n    // Access third element for output\n    std::cout &lt;&lt; \"Third element: \" &lt;&lt; arr[2] &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Third element: 30\n</code></pre> <p>Danger</p> <p>Writing to memory you don't own\u2014beyond the array\u2019s allocated size\u2014leads to undefined behavior, which means your program could do anything from crashing immediately to silently corrupting memory.</p> <p>In debug mode, many compilers and runtime environments will catch this and stop the program with a memory access violation. But in release mode, it might appear to work fine\u2014until it suddenly doesn't. These kinds of bugs are notoriously difficult to track down, so always stay within the bounds of your array and always write index-to-size checks.</p>"},{"location":"07%20Collections%20of%20Data/#iterating-over-arrays","title":"Iterating Over Arrays","text":"<p>Arrays naturally bring us back to loops\u2014because when you have a collection of data, loops are the perfect tool for efficiently stepping through and working with each element. For example, if we\u2019ve declared an array for five integers, a for loop lets us visit every element and do something with it\u2014like assigning controlled pseudo-random values, since computers can\u2019t really produce truly random numbers.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // for std::srand and std::rand\n#include &lt;ctime&gt;   // for std::time\n\nint main() {\n    int array[5];\n\n    /* \n        Seed the random number generator with the current time\n        to ensure different sequences of numbers each run\n    */\n    std::srand(std::time(nullptr));\n\n    for (int i = 0; i &lt; sizeof(array) / sizeof(array[0]); ++i)\n        // Generate a pseudo-random number between 0 and 100 (inclusive)\n        array[i] = std::rand() % 101;\n\n    for (int i = 0; i &lt; sizeof(array) / sizeof(array[0]); ++i)\n        std::cout &lt;&lt; array[i] &lt;&lt; '\\t';\n}\n</code></pre> output<pre><code>65  30  83  46  92\n</code></pre> <p>In this example, we utilized the <code>sizeof</code> operator in the loop condition to determine the number of elements in the array. This ensures the loop runs exactly once per element, keeping our code safe and adaptable if the array size changes.</p> <p>Tip</p> <p>This example uses the C-style <code>std::rand()</code> function to generate pseudo-random numbers. While it\u2019s simple and widely supported, it\u2019s considered outdated in modern C++. For better randomness, control, and features, check out the C++ <code>&lt;random&gt;</code> header introduced in C++11. It provides more powerful and flexible tools to generate random numbers\u2014including floating-point values and more\u2014in a safer and more efficient way.</p> <p>More on that topic can be found here: https://cplusplus.com/reference/random/</p>"},{"location":"07%20Collections%20of%20Data/#pointers-arithmetic-on-arrays","title":"Pointers Arithmetic on Arrays","text":"<p>It\u2019s important to understand that arrays are tightly related to pointers. In fact, the array variable itself acts as a pointer to the first element of the array. So when you print just the array\u2019s name, what you\u2019re really seeing is the memory address of the first element.</p> <p>If we increment that pointer by one, it doesn\u2019t move forward by one byte\u2014it moves forward by the size of the type it points to. For an <code>int</code> array, this usually means 4 bytes per step (on most systems).</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int array[3] = {1, 2, 3};\n\n    int* ptr = array; // Points to the first element\n\n    std::cout &lt;&lt; \"First element: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n\n    ++ptr;            // Advances the pointer by 4 bytes\n\n    std::cout &lt;&lt; \"Second element: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>First element: 1\nSecond element: 2\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#array-heap-allocation","title":"Array Heap Allocation","text":"<p>Until now, we've declared arrays on the stack, meaning they're automatically managed and cleaned up when they go out of scope. However, we can use the <code>new</code> keyword to allocate an array on the heap, which gives us full control over its lifetime.</p> example<pre><code>int main() {\n    int* array = new int[5];\n    delete[] array;\n}\n</code></pre> <p>Since this array was allocated on the heap, it won't be automatically deallocated when the function ends. It will persist until we manually free it using <code>delete[]</code>, or until the program terminates.</p> <p>Danger</p> <p>If we allocate an array on the heap inside a function and forget to free it before the function ends, we lose access to that memory address\u2014resulting in a memory leak. Once it's out of scope with no pointer referencing it, there's no way to clean it up anymore.</p>"},{"location":"07%20Collections%20of%20Data/#multidimensional-arrays","title":"Multidimensional Arrays","text":"<p>The term multidimensional refers to arrays with more than one level of indexing. Whether it\u2019s 2D, 3D, or more, the underlying concept stays the same: a multidimensional array is simply an array of arrays and so on. This structure allows us to represent its elements like grids, matrices, or tables.</p> <p></p> <p>Since arrays are essentially pointers, a multidimensional array can be viewed as a pointer to a pointer\u2014each pointer in the top-level array refers to another block of memory that holds the actual data. This hierarchical structure lets us organize data in rows, columns, and beyond.</p>"},{"location":"07%20Collections%20of%20Data/#dynamically-allocating-a-2d-array","title":"Dynamically Allocating a 2D Array","text":"<p>To properly create a 2D array on the heap:</p> <ul> <li>Allocate memory for an array of pointers (the rows).</li> <li>Loop through each pointer and allocate a separate array for that row.</li> </ul> example<pre><code>int main() {\n    /*\n        Allocate a 2D array on the heap using a pointer-to-pointer\n        This helps illustrate how 2D arrays work under the hood\n    */\n    int** array2d = new int*[50];  // 50 rows\n\n    for (int i = 0; i &lt; 50; ++i)\n        array2d[i] = new int[10]; // Each row has 10 columns\n\n    /*\n        However, it's better to use a stack-allocated 2D array if possible\n        int array2d[2][3] = {{1, 2, 3},\n                             {4, 5, 6}};\n    */\n}\n</code></pre> <p>Each <code>array2d[i]</code> now points to a 1D array of integers, giving us a full 50\u00d710 grid of values.</p>"},{"location":"07%20Collections%20of%20Data/#deallocating-a-2d-array","title":"Deallocating a 2D Array","text":"<p>Each row is dynamically allocated separately, allowing for flexible memory management. However, since we are manually allocating memory, we must also free it later to prevent memory leaks.</p> <p>Danger</p> <p>When deallocating a multidimensional array, we cannot simply use <code>delete[] array2d</code> because that would only free the top-level pointer, leaving the allocated rows still in memory and causing a memory leak.</p> <p>To properly free a dynamically allocated 2D array, we must:</p> <ol> <li>Iterate through the first dimension and delete each row.</li> <li>Once all rows are freed, delete the main array pointer.</li> </ol> example<pre><code>int main() {\n    int** array2d = new int*[50];\n\n    for (int i = 0; i &lt; 50; ++i)\n        array2d[i] = new int[10];\n\n    for (int i = 0; i &lt; 50; ++i)\n        delete[] array2d[i];\n\n    delete[] array2d;\n}\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#access-multidimensional-arrays","title":"Access multidimensional arrays","text":"<p>To access elements in a multidimensional array, we extend our understanding of indexing. The first <code>[]</code> selects a row (an array), and the second <code>[]</code> selects a column (element within that row).</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int array2d[3][3] = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    std::cout &lt;&lt; \"Second row, third column: \" &lt;&lt; array2d[1][2] &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Second row, third column: 6\n</code></pre> <p>In this example, we demonstrated how to allocate a multidimensional array on the stack. This approach is much simpler, but it doesn\u2019t reveal how multidimensional arrays actually work under the hood. That\u2019s why we only introduced it at this point\u2014once the fundamentals were already in place.</p>"},{"location":"07%20Collections%20of%20Data/#optimizing-memory-access-for-multidimensional-arrays","title":"Optimizing Memory Access for Multidimensional Arrays","text":"<p>Multidimensional arrays do not store their data in a single contiguous memory block by default. Instead, they typically allocate multiple smaller buffers scattered across memory, leading to memory fragmentation, where data is no longer stored sequentially. This fragmentation causes inefficient memory access, as the CPU must jump between different memory locations\u2014resulting in increased overhead and slower performance.</p> <p>One way to optimize this is by improving cache locality, which minimizes costly memory jumps by keeping related data close together in memory.</p> <p>It might seem like there's no easy fix for this, but there actually is. If we know the dimensions of the array ahead of time, we can allocate a single contiguous block of memory (i.e., a one-dimensional array) and manually compute row and column indices to simulate multidimensional access.</p> <p>This approach avoids the overhead of multiple <code>new</code> allocations and takes better advantage of the CPU cache. Additionally, allocating the array on the stack (when size is known and small enough) instead of dynamically on the heap further improves performance and memory safety.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int rows = 50, cols = 10;\n    int* array = new int[rows * cols];\n\n    // Accessing elements using index calculations\n    int row = 2, col = 3;\n    array[row * cols + col] = 42;\n\n    std::cout &lt;&lt; \"Value at [\" &lt;&lt; row &lt;&lt; \"][\" &lt;&lt; col &lt;&lt; \"]: \" \n              &lt;&lt; array[row * cols + col] &lt;&lt; std::endl;\n\n    delete[] array;\n}\n</code></pre> output<pre><code>Value at [2][3]: 42\n</code></pre> <p>This method ensures that all elements are stored in a single contiguous memory block, reducing fragmentation and significantly improving performance. Whenever possible, prefer this approach to optimize memory access and cache efficiency.</p> <p>Even when you imagine an image as a multidimensional array of pixels, it isn't, it is just a single-dimensional array stored in memory. The concept of rows and columns is simply an abstraction used for easier indexing and manipulation.</p>"},{"location":"07%20Collections%20of%20Data/#strings","title":"Strings","text":"<p>Strings\u2014or text in general\u2014are a surprisingly complex topic in computing, largely due to character encoding and how characters are represented in memory. By default, C++ uses the <code>char</code> type to represent individual characters, typically assuming an ASCII-compatible encoding, such as UTF-8.</p> <p>However, ASCII has a major limitation: it uses only 1 byte per character, giving just 256 possible values. That\u2019s nowhere near enough to represent the thousands of characters used across different languages and symbol sets.</p> <p>To solve this, modern encodings like Unicode and especially UTF-8 were introduced. These allow much broader and more flexible character representation, supporting virtually all human languages.</p> <p>From a structural point of view, strings are closely related to arrays, because they both act as buffers of a specific type. In fact, a basic string in C and C++ is just an array or pointer of <code>char</code> values stored contiguously in memory.</p>"},{"location":"07%20Collections%20of%20Data/#c-style-string","title":"C-Style String","text":"<p>We briefly encountered this style of string in the earlier chapters\u2014for example, when using <code>std::cout</code>\u2014but we didn\u2019t stop to examine how it actually works. Now that we have the necessary background on arrays, pointers, and memory, we can finally explore it in more detail.</p> main.cpp<pre><code>int main() {\n    const char* string = \"Hello World!\";\n\n    std::cout &lt;&lt; string &lt;&lt; std::endl;\n}\n</code></pre> <p>In the example above, a few important things are happening:</p> <ul> <li>The string is written using double quotes, which tells the compiler to create a string literal\u2014a fixed, read-only block of characters.</li> <li>The variable is declared as <code>const char*</code>, meaning it\u2019s a pointer to a constant character buffer.   This pointer points to the beginning of the string literal, which is stored in read-only memory.</li> <li>The <code>const</code> is important\u2014it prevents accidental modification of the string.   If you try to change a string literal, you\u2019ll get undefined behavior, and many compilers will crash the program to protect memory.</li> </ul> <p>One key detail about string literals is that they are null-terminated. Behind the scenes, the compiler automatically adds a special character, <code>\\0</code>, to the end of the string. This marks where the string ends in memory.</p> Index 0 1 2 3 4 5 Value H e l l o \\0 <p>Without that null character, functions like <code>std::cout</code> wouldn\u2019t know when to stop reading characters, and you'd likely end up printing garbage data\u2014or crashing your program.</p>"},{"location":"07%20Collections%20of%20Data/#modifying-c-style-strings","title":"Modifying C-Style Strings","text":"<p>If you want a string that you can modify, you need to create it differently. Rather than pointing to a read-only literal, you allocate a character array that lives in stack memory.</p> main.cpp<pre><code>int main() {\n    char string[] = \"Hello World!\";\n\n    string[1] = 'a';\n}\n</code></pre> <p>This creates a mutable copy of the string. Each character is stored in stack memory, and you can safely modify it. The null terminator is still added at the end automatically.</p>"},{"location":"07%20Collections%20of%20Data/#c-string","title":"C++ String","text":"<p>Info</p> <p>The <code>std::string</code> API provides solutions for nearly all string-related problems. Covering every possible edge case and method here would be unnecessary. If you need a specific solution, you can refer to the C++ documentation available here: https://cplusplus.com/reference/string/string/</p> <p>Now that we\u2019ve explored C-style strings and how they work under the hood, it\u2019s time to introduce the more modern and user-friendly C++ alternative: <code>std::string</code>.</p> <p>C++ provides a powerful templated class called <code>std::string</code> for handling and manipulating text. Internally, it still uses a <code>char</code> array as its underlying data structure, but it wraps that low-level complexity in a much more intuitive and safer interface.</p> <p>To use <code>std::string</code>, we include the <code>&lt;string&gt;</code> header, which defines the class and its methods. While <code>std::string</code> can technically be used with just <code>&lt;iostream&gt;</code>, doing so doesn\u2019t give you full access to all of its functionality\u2014so it\u2019s best practice to explicitly include <code>&lt;string&gt;</code>.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string string = \"Hello World!\";\n\n    std::cout &lt;&lt; string &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>This example shows a simple way to declare and print a string in C++. Behind the scenes, <code>std::string</code> automatically handles memory allocation, resizing, copying, and null-termination for you.</p>"},{"location":"07%20Collections%20of%20Data/#string-concatenation","title":"String Concatenation","text":"<p>With <code>std::string</code>, concatenating text is simple. We can use the <code>+=</code> operator to append new content, or use the <code>.append()</code> method for a more explicit and readable approach. Both options do the same thing\u2014it\u2019s just a matter of preference.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string string = \"Hello World!\";\n\n    string += \" Another string!\";\n    string.append(\" Yet another string!\");\n\n    std::cout &lt;&lt; string &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hello World! Another string! Yet another string!\n</code></pre> <p>The problem arises when we try to concatenate two string literals, as they are both raw C-style <code>const char*</code> values. Since these are pointers to character arrays, there's no built-in + operator to add two <code>const char*</code> values together. In other words, C++ doesn\u2019t know how to \"add\" two pointers and produce a combined string.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string string = \"Hello \" + \"World!\";\n}\n</code></pre> output<pre><code>error: invalid operands\n</code></pre> <p>To fix this, you need to convert at least one of them to <code>std::string</code>, type which knows how to handle dynamic memory and concatenation.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string message = std::string(\"Hello \") + \"World!\";\n\n    std::cout &lt;&lt; message &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>There's also a shortcut: if you're just trying to break a long string across multiple lines or connect with a definition, C-style string literals placed next to each other automatically merge at compile time. This works without any concatenation operator.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#define RESOURCES_PATH \"assets/\"\n\nint main() {\n    const char* path = RESOURCES_PATH\n                       \"textures/\"\n                       \"player.png\";\n\n    std::cout &lt;&lt; path &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>assets/textures/player.png\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#string-literals","title":"String Literals","text":"<p>Danger</p> <p>Modifying a string literal like leads to undefined behavior, because literals are stored in read-only memory.</p> <p>Now that we've learned how to store and manipulate text, it's time to cement our understanding of what string literals actually are.</p> <p>A string literal is a sequence of characters enclosed in double quotes. In C++, these are stored as pointers to arrays of <code>char</code> values, and they are automatically null-terminated\u2014meaning a special character is placed at the end to signal where the string stops.</p> <p>In contrast, a character literal is written inside single quotes and represents a single char value.</p> main.cpp<pre><code>int main() {\n    char character = 'A';      // Single character\n    const char* string = \"A\";  // Null-terminated C-string {'A', '\\0'}\n}\n</code></pre> <p>Although both contain single character <code>A</code>, the first is a single character stored in a single byte, while the second is a pointer to a two-character array: <code>'A'</code> followed by <code>'\\0'</code>. This distinction matters, especially when performance or memory layout is important. If you only need one character, avoid using a full string literal\u2014it's less efficient and potentially misleading.</p>"},{"location":"07%20Collections%20of%20Data/#raw-string-literals","title":"Raw String Literals","text":"<p>Sometimes, escape sequences like <code>\\n</code>, <code>\\t</code>, or <code>\\\\</code> get in the way\u2014especially when working with file paths, regular expressions, or JSON. To help with this, C++ offers raw string literals, written using <code>R\"(...)\"</code>. Inside the parentheses, everything is treated as plain text without interpreting escape sequences. This removes the need for double backslashes and other annoying escapes.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string raw_string = R\"(C:\\Users\\UserName\\Documents\\file.txt)\";\n\n    std::cout &lt;&lt; raw_string &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>C:\\Users\\UserName\\Documents\\file.txt\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#unicode-string-literals","title":"Unicode String Literals","text":"<p>Warning</p> <p>As mentioned earlier, non-ASCII characters can cause compatibility issues across different system architectures. Unless you're working on a graphical user interface (GUI) or an application that explicitly requires Unicode, it's often better to avoid using non-ASCII characters in general-purpose or console-based programs.</p> <p>C++ also supports Unicode and wide character string literals, which are essential for representing characters outside of ASCII (like emoji, accented letters, or non-Latin scripts). These literals use prefixes to indicate encodings.</p> Prefix Type Encoding Notes <code>L\"\"</code> <code>wchar_t</code> Platform-defined (UTF-16/32) <code>u\"\"</code> <code>char16_t</code> UTF-16 Fixed 2 bytes per char <code>U\"\"</code> <code>char32_t</code> UTF-32 Fixed 4 bytes per char <code>u8\"\"</code> <code>char</code> UTF-8 Same type as <code>std::string</code>"},{"location":"07%20Collections%20of%20Data/#small-strings","title":"Small Strings","text":"<p>Strings are a foundational part of programming, and while they\u2019re often convenient to use, they carry a reputation for being slow. This is mostly due to frequent memory allocations on the heap, which are slower than stack allocations.</p> <p>To address this, modern implementations of <code>std::string</code> include an optimization called Small String Optimization (SSO). This technique avoids heap allocation for small strings by storing them directly on the stack.</p> <p>Note</p> <p>The exact size limit for SSO varies between implementations. For instance, Microsoft\u2019s Visual C++ (MSVC) stores strings up to 15 characters on the stack. Longer strings are allocated on the heap.</p> <p>This optimization is transparent to the user and one of the main reasons <code>std::string</code> is preferred over C-style strings in modern C++.</p>"},{"location":"07%20Collections%20of%20Data/#optimize-strings-in-c","title":"Optimize Strings in C++","text":"<p>As noted, frequent heap allocations are the main source of performance overhead. While not inherently bad, heap allocations are relatively expensive, especially inside performance-critical loops.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstatic unsigned int s_alloc_count = 0;\n\nvoid* operator new(size_t size) {\n    s_alloc_count++;\n    std::cout &lt;&lt; \"Allocating: \" &lt;&lt; size &lt;&lt; \" bytes\" &lt;&lt; std::endl;\n    return malloc(size);\n}\n\nvoid operator delete(void* memory, size_t size) {\n    std::cout &lt;&lt; \"Deallocating: \" &lt;&lt; size &lt;&lt; \" bytes\" &lt;&lt; std::endl;\n    free(memory);\n}\n\nvoid PrintNameReference(const std::string&amp; name) {\n    std::cout &lt;&lt; name &lt;&lt; std::endl;\n}\n\nint main() {\n    std::string small_string = \"Unknown Name\";        // Stack allocation\n    std::string large_string = \"Unknown Name Longer\"; // Heap allocation\n    PrintNameReference(large_string);\n\n    std::cout &lt;&lt; \"Total Allocations: \" &lt;&lt; s_alloc_count &lt;&lt; std::endl;\n}\n</code></pre> output msvc debug<pre><code>Allocating: 16 bytes -&gt; small_string\nAllocating: 16 bytes -&gt; large_string metadata\nAllocating: 32 bytes -&gt; large_string content\n\nRandom Jordan Second\nTotal Allocations: 3\n\nDeallocating: 32 bytes -&gt; large_string content\nDeallocating: 16 bytes -&gt; large_string metadata\nDeallocating: 16 bytes -&gt; small_string\n</code></pre> output msvc release<pre><code>Allocating: 32 bytes\n\nRandom Jordan Second\nTotal Allocations: 1\n\nDeallocating: 32 bytes\n</code></pre> <p>The Small String Optimization typically applies in release mode with the Microsoft Visual C++ compiler. In Debug mode, MSVC disables many optimizations and adds extra bookkeeping (like iterator debugging and guard buffers), which often prevents SSO from activating.</p> <p>Interestingly, the same allocation behavior occurs even if we don\u2019t explicitly create a <code>std::string</code> variable, and instead pass a string literal directly to a function. That\u2019s because a temporary <code>std::string</code> is still constructed behind the scenes from the literal.</p> <pre><code>PrintNameReference(\"Random Jordan Second\");\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#substring-operations-overhead","title":"Substring Operations Overhead","text":"<p>Problems can arise when manipulating strings\u2014such as extracting substrings\u2014because each operation typically results in a new string which needs another heap allocation. This can introduce performance overhead, especially when used inside loops or performance-critical code.</p> main.cpp<pre><code>/*\n    Operator overloads for memory tracking from example before\n    PrintName function implementation \n*/\n\nint main() {\n    std::string name = \"Unknown Name Longer\";\n\n    std::string firstName = name.substr(0, 6);\n    std::string lastName = name.substr(8, 17);\n\n    std::cout &lt;&lt; \"Total Allocations: \" &lt;&lt; s_alloc_count &lt;&lt; std::endl;\n}\n</code></pre> output msvc debug<pre><code>Allocating: 16 bytes\nAllocating: 16 bytes\nAllocating: 16 bytes\n\nTotal Allocations: 3\n\nDeallocating: 16 bytes\nDeallocating: 16 bytes\nDeallocating: 16 bytes\n</code></pre> <p>When we extract portions of an existing string using substr, each call results in a new <code>std::string</code> being constructed. This means a fresh heap allocation is performed, and the relevant characters are copied from the original string into the new one. While this might seem harmless in small, isolated cases, it introduces unnecessary overhead.</p> <p>The root of the issue is how <code>std::string::substr</code> behaves: it always returns a new string, rather than referencing a slice of the original. Even if we pass that substring directly to a function, a temporary string is still created behind the scenes, leading to the same allocation cost.</p>"},{"location":"07%20Collections%20of%20Data/#string-views","title":"String Views","text":"<p>To avoid these allocations, we need a way to reference a substring without copying it. This is exactly what the C++ Standard Library offers with <code>std::string_view</code>. Unlike <code>std::string</code>, a <code>string_view</code> is a non-owning view into an existing character sequence. It performs no allocations and provides a lightweight, efficient way to work with substrings.</p> main.cpp<pre><code>// Operator overloads for memory tracking from example before\n\nvoid PrintNameView(std::string_view name) {\n    std::cout &lt;&lt; name &lt;&lt; std::endl;\n}\n\nint main() {\n    std::string name = \"Unknown Name\";\n\n    std::string_view first_name(name.c_str(), 6);\n    std::string_view last_name(name.c_str() + 8, 4);\n\n    PrintNameView(first_name);\n    PrintNameView(last_name);\n\n    std::cout &lt;&lt; \"Total Allocations: \" &lt;&lt; s_alloc_count &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Allocating: 16 bytes\nUnknow\nName\nTotal Allocations: 1\nDeallocating: 16 bytes\n</code></pre> <p>By switching to <code>std::string_view</code>, we\u2019ve reduced the number of heap allocations down to just one\u2014the one used to create the original <code>std::string</code>. Since view doesn\u2019t copy data, it allows us to reference parts of the string without triggering additional allocations.</p> <p>Instead of calling substring, we now construct <code>std::string_view</code> objects directly. The constructor takes two arguments:</p> <ol> <li>A starting pointer position \u2013 typically provided by <code>name.c_str()</code>, which gives access to the underlying character data.</li> <li>A length \u2013 indicating how many characters to include starting from the pointer you provided.</li> </ol> <p>Since <code>c_str()</code> returns a <code>const char*</code>, we can use pointer arithmetic (like name.c_str() + 7) to adjust the starting point of the view dynamically.</p> <p>To support this approach, we also have to create new function to accept a <code>std::string_view</code> instead of a full <code>std::string</code>, ensuring that no temporary allocations occur when passing substrings around.</p> <p>But we can go even further\u2014down to zero allocations\u2014by skipping <code>std::string</code> entirely. If we declare the original string as a plain <code>const char*</code>, we avoid heap usage altogether. These literals are stored in static memory (often embedded directly in the binary), and don't trigger any heap allocations which are tracked by <code>s_alloc_count</code>.</p> main.cpp<pre><code>// Operator overloads for memory tracking from example before\n// PrintNameView function\n\nint main() {\n    const char* name = \"Unknown Name Longer\";\n\n    std::string_view first_name(name, 6);\n    std::string_view last_name(name + 8, 4);\n\n    PrintNameView(first_name);\n    PrintNameView(last_name);\n\n    std::cout &lt;&lt; \"Total Allocations: \" &lt;&lt; s_alloc_count;\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>Since it's already a <code>char*</code> pointer, we can simply pass the variable <code>name</code> instead of using <code>c_str()</code>.</p> <p>Note</p> <p>If we need to mutate the string, <code>char*</code> is no longer an option, as <code>char*</code> is non-modifiable strings in this context.</p>"},{"location":"07%20Collections%20of%20Data/#c-static-array","title":"C++ Static Array","text":"<p>Earlier in this chapter, we referred to the C-style array\u2014also known as a static array\u2014and mentioned how it has a fixed size that cannot be changed after its declaration. Now, let\u2019s focus on the C++ Standard Library's static array: <code>std::array</code>. While it shares the fixed-size nature of C-style arrays, it offers several advantages that make it more practical and safer to use in modern C++. To use <code>std::array</code>, simply include the <code>&lt;array&gt;</code> header.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nint main() {\n    std::array&lt;int, 5&gt; array;\n    array[0] = 1;\n    array[4] = 5;\n\n    // Easily access array size as count of elements\n    std::cout &lt;&lt; array.size();\n}\n</code></pre> output<pre><code>5\n</code></pre> <p>This example shows how to declare a static array using <code>std::array</code> and access its elements. The interface is quite similar to C-style arrays, but with additional functionality.</p> <p><code>std::array</code> takes two template parameters:</p> <ol> <li>The type of elements it stores</li> <li>The size (number of elements)</li> </ol> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nvoid PrintArray(const std::array&lt;int, 5&gt;&amp; array) {\n    for (int i = 0; i &lt; 5; ++i)\n        std::cout &lt;&lt; array[i] &lt;&lt; '\\t';\n}\n\nint main() {\n    std::array&lt;int, 5&gt; array = {}; // Zero-initialize all elements\n    array[0] = 1;\n    array[4] = 5;\n\n    PrintArray(array);\n}\n</code></pre> output<pre><code>1   0   0   0   5\n</code></pre> <p>One limitation is clear in this example: the size of the array (5) must be part of the function's type signature, which reduces flexibility and modularity. Later with templates, we\u2019ll learn how to solve this by templating the function itself.</p> <p>Alternatively, if you need a resizable container, you may want to use a dynamic array such as <code>std::vector</code> instead.</p> <p>Despite this constraint, <code>std::array</code> introduces no performance overhead compared to raw arrays. In return, you get stronger type safety and better integration with the STL. For these reasons, it should be preferred over C-style arrays in modern C++ code.</p>"},{"location":"07%20Collections%20of%20Data/#dynamic-array","title":"Dynamic Array","text":"<p>Info</p> <p>We won\u2019t go into every feature of <code>std::vector</code> here, as it\u2019s a large and powerful tool. For more tailored usage, refer to the documentation: cplusplus.com/reference/vector/vector</p> <p>When we need a C++ container that can resize by adding or removing elements during runtime, the Standard Library provides a dynamic array implementation called <code>std::vector</code>. Its key feature is exactly what we\u2019d expect from a dynamic container: automatic resizing, making it ideal when the number of elements isn\u2019t known in advance or is expected to change over time.</p> <p>Under the hood, a vector manages memory dynamically. The actual element data is stored on the heap, while the vector object itself\u2014along with its pointer to the data, current size, and capacity\u2014is stored on the stack.</p> <p>As you add elements, the vector will automatically expand its internal storage when needed. For example, if a vector initially reserves space for 10 elements and you push more, it will:</p> <ol> <li>Allocate a new, larger block of memory (usually doubling the capacity)</li> <li>Copy the existing elements into the new memory</li> <li>Release the old memory</li> <li>Update its internal pointer to point to the new block</li> </ol> <p>Just like <code>std::array</code>, vectors support indexing, range-based loops, and all the common STL algorithms like sorting and searching. The big difference is that you don\u2019t need to define the size ahead of time.</p> <p>To use vectors in your project, include the <code>&lt;vector&gt;</code> header from the Standard Library.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; dynamicArray = {58, 11, 94, 36, 77};\n    dynamicArray.push_back(63);\n\n    std::cout &lt;&lt; dynamicArray[5] &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>63\n</code></pre> <p>By default, <code>std::vector</code> stores its elements in a contiguous block of memory on the heap, not as separate pointers. The vector object itself\u2014including its size, capacity, and a pointer to its data\u2014is kept on the stack when the vector is declared as a local variable.</p> <p>For complex types like structures, the objects themselves are still stored directly within the vector's memory block, not just pointers to them. This means that whenever the vector resizes, each object is moved into the new memory block, which can introduce performance overhead depending on how expensive those moves are.</p> example<pre><code>int main() {\n    int* static_array1 = new int[500000];\n    std::array&lt;int, 500000&gt; static_array2;\n}\n</code></pre> <p>In this example, we allocate a large array both heap and stack. While pre-allocating a large array might seem like a way to avoid future resizing, it introduces some serious risks.</p> Issue Description Stack Overflow <code>std::array&lt;int, 500000&gt;</code> is allocated on the stack, which has limited space (typically around 2 MB). Exceeding this causes an immediate crash. Heap Exhaustion <code>new int[500000]</code> allocates memory on the heap, which has more space than the stack, but can still run out if memory is low or overused. <p>While vectors offer a safe and flexible way to manage dynamic arrays, they aren\u2019t magic\u2014they still rely on memory allocations and must be used wisely.</p>"},{"location":"07%20Collections%20of%20Data/#vector-optimization","title":"Vector Optimization","text":"<p>Now that we understand how <code>std::vector</code> works internally\u2014especially its dynamic resizing behavior\u2014we can take it a step further and discuss how to use it more efficiently.</p> <p>Optimizing performance in C++ often means understanding what\u2019s happening under the hood. In the case of vectors, that includes how memory is managed, how elements are copied or moved, and how frequently reallocation occurs.</p> <p>Whenever you add elements to a vector that has reached its capacity, it must allocate a larger memory block to accommodate the new data. It then copies all existing elements into the new block, deallocates the old memory, and updates its internal pointer. This reallocation process happens automatically as needed, but if triggered too often, it can introduce significant performance costs.</p> <p>By default, a vector typically grows its capacity by around 50% of the previous one when resizing. While this amortizes the cost across many insertions, frequent resizes can still slow things down\u2014especially when dealing with large amounts of data or non-trivial object types.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass Vertex {\npublic:\n    float x;\n    float y;\n    float z;\n\n    Vertex() = default;\n\n    Vertex(float x, float y, float z)\n        : x(x), y(y), z(z) {\n    }\n\n    Vertex(const Vertex&amp; vertex)\n        : x(vertex.x), y(vertex.y), z(vertex.z) {\n        std::cout &lt;&lt; \"Copied!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::vector&lt;Vertex&gt; vertices;\n\n    vertices.push_back(Vertex(1, 2, 3));\n    vertices.push_back(Vertex(4, 5, 6));\n    vertices.push_back(Vertex(7, 8, 9));\n}\n</code></pre> output<pre><code>Copied!\nCopied!\nCopied!\nCopied!\nCopied!\nCopied!\n</code></pre> <p>Let\u2019s break down what\u2019s happening in the example above. When running this code, you'll see six copy operations\u2014even though we're only adding three elements. This might seem surprising at first, but it reveals two important areas where we can optimize our use of <code>std::vector</code>.</p> <p>The first issue is how we're adding elements. When we write it as is we're creating a temporary <code>Vertex</code> object and then copying it into the vector. Even though the construction happens inside the <code>push_back</code> call, it's still a two-step process: first, the object is constructed, then it\u2019s copied into the vector. This accounts for three copies\u2014one for each object we add.</p> <p>The second problem stems from how <code>std::vector</code> handles its memory. When we don\u2019t specify a capacity ahead of time, the vector starts with a small default capacity (often 2, depending on the implementation). As we add more elements, the vector must resize itself. Each time this happens, it allocates new memory, copies all existing elements into the new block, and deallocates the old one. Since we\u2019re adding three elements and the initial capacity isn't sufficient, we trigger at least one reallocation, which causes the existing elements to be copied again. That\u2019s another three copies, bringing the total to six.</p> <p>To prevent these unnecessary copies, there are two simple optimizations we can apply:</p> <ol> <li>Reserve memory ahead of time: If we know how many elements we'll add, we can call <code>.reserve()</code> on the vector before inserting data.    This ensures enough space is allocated up front, so no reallocations are needed during insertion.</li> <li>Construct in-place: Instead of using <code>push_back</code>, use <code>emplace_back</code>, which constructs the object directly inside the vector, avoiding the temporary copy.</li> </ol> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass Vertex {\npublic:\n    float x;\n    float y;\n    float z;\n\n    Vertex() = default;\n\n    Vertex(float x, float y, float z)\n        : x(x), y(y), z(z) {\n    }\n\n    Vertex(const Vertex&amp; vertex)\n        : x(vertex.x), y(vertex.y), z(vertex.z) {\n        std::cout &lt;&lt; \"Copied!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::vector&lt;Vertex&gt; vertices;\n    vertices.reserve(3);\n\n    vertices.emplace_back(1, 2, 3);\n    vertices.emplace_back(4, 5, 6);\n    vertices.emplace_back(7, 8, 9);\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>It's also worth noting that there is another way to initialize a vector with a default size, but it is not as efficient. While the <code>reserve</code> method is more explicit and better, it can be substituted with syntax where we specify the vector's size directly in the constructor. This not only reserves memory but also defaultly initializes the elements (e.g., filling an integer vector with zeros or a string vector with empty strings).</p> example<pre><code>std::vector&lt;Vertex&gt; vertices(3);\n</code></pre> <p>However, this method should be used with caution because, although it avoids reallocations, it still results in unnecessary copies. Specifically, using this approach would create 3 copies in this context, as we are assigning values after initialization. Instead, using <code>emplace_back</code> is the more efficient way to handle this situation.</p>"},{"location":"07%20Collections%20of%20Data/#hashmap","title":"HashMap","text":"<p>Info</p> <p>As always, we won\u2019t cover every single operation available for C++ maps here\u2014our focus is on understanding how they work logically. For a complete list of functionalities, refer to the documentation:</p> <ul> <li>https://cplusplus.com/reference/map/map/</li> <li>https://cplusplus.com/reference/unordered_map/unordered_map/</li> </ul> <p>Sometimes, we need more than just a list of values. We want to associate one piece of data with another\u2014like a name with a phone number, or a username with a score. This is for what associative containers, also known as maps, are for.</p> <p>Unlike arrays or vectors, which use numeric indices to access elements, maps store key\u2013value pairs. You provide a unique key, and the map returns the corresponding value. This means maps are ideal when you need fast access to specific elements, especially when you don\u2019t care about the order of the data.</p> <p>In C++, the Standard Library provides two main types of maps.</p> Type Description <code>std::map</code> A sorted map implemented using a self-balancing red-black tree. <code>std::unordered_map</code> A hash table that offers faster lookups by using a hashing algorithm. <p>A <code>std::map</code> keeps its keys in sorted order using a red-black tree under the hood. Each time you insert or search for a key, it traverses the tree by comparing keys until it finds the correct spot. The tradeoffs are lookups and insertions have a time complexity of O(log n)\u2014which is still fast, but not as fast as a hash map for most use cases.</p> <p></p> <p>Because of the guaranteed order, <code>std::map</code> is useful when you want to iterate through the keys in sorted order or need range-based queries.</p> <p>If you don\u2019t care about key order and just want the fastest possible lookups, <code>std::unordered_map</code> is usually the better choice. It uses a hash function to compute an index for each key, giving it average-case constant-time access\u2014O(1). This is ideal when you're doing lots of lookups and inserts based on unique keys.</p> <p></p> <p>However, this speed comes with tradeoffs. <code>std::unordered_map</code> uses more memory, and hash collisions (when two keys hash to the same index) can slow things down slightly. But in most real-world scenarios, the performance gain is worth it. So prefer <code>std::unordered_map</code> for its speed\u2014unless you need the keys to stay sorted or require ordered traversal.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n\nstruct City {\n    unsigned int area_km;\n    unsigned int population;\n};\n\nint main() {\n    std::map&lt;std::string, City&gt; city_records1;\n    std::unordered_map&lt;std::string, City&gt; city_records2;\n\n    city_records1[\"London\"] = City{\n        .area_km = 1'572,\n        .population = 8'945'309\n    };\n    city_records1[\"Madrid\"] = City{\n        .area_km = 604,\n        .population = 3'345'894\n    };\n\n    city_records2[\"Berlin\"] = City{\n        .area_km = 891,\n        .population = 3'596'999\n    };\n    city_records2[\"Sydney\"] = City{\n        .area_km = 12'367,\n        .population = 3'596'999\n    };\n\n    std::cout &lt;&lt; \"London population: \" &lt;&lt; city_records1[\"London\"].population &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"London area: \" &lt;&lt; city_records1[\"London\"].area_km &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"Berlin population: \" &lt;&lt; city_records2[\"Berlin\"].population &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Berlin area: \" &lt;&lt; city_records2[\"Berlin\"].area_km &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>London population: 8945309\nLondon area: 1572\nBerlin population: 3596999\nBerlin area: 891\n</code></pre> <p>Both <code>std::map</code> and <code>std::unordered_map</code> store data as key-value pairs and take two template parameters: the key type and the value type. You can access and modify values using the same square bracket syntax you're used to with arrays: <code>map[key]</code>.</p> <p>One important behavior to be aware of is this: if you access a key that doesn\u2019t exist yet, the map will automatically create a new entry with a default-constructed value. This can be convenient in many cases, but it can also introduce bugs if you're not careful\u2014especially if you accidentally use a key that was never meant to be inserted.</p> <p>There\u2019s also a key difference between <code>std::map</code> and <code>std::unordered_map</code> in terms of how they manage keys:</p> Container Type Key Requirement Reason <code>std::map</code> Must support the less-than operator (<code>&lt;</code>) Keys are stored in sorted order using a tree structure <code>std::unordered_map</code> Must be hashable Keys are stored in a hash table, which uses a hash function for lookup <p>If you try to use a custom type as a key without implementing the appropriate comparison or hashing support, the compiler will produce an error.</p>"},{"location":"07%20Collections%20of%20Data/#hashing-function","title":"Hashing Function","text":""},{"location":"07%20Collections%20of%20Data/#index-operator","title":"Index Operator","text":"<p>When working with constant maps (such as <code>const std::unordered_map</code>), the index operator cannot be used. This is because it will insert a default-constructed value if the key doesn\u2019t exist\u2014an action that would modify the map, which isn\u2019t allowed on a constant object. This behavior was mentioned earlier and is exactly why using index operator on constant maps causes a compilation error.</p> <p>To safely access elements in a constant map without risking modification, we use the <code>.at()</code> method. Unlike index operator, it performs bounds checking and throws an out of range exception if the key doesn\u2019t exist\u2014so we must first ensure the key is present.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nstruct City {\n    unsigned int area_km;\n    unsigned int population;\n};\n\nint main() {\n    std::unordered_map&lt;std::string, City&gt; city_records = {\n        {\"Berlin\", City{\n            .area_km = 891,\n            .population = 3'596'999\n        }}\n    };\n\n    if (city_records.find(\"Berlin\") != city_records.end())\n        std::cout &lt;&lt; \"Berlin population: \" &lt;&lt; city_records.at(\"Berlin\").population &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Berlin population: 3596999\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#linked-list","title":"Linked List","text":"<p>We\u2019ve now covered the most commonly used containers in C++. However, there are still some data structures worth knowing\u2014even if they\u2019re not as commonly used in modern code. One such structure is the linked list, which is available in the C++ Standard Library as <code>std::list</code>.</p> <p>While many of its use cases can be mimicked using the containers we\u2019ve already introduced, a linked list is unique in its structure and behavior. The C++ STL implementation specifically provides a doubly linked list, which, like <code>std::vector</code>, supports dynamic resizing, but with a completely different internal mechanism.</p> <p>Unlike arrays and vectors that store elements in contiguous memory blocks, a linked list is composed of nodes. Each node holds:</p> <ol> <li>a value</li> <li>a pointer to the previous node</li> <li>a pointer to the next node</li> </ol> <p></p> <p>This layout enables fast insertions and deletions from anywhere in the list without shifting elements, making it useful in specific scenarios. However, it also brings increased memory usage and no support for random access, making it less performant for frequent lookups compared to vectors.</p> <p>To use a linked list in C++, just include the <code>&lt;list&gt;</code> header.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nint main() {\n    std::list&lt;int&gt; list = {73, 19, 86, 42, 5};\n    list.push_back(67);\n\n    for (const auto&amp; element : list)\n        std::cout &lt;&lt; element &lt;&lt; '\\t';\n}\n</code></pre> output<pre><code>73  19  86  42  5\n</code></pre> <p>The <code>std::list</code> class offers a familiar interface\u2014its API is very similar to that of <code>std::array</code> and <code>std::vector</code>. The real difference lies in how it stores and manages its data.</p> <p>You should consider using <code>std::list</code> when your program involves frequent insertions or deletions at arbitrary positions in the sequence. Unlike std<code>::vector</code>, a linked list doesn\u2019t need to shift elements when inserting or removing them in the middle. This can significantly improve performance in certain scenarios.</p> <p>Another major benefit of <code>std::list</code> is iterator stability\u2014modifying the container (such as inserting or removing elements) does not invalidate existing iterators, which is not the case with <code>std::vector</code>.</p> <p>That said, in the majority of situations, <code>std::vector</code> remains the better default choice. It provides better memory efficiency, faster random access, and superior cache performance due to its use of contiguous memory.</p> <p>In short: use <code>std::list</code> for frequent insertions/removals in the middle; stick with <code>std::vector</code> when you care about access speed and memory locality.</p>"},{"location":"07%20Collections%20of%20Data/#stack-and-queue","title":"Stack and Queue","text":"<p>Continuing with container-like data structures in the STL, let\u2019s talk about stacks and queues\u2014two foundational tools that help structure the way we handle data.</p> <p>These structures differ from arrays, vectors, or linked lists in one key way: you don\u2019t control where data goes\u2014you only interact with the ends, based on the specific rules of the structure.</p> <p>A stack operates on a Last In, First Out (LIFO) principle. That means the last element you push in is the first one that comes out. You can think of it like stacking plates\u2014if you want the one at the bottom, you\u2019ll have to take the top ones off first.</p> <p>Stacks do not allow random access or iteration\u2014you can only interact with the top element.</p> <p>Common operations include:</p> Operation Description <code>push()</code> Adds an element to the top <code>pop()</code> Removes the top element <code>top()</code> Returns a reference to the top element <code>empty()</code> Checks if the stack is empty <code>size()</code> Returns the number of elements <p>To use a stack in C++, just include the <code>&lt;stack&gt;</code> header.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nint main() {\n    std::stack&lt;int&gt; stack;\n    stack.push(10);\n    stack.push(20);\n    stack.push(30);\n\n    std::cout &lt;&lt; \"Top element: \" &lt;&lt; stack.top() &lt;&lt; std::endl;\n    stack.pop();\n    std::cout &lt;&lt; \"New top element: \" &lt;&lt; stack.top() &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Top element: 30\nNew top element: 20\n</code></pre> <p>A queue works the opposite way: it follows a First In, First Out (FIFO) rule. That means the first element you insert is the first to be removed\u2014just like people lining up at a ticket counter.</p> <p>A queue gives you access to the front and back elements only\u2014there\u2019s no way to randomly access or iterate through its contents directly.</p> <p>Common operations include:</p> Operation Description <code>push()</code> Adds an element to the back <code>pop()</code> Removes the front element <code>front()</code> Returns a reference to the front element <code>back()</code> Returns a reference to the last element <code>empty()</code> Checks if the queue is empty <code>size()</code> Returns the number of elements <p>To use a queue in C++, include the <code>&lt;queue&gt;</code> header:</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n\nint main() {\n    std::queue&lt;int&gt; queue;\n    queue.push(1);\n    queue.push(2);\n    queue.push(3);\n\n    std::cout &lt;&lt; \"Front element: \" &lt;&lt; queue.front() &lt;&lt; std::endl;\n    queue.pop();\n    std::cout &lt;&lt; \"New front element: \" &lt;&lt; queue.front() &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Front element: 1\nNew front element: 2\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#iterators","title":"Iterators","text":"<p>Now that we\u2019ve covered several STL containers, it's time to explore a powerful mechanism that underpins how we work with these collections: iterators.</p> <p>At a high level, iterators in C++ behave much like pointers\u2014they allow us to step through a container, one element at a time. This makes them useful not only for traversal, but also for performing operations like insertion, deletion, or modification during iteration.</p> <p>All standard C++ containers\u2014such as <code>std::array</code>, <code>std::vector</code>, <code>std::list</code>, and <code>std::map</code>\u2014are designed to support iteration. Some, like <code>std::array</code> and <code>std::vector</code>, store their elements in contiguous memory, so you can often get by using index-based access. But others, like <code>std::list</code>, <code>std::set</code>, or <code>std::map</code>/<code>std::unordered_map</code>, don't support random indexing at all. For these, iterators are essential.</p> <p>That\u2019s why each STL container comes with built-in iterator support. Iterators are objects that act like generalized pointers. You can dereference them to access a value, increment them to move to the next element, and use them to drive algorithms that operate over sequences of data.</p> <p>They\u2019re especially valuable when working with containers that lack direct index access or when you need fine-grained control over iteration. Some examples where iterators really shine:</p> <ul> <li>Removing elements while iterating through a container.</li> <li>Inserting new elements during traversal.</li> <li>Working with containers like std::set or std::map that don't support operator[].</li> <li>Writing generic code that works with any iterable container.</li> </ul> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nint main() {\n    std::list&lt;int&gt; list = {58, 6, 91, 27, 44};\n\n    /*\n        This won\u2019t work because `std::list` doesn\u2019t\n        support the regular indexing operator `[]`\n\n        for (int i = 0; i &lt; list.size(); ++i)\n            std::cout &lt;&lt; list[i] &lt;&lt; '\\t';\n    */\n\n    for (std::list&lt;int&gt;::iterator it = list.begin(); it != list.end(); ++it)\n        std::cout &lt;&lt; *it &lt;&lt; '\\t';\n\n    /*\n        This is exactly where `auto` shines,\n        replacing the clunky long iterator type\n        without risk of losing clarity:\n\n        for (auto it = list.begin(); it != list.end(); ++it)\n            std::cout &lt;&lt; *it &lt;&lt; '\\t';\n    */\n}\n</code></pre> output<pre><code>58  6   91  27  44\n</code></pre> <p>As shown in the example, an iterator is essentially a pointer to an element within a data structure. That\u2019s why we can use pointer-like operations on iterators, such as increment operator to move to the next element.</p> Method What it points to Purpose / Notes <code>.begin()</code> The first element of the container Marks the start of iteration <code>.end()</code> One past the last element (not valid) Acts as a sentinel to mark the end; used to indicate \u201cnot found\u201d in functions like <code>find()</code> <p>This iterator-based approach works consistently across all STL containers.</p>"},{"location":"07%20Collections%20of%20Data/#range-based-for-loops","title":"Range-Based For Loops","text":"<p>Since every STL container provides iterators via its <code>.begin()</code> and <code>.end()</code> methods, we can use those iterators directly for traversal and modification.</p> <p>However, writing explicit iterator loops can be verbose and less readable. This is where range-based for loops come in \u2014 they provide a cleaner, more concise syntax for iterating over any iterable container.</p> <p>Under the hood, the range-based for loop uses the container\u2019s iterators automatically. You don\u2019t need to write the iterator variables or increment expressions yourself. This makes the code easier to write and read, while still leveraging the power of iterators.</p> <p>Any container that implements <code>.begin()</code> and <code>.end()</code> \u2014 including common STL containers like <code>std::array</code>, <code>std::vector</code>, <code>std::list</code>, <code>std::map</code>, and others \u2014 can be used directly in a range-based for loop.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nint main() {\n    std::array&lt;int, 5&gt; array = {73, 12, 89, 47, 31};\n\n    for (int element : array)\n        std::cout &lt;&lt; element &lt;&lt; '\\t';\n\n    /*\n        It's better to use `auto` for long or complex types.\n        Also, if you're only reading the data, use a `const` reference\n        to avoid unnecessary copies and save resources.\n\n        for (const auto&amp; element : array)\n            std::cout &lt;&lt; element &lt;&lt; '\\t';\n    */\n}\n</code></pre> output<pre><code>73  12  89  47  31\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#chapter-summary","title":"Chapter Summary","text":"<p>In this lecture, we explored various data structures in C++, each designed to solve different types of problems efficiently. From C-style arrays and strings to more advanced structures like linked lists, hash maps, stacks, and queues, we covered their properties, use cases, and optimal usage.</p> <p>Key takeaways from this lecture: - Choosing the Right Data Structure: Each structure has its advantages, arrays offer cache efficiency, linked lists provide efficient insertions/deletions, and hash maps enable fast lookups. Understanding when to use each one is critical. - Memory Considerations: Static vs. dynamic allocation plays a big role in performance. Data locality, heap allocations, and iterator stability should always be factored into design decisions. - Iterators &amp; Range-Based Loops: Modern C++ provides efficient ways to traverse collections while maintaining readability and performance. - Algorithmic Efficiency: Many operations have trade-offs (e.g., <code>std::vector</code> vs. <code>std::list</code> for insertions). Profiling and testing are necessary to make the right decision.</p> <p>Data structures form the foundation of efficient programming. Mastering their behavior and choosing the right one for the task can drastically improve performance and maintainability. Always consider time complexity, memory overhead, and real-world constraints when working with them.</p>"},{"location":"08%20User%20Defined%20Types/","title":"08 User Defined Types","text":"<p>In the previous chapter, we explored how to organize data using C-style arrays, strings and STL containers. These are great when you\u2019re working with a list of similar things\u2014like numbers, coordinates, or game items. But they only work when all the elements are of the same type.</p> <p>In real-world programs, you often need to combine different kinds of values into one thing. Think of a game character: you might need to track their name, score, and health\u2014all of which are different types of data. Handling each one separately quickly becomes awkward and error-prone.</p> <p>That\u2019s why programming languages like C++ let us create our own complex data types\u2014custom structures that bundle different kinds of information together under a single name. Instead of juggling multiple variables for one concept, you can wrap them into a single, unified object that better reflects what you\u2019re actually working with.</p> <p>In this chapter, we\u2019ll explore how to build and use these custom structures to keep your programs clean, organized, and scalable. We\u2019ll start with the simplest and most practical form: grouping variables into one meaningful unit.</p>"},{"location":"08%20User%20Defined%20Types/#structs","title":"Structs","text":"<p>A struct lets you group related data under a single name. Its members can be of different types, and you access them using the dot operator. Structs are great for organizing simple, related pieces of information\u2014like integers, floating-point numbers, or strings\u2014into a single unit. Like arrays, the members of a struct are stored in contiguous memory. If you remember why this matters, it\u2019s the reason we can perform type punning with structs.</p> <p>When a struct contains only simple data types without extra behavior, it\u2019s often called a Plain Old Data (POD) type.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Player {\n    std::string username;\n    unsigned int score;\n    double health;\n};\n\nint main() {\n    Player player;\n    player.username = \"Unknown\";\n    player.score = 45.0;\n\n    std::cout &lt;&lt; \"Player username: \" &lt;&lt;  player.username &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Player username: Unknown\n</code></pre> <p>In this example, the <code>struct</code> name <code>Player</code> defines a custom data type, allowing us to create variables of that type.</p> <p>Notice that the <code>struct</code> like other structure we will be covering is defined outside the main function, which gives it global scope. This isn\u2019t strictly necessary\u2014if you only need to use it within a single function or other scope, you can define it there. However, in most cases, the entire translation unit needs access to it, so defining it globally is the usual approach.</p> <p>Also, the <code>struct</code> definition must end with a semicolon, forgetting this will cause a compilation error.</p> <p>Beyond just holding data, a struct can also include functions that can manipulate that data. These are called member functions or methods, and they can operate on the struct\u2019s members because they\u2019re defined inside the structs scope.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Player {\n    std::string username;\n    unsigned int score;\n    double health;\n\n    void ReduceHealth() {\n        health -= 10;\n    }\n};\n\nint main() {\n    // Initialize all members with an initializer list\n    Player player{\"Random\", 0, 100};\n\n    player.ReduceHealth();\n\n    std::cout &lt;&lt; \"Player health: \" &lt;&lt; player.health &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Player health: 90\n</code></pre> <p>Note</p> <p>Adding methods to structs is a feature unique to C++. This is important to note because structs originate from C, where attaching methods is not possible.</p> <p>We can also initialize all member variables at once using curly braces with values \u2014 this is known as aggregate initialization. However, the values must be provided in the same order as the member variables are declared in the <code>struct</code>, since they are assigned from top to bottom.</p> <p>C++ again offers a clearer alternative called designated initializers, where you explicitly specify which value corresponds to each member by name. This improves readability, especially when the <code>struct</code> definition is far from its usage or when dealing with many members.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Player {\n    std::string username;\n    unsigned int score;\n    double health;\n\n    void ReduceHealth() {\n        health -= 10;\n    }\n};\n\nint main() {\n    // Designated initializers\n    Player player{\n        .username = \"Random\",\n        .score = 0,\n        .health = 100\n    };\n\n    player.ReduceHealth();\n\n    std::cout &lt;&lt; \"Player health: \" &lt;&lt; player.health &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Player health: 90\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#unions","title":"Unions","text":"<p>A <code>union</code> is similar to a <code>struct</code> in that it groups related variables under a single name. However, unlike a <code>struct</code>, a <code>union</code> shares the same memory space among all its members. This means a <code>union</code> can only store one value at a time, and its total size is determined by the largest member it contains.</p> <p>For example, if a union holds four <code>float</code> members named <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code>, it will only occupy the size of one float\u20144 bytes\u2014instead of the combined size of all four, which would total 16 bytes. Since all members share the same memory location, changing one member will affect the others.</p> <p>Unions are useful for type punning, which means interpreting the same chunk of memory in different ways. They also enable aliasing, where the same data can be accessed under different names. For instance, a <code>union</code> might let you treat a 3D vector (x, y, z) as an RGB color (r, g, b) without duplicating memory.</p> <p>Also unions can be declared on their own or embedded anonymously inside other structures for convenience. Unlike structs, unions do not support member functions, except for constructors and destructors.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nunion Vector3 {\n    struct {\n        double x;\n        double y;\n        double z;\n    };\n\n    struct {\n        double r;\n        double g;\n        double b;\n    };\n};\n\nint main() {\n    Vector3 vec3{14.3, 22.78, 237.4};\n\n    // Accessed as coordinates\n    std::cout &lt;&lt; \" x: \" &lt;&lt; vec3.x;\n    std::cout &lt;&lt; \" y: \" &lt;&lt; vec3.y;\n    std::cout &lt;&lt; \" z: \" &lt;&lt; vec3.z &lt;&lt; std::endl;\n\n    // Accessed as color components\n    std::cout &lt;&lt; \" r: \" &lt;&lt; vec3.r;\n    std::cout &lt;&lt; \" g: \" &lt;&lt; vec3.g;\n    std::cout &lt;&lt; \" b: \" &lt;&lt; vec3.b &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code> x: 14.3 y: 22.78 z: 237.4\n r: 14.3 g: 22.78 b: 237.4\n</code></pre> <p>In this example, we define a union called <code>Vector3</code> that allows accessing its data in two different ways:</p> <ul> <li>As coordinates (x, y, z) when used as a 3D vector.</li> <li>As color components (r, g, b) when used in a color palette.</li> </ul> <p>Notice that these variables are grouped inside anonymous structs within the union. Without the structs, the union would only allow one active variable at a time, so you couldn\u2019t store all three values simultaneously.</p> <p>Anonymous structs act like regular structs but inherit their member names directly into the union. This lets us write <code>vec3.x</code> instead of something longer like <code>vec3.color.r</code>, keeping the code clean.</p>"},{"location":"08%20User%20Defined%20Types/#enums","title":"Enums","text":"<p>Enums, short for enumerations, allow us to define a set of named constants that are represented by integer values. They\u2019re useful for giving meaningful names to integer values, making the code easier to read and less prone to errors.</p> <p>One big advantage of enums is that they limit the possible values a variable can hold. Instead of using plain integers to represent different states, enums ensure only predefined values are allowed.</p> <p>For example, say we want to represent different screen states in a program, like a Start Screen and an End Screen. Without enums, we might use integers like <code>1</code> for the start screen and <code>2</code> for the end screen\u2014but this can cause bugs if invalid numbers are used accidentally. Enums prevent that by defining a fixed set of allowed values.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nenum Screen {\n    StartScreen,\n    EndScreen\n};\n\nint main() {\n    Screen screen = StartScreen;\n\n    std::cout &lt;&lt; \"Screen state: \" &lt;&lt; screen &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Enum byte size: \" &lt;&lt; sizeof(screen) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Screen state: 0\nEnum byte size: 4\n</code></pre> <p>In this example, the enum members start at <code>0</code>, which is the default behavior in C++, and each subsequent member increases by <code>1</code>. However, you can specify a custom starting value, and any subsequent members without an explicit value will continue incrementing from the last assigned number. This continues until another manually assigned value appears, which resets the counting from that new number.</p> <p>By default, an enum uses int (typically 4 bytes) as the underlying type to store its values. But if that's more memory than necessary, you can choose a smaller integer type by using a colon after the enum name, followed by the type you want.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nenum Screen : char {\n    StartScreen = 1,\n    EndScreen,       // Becomes 2\n    SomeScreen = 10,\n    AnotherScreen    // Becomes 11\n};\n\nint main() {\n    Screen screen = AnotherScreen;\n\n    std::cout &lt;&lt; \"Screen state: \" &lt;&lt; static_cast&lt;int&gt;(screen) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Enum byte size: \" &lt;&lt; sizeof(screen) &lt;&lt; \" byte\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Screen state: 11\nEnum byte size: 1 byte\n</code></pre> <p>Warning</p> <p>C++ allows you to print regular enums and use them in arithmetic expressions because they implicitly convert to integers.</p> <p>But this doesn't apply to all enums. If you use <code>enum class</code> (scoped enum), or if you manually specify an underlying type (like <code>char</code>, <code>short</code>, or <code>unsigned int</code>), you lose automatic conversion in many contexts \u2014 especially with <code>enum class</code>.</p> <p>This means you'll need to explicitly cast the value to an integer type before printing it or doing math with it.</p> <p>As you\u2019ve seen, regular enums in C++ are a handy way to assign names to integer or other numeric values. They make code easier to read and help avoid using magic numbers \u2014 literal numbers in code without clear meaning.</p> <p>But traditional enums have some downsides that become more noticeable as your code grows in size and complexity. One of the main issues is that all the <code>enum</code> values share the same global scope, which can easily lead to naming conflicts. Also, regular enums implicitly convert to integers, which can result in unexpected behavior if you're not careful. To address these problems, C++ introduced scoped enums using <code>enum class</code>.</p> <p>Scoped enums behave more strictly \u2014 and that's a good thing. Here's what makes them different:</p> <ul> <li>No global clutter: Enum members no longer leak into the global scope.</li> <li>Type safety: You can\u2019t accidentally treat them like integers without a cast.</li> <li>Explicit usage: You must qualify enum members with their enum name, which makes the code easier to follow.</li> </ul> main.cpp<pre><code>#include &lt;iostream&gt;\n\n\n/*\n    This approach cluters global scope\n\n    enum GameState {\n        Start,\n        Playing,\n        End\n    };\n*/\n\nenum class MenuOption : char {\n    Start = 1,\n    Settings,\n    Exit = 10,\n    Credits\n};\n\nint main() {\n    /*\n        OK \u2014 enum members are globally visible\n\n        GameState game = Start;\n    */\n\n    // Must use the prefix\n    MenuOption menu = MenuOption::Settings; \n\n    /*\n        OK \u2014 Implicit conversion works\n\n        std::cout &lt;&lt; \"GameState (Start) as int: \" &lt;&lt; game &lt;&lt; std::endl;\n    */\n\n    // Must cast \u2014 scoped enums don't convert automatically\n    std::cout &lt;&lt; \"Screen state: \" &lt;&lt; static_cast&lt;int&gt;(menu) &lt;&lt; std::endl;\n\n    // std::cout &lt;&lt; \"Size of GameState: \" &lt;&lt; sizeof(game) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Enum byte size: \" &lt;&lt; sizeof(menu) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Screen state: 2\nEnum byte size: 1\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#classes","title":"Classes","text":"<p>By now, we've looked at different ways to group related pieces of data \u2014 using structs, unions, and even basic enums. These approaches all come from the C side of things. While they don't behave identically in C++, they still follow the same procedural mindset.</p> <p>But as your programs begin to model real-world entities \u2014 for instance, in medical software where you might represent a patient, track their medical history, and perform operations like scheduling appointments or updating test results \u2014 a more powerful abstraction becomes useful. That\u2019s where classes come in.</p> <p>This isn\u2019t to say that classes are mandatory. Many developers stick with procedural programming, which avoids classes and sticks to functions and data structures. It's perfectly valid and often simpler for smaller or tightly focused programs.</p> <p>However, another widely used approach is Object-Oriented Programming (OOP) \u2014 and classes are at the heart of it.</p> <p>A class is a blueprint for building objects that combine data and behavior. Classes form the foundation of OOP, a style of programming that models things as self-contained units called objects. Each object holds both state (data) and functionality (methods).</p> <p>Unlike Java or C#, C++ doesn\u2019t force you into OOP. It leaves the choice to you. But when your project calls for organizing logic around real-world concepts, classes give you the right tools.</p> <p>Just like a struct, a class lets you group related member variables under a single name. But with classes, you also get access control, encapsulation, and structured member functions \u2014 also known as methods \u2014 that act on the internal state of the object.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Patient {\npublic:\n    std::string name;\n    int age;\n\n    void PrintInfo() {\n        std::cout &lt;&lt; \"Patient: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Patient patient;\n    patient.name = \"Unknown Patient\";\n    patient.age = 42;\n\n    patient.PrintInfo();\n}\n</code></pre> output<pre><code>Patient: Unknown Patient, Age: 42\n</code></pre> <p>With the class implementation, we can see some key differences compared to structs. The most notable one is access control, made possible through access specifiers. In C++, classes support three kinds of access.</p> Access Specifier Description <code>public</code> Members can be accessed from anywhere in the program. <code>private</code> Members can only be accessed from within the class. This is the default access level in classes. They cannot be accessed directly from outside the class, but can be accessed indirectly through public methods. <code>protected</code> Like <code>private</code>, but members are also accessible by derived classes (i.e., subclasses in inheritance). <p>Note</p> <p>In C++, the only difference between a <code>struct</code> and a <code>class</code> is their default access level: members of a <code>struct</code> are public by default, while members of a <code>class</code> are private by default.</p> <p>In C, <code>structs</code> cannot contain methods, but in C++, they can. However, it\u2019s generally best to use structs for simple data grouping\u2014types that hold multiple variables without associated functionality\u2014to keep design intentions clear and maintain a clean separation between plain data and more complex behavior.</p> <p>In the example above, the <code>name</code> and <code>age</code> members were declared as public, which allows us to set and access them directly in <code>main()</code> using the dot operator. If they had been marked private, we wouldn\u2019t be able to access them directly from outside the class. Instead, we\u2019d need to use getter and setter methods (or another kind of public interface) to interact with those values \u2014 something we\u2019ll cover a bit later.</p> <p>Another common convention is to prefix private member variables with <code>m_</code> or suffix them with <code>_</code> (e.g., <code>m_name</code> or <code>age_</code>). Here, we\u2019ll use the underscore suffix style as it tends to be cleaner and easier to read. This naming convention helps clearly distinguish member variables from local variables or function parameters, especially in larger codebases. It also improves readability, reduces naming conflicts, and eliminates the need to use the this pointer explicitly in most cases \u2014 something we\u2019ll explore a bit later as well.</p>"},{"location":"08%20User%20Defined%20Types/#static-inside-class","title":"Static Inside Class","text":"<p>So far, we\u2019ve seen how classes let each object maintain its own set of member variables with data unique to that particular object, created from the blueprint of a class like <code>Patient</code>. But sometimes, you want a variable or function to belong to the class itself, rather than to any single object.</p> <p>This can be achived by placing <code>static</code> keyword before a member variable or method\u2019s data type, you make it shared across all instances of the class. Instead of belonging to one object, the member belongs to the class as a whole.</p> <p>For example, a static variable can count how many objects have been created \u2014 like tracking how many patients have been registered. This shared state is useful for managing common data or resources that all objects of the class need to access.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Counter {\npublic:\n    static int value;\n\n    static void Increment() {\n        ++value;\n    }\n};\n\n// Static variables have to be defined outside the class\nint Counter::value = 0;\n\nint main() {\n    Counter::Increment();\n    Counter::Increment();\n\n    std::cout &lt;&lt; \"Counter value: \" &lt;&lt; Counter::value &lt;&lt; std::endl;\n\n    /*\n        You can also access static members\n        via an object (though it's not preferred)\n    */\n    Counter c;\n    c.Increment();\n\n    std::cout &lt;&lt; \"Counter value after object call: \" &lt;&lt; c.value &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Counter value: 2\nCounter value after object call: 3\n</code></pre> <p>We can see that the <code>value</code> is shared across all instances of the class. However, since it's a static member, it must be defined outside the class\u2014this step is required to allocate memory for it. If you forget to do this, you'll get a linker error.</p>"},{"location":"08%20User%20Defined%20Types/#static-outside-class","title":"Static Outside Class","text":"<p>The <code>static</code> keyword in C++ has two distinct meanings depending on where it's used. One use, as we saw in the previous section, is inside a class\u2014where it makes a member variable or method shared across all instances. But <code>static</code> can also be used outside of a class, and in that context, it means something different.</p> <p>When applied at file scope, <code>static</code> makes a variable or function local to the current translation unit\u2014in other words, visible only within the file in which it's declared. This limits external access, prevents unintended usage from other files, and helps avoid name conflicts across a project.</p> <p>If a variable is declared as <code>static</code> at the top level of a file (not inside any function or class), it exists for the lifetime of the program but remains completely invisible to other source files. This allows the same variable name to safely exist in multiple translation units without clashing.</p> static.cpp<pre><code>int value = 20;\n</code></pre> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint value = 10;\n\nint main() {\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>error: one or more multiply defined symbols found\n</code></pre> <p>If we declare a global variable like <code>value</code> in <code>static.cpp</code> and then declare another global <code>value</code> in <code>main.cpp</code>, the compiler produces a linker error due to multiple definitions of the same symbol. Global variables without the static keyword have external linkage by default, meaning their names are visible across translation units. That\u2019s what causes the conflict here.</p> <p>To avoid this problem, we can mark the variable in <code>main.cpp</code> as <code>static</code>. This limits its visibility to just that file, preventing it from colliding with value in <code>static.cpp</code>.</p> static.cpp<pre><code>int value = 20;\n</code></pre> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstatic int value = 10;\n\nint main() {\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Value: 10\n</code></pre> <p>Now both files can define a variable named <code>value</code> without conflict, because <code>value</code> in <code>main.cpp</code> is local to that translation unit thanks to the <code>static</code> keyword.</p> <p>If we actually want to share the variable from <code>static.cpp</code> with <code>main.cpp</code>, we need to remove <code>static</code> and use the extern keyword to declare the variable in <code>main.cpp</code>. This way, <code>main.cpp</code> refers to the definition from <code>static.cpp</code>, and there's no redefinition.</p> static.cpp<pre><code>int value = 20;\n</code></pre> main.cpp<pre><code>#include &lt;iostream&gt;\n\nextern int value;\n\nint main() {\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Value: 20\n</code></pre> <p>By using <code>extern</code>, we give <code>main.cpp</code> access to the variable defined in another file. This is known as external linkage, and it allows multiple files to share global variables while keeping a single definition in one place.</p>"},{"location":"08%20User%20Defined%20Types/#getters-and-setters","title":"Getters and Setters","text":"<p>In general, member variables should not be exposed directly outside of a class. This encapsulation helps prevent unintended modification or misuse. Instead, we provide getter and setter functions\u2014public member functions designed specifically for reading or writing private data.</p> <p>This approach allows us to maintain control over how internal state is accessed or changed. For example, setters can enforce validation rules before assigning values, adding a layer of protection and integrity to our data.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Person {\npublic:\n    std::string GetName() const {\n        return name_;\n    }\n\n    /*\n        Example of how a controlled assignment with validation might look:\n        if the name is too long, it gets truncated before being stored.\n    */\n    void SetName(const std::string&amp; name) {\n        if (name.length() &gt; 10) {\n            name_ = name.substr(0, 9);\n        } else {\n            name_ = name;\n        }\n    }\n\nprivate:\n    std::string name_;\n};\n\nint main() {\n    Person person;\n    person.SetName(\"Random Name\");\n\n    std::cout &lt;&lt; \"Person name: \" &lt;&lt; person.GetName() &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Person name: Random Na\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#constant-member-functions","title":"Constant Member Functions","text":"<p>In the previous section, we can see a <code>const</code> qualifier behind the class method declaration. When designing a class, it\u2019s important to distinguish between member functions that modify the object\u2019s internal state and those that don\u2019t. Functions that do not change the object should be explicitly marked as <code>const</code>.</p> <p>That is because doing so allows those functions to be safely called on constant instances of your class\u2014objects that have been declared immutable and are not supposed to be changed.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Player {\npublic:\n    Player(std::string name) \n        : name_(name) {\n    }\n\n    /*\n        Notice that it is marked with const at the end.\n        This tells the compiler that calling this method won\u2019t\n        change the internal state of the object. Because of that,\n        we can safely call it even when the player object is const.\n\n        Now, if we forget to add const to a method that doesn\u2019t actually\n        modify anything, we\u2019ll run into problems\u2014because the method can\u2019t\n        be called on const objects, even though it logically should be.\n    */\n\n    std::string GetName() const {\n        return name_;\n    }\n\n    void SetName(std::string name) {\n        name_ = name;\n    }\n\nprivate:\n    std::string name_;\n};\n\nint main() {\n    const Player player(\"Alex\");\n\n    std::cout &lt;&lt; player.GetName() &lt;&lt; std::endl;\n\n    // player.SetName(\"Chris\"); Error: can't call non-const method on const object\n}\n</code></pre> output<pre><code>Alex\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#constructors","title":"Constructors","text":"<p>A constructor is a special kind of method that runs automatically when an object of a class is created. Unlike regular methods, a constructor has no return type\u2014not even void\u2014and its name must match the class exactly.</p> <p>They are typically declared public so that objects can be created from outside the class. However, this isn\u2019t always the case\u2014when inheritance is involved, constructors might be protected or private, allowing them to be called only by derived classes or within the class itself. This is often used to enforce controlled object creation or to support specific inheritance patterns, which we\u2019ll explore later.</p> <p>The primary purpose of a constructor is to initialize member variables and set up the object so it\u2019s ready to use immediately. This makes code cleaner and more expressive by reducing the need for separate assignment statements after object creation.</p> <p>Constructors also play a critical role in how C++ manages memory and resources. They are involved not only in basic initialization but also in how objects are copied or moved, which can have performance implications.</p> <p>If you don\u2019t explicitly define a constructor, compiler will automatically generate a default one\u2014a no-argument constructor that initializes the object with default values. However, these defaults may not be meaningful unless you define them yourself. By writing your own constructors, you gain control over how your objects are initialized and what their initial state is. It\u2019s also important to note that the default constructor is only implicitly generated if no other constructors are defined. If you define any constructor, such as one that takes parameters, the compiler will not automatically generate a default constructor unless you explicitly tell it to.</p> <p>Note</p> <p>In these examples, we\u2019ll use <code>struct</code> instead of <code>class</code>. As mentioned earlier, in C++, the only difference between a <code>struct</code> and a <code>class</code> is that <code>struct</code> members are public by default, whereas <code>class</code> members are private.</p> <p>Using <code>struct</code> helps us keep the examples simple and avoids cluttering the code with access modifiers, getters and setters.</p> <p>However, in real-world programs, use <code>class</code> for better clarity, encapsulation, and adherence to object-oriented design practices.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Human {\n    std::string name_;\n\n    // Explicitly declare the default constructor\n    Human() = default;\n\n    // Constructor with parameters\n    Human(std::string name) {\n        name_ = name;\n    }\n\n    std::string GetName() {\n        return name_;\n    }\n};\n\nint main() {\n    Human default_human;   // Calls default constructor\n    Human human(\"Random\"); // Calls constructor with parameter\n\n    std::cout &lt;&lt; \"Default human name: \" &lt;&lt; default_human.GetName() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Named human: \" &lt;&lt; human.GetName() &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Default human name: empty string \nNamed human: Random\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#member-initializer-list","title":"Member Initializer List","text":"<p>In addition C++ provides a efficient way to write parameterized constructors using member initializer lists. This isn\u2019t just a stylistic choice\u2014it can significantly improve performance by initializing members in place, rather than first default-initializing them and then reassigning values inside the constructor body. In other words, member initializer lists construct the members directly with the given values, similar to how <code>emplace_back</code> works with vectors by constructing objects directly where they belong.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Vector2 {\npublic:\n    float x;\n    float y;\n\n    // Custom default constructor using member initializer list\n    Vector2()\n        : x(0.0f), y(0.0f) {\n    }\n\n    // Parameterized constructor using member initializer list\n    Vector2(float x, float y)\n        : x(x), y(y) {\n    }\n};\n\nint main() {\n    Vector2 vec2(10.5f, 20.8f);\n\n    std::cout &lt;&lt; \"x: \" &lt;&lt; vec2.x &lt;&lt; \" y: \" &lt;&lt; vec2.y &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>x: 10.5 y: 20.8\n</code></pre> <p>Using a member initializer list initializes members directly with the provided values. In contrast, assigning values inside the constructor body causes members to be default-initialized first and then assigned new values, which can be less efficient\u2014especially for complex types.</p> <p>Moreover, member initializer lists are required to initialize const members, reference members, and base classes, since these cannot be assigned inside the constructor body.</p> <p>Beyond the performance benefits, member initializer lists make the constructor\u2019s intent clearer and the code more concise by eliminating unnecessary syntax. For these reasons, using member initializer lists should be preferred whenever possible.</p>"},{"location":"08%20User%20Defined%20Types/#copy-constructor","title":"Copy Constructor","text":"<p>Data copying in programming is a lot like copying a chunk of text\u2014it duplicates the contents of one instance into another. For primitive types, copying is straightforward and typically has little impact on performance. But when it comes to user-defined types or containers like <code>std::vector</code> or <code>std::map</code>, copying can involve a lot more behind the scenes.</p> <p>These complex types may hold large amounts of data or even manage resources like memory or file handles. Copying such objects isn't just a matter of duplicating values\u2014it can be expensive in terms of performance and memory usage.</p> <p>That's why it's important to understand how copying works in C++, and what mechanisms are involved\u2014especially when your types grow in complexity.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double x;\n    double y;\n};\n\nint main() {\n    Vector2 a{\n        .x = 22.33,\n        .y = 55.66\n    };\n\n    // Value of 'a' was copied into 'b'\n    Vector2 b = a;\n\n    b.x = 10;\n\n    std::cout &lt;&lt; \"Coordinate x of object a: \" &lt;&lt; a.x &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Coordinate x of object a: 22.33\n</code></pre> <p>In the example above, <code>b</code> is a copy of <code>a</code>. It holds its own separate memory, so changes to <code>b.x</code> have no effect on <code>a.x</code>. This is value-based copying, and it's the default behavior in C++ for objects that aren\u2019t using pointers.</p> <p>However, when pointers are involved, copying behaves differently. Instead of copying the data being pointed to, only the address to the data is copied. That means both variables will point to the same memory location.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double x;\n    double y;\n};\n\nint main() {\n    Vector2* a = new Vector2{\n        .x = 22.33,\n        .y = 55.66\n    };\n\n    Vector2* b = a;\n\n    b-&gt;x = 10;\n\n    std::cout &lt;&lt; a-&gt;x;\n}\n</code></pre> <p>This kind of copying is handled by a special constructor called the copy constructor. C++ compiler automatically provides one for your class if you don\u2019t explicitly define it. The default copy constructor performs a member-wise copy\u2014copying each member field from one object to another.</p> <p>If you want to customize what happens when an object is copied (for example, to deeply copy a pointer or to log when copying happens), you can define your own.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double x;\n    double y;\n\n    Vector2() = default;\n\n    Vector2(float x, float y) \n        : x(x), y(y) {\n        std::cout &lt;&lt; \"Parameterized init constructor called!\" &lt;&lt; std::endl;\n    }\n\n    // Custom copy constructor signiture\n    Vector2(const Vector2&amp; other)\n        : x(other.x), y(other.y) {\n        std::cout &lt;&lt; \"Copy constructor called!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Vector2 a(22.33, 55.66); // This line will trigger the init constructor \n\n    Vector2 b = a;           // This line will trigger our copy constructor\n\n    b.x = 10.0;\n\n    std::cout &lt;&lt; \"a.x = \" &lt;&lt; a.x &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"b.x = \" &lt;&lt; b.x &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Parameterized init constructor called!\nCopy constructor called!\na.x = 22.33\nb.x = 10\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#copy-assignment-operator","title":"Copy Assignment Operator","text":"<p>The copy assignment operator is closely related to the copy constructor, but it comes into play after an object has already been constructed.</p> <p>Whereas the copy constructor creates a new object from an existing one, the copy assignment operator replaces the contents of an already existing object with those from another.</p> <p>C++ provides a default version of this operator if you don't write your own. Like the default copy constructor, it performs a member-wise copy of each field.</p> <p>But if your type manages resources manually, or you just want to log or tweak the behavior, you can define your own.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double x;\n    double y;\n\n    Vector2() = default;\n\n    Vector2(double x, double y)\n        : x(x), y(y) {\n        std::cout &lt;&lt; \"Init constructor called!\" &lt;&lt; std::endl;\n    }\n\n    Vector2(const Vector2&amp; other)\n        : x(other.x), y(other.y) {\n        std::cout &lt;&lt; \"Copy constructor called!\" &lt;&lt; std::endl;\n    }\n\n    // Custom copy assignment operator\n    Vector2&amp; operator=(const Vector2&amp; other) {\n        std::cout &lt;&lt; \"Copy assignment operator called!\" &lt;&lt; std::endl;\n\n        /*\n            Self-assignment check\n\n            Without this check, you might accidentally overwrite\n            your own data unnecessarily\u2014or worse, in more complex types,\n            cause memory corruption.\n        */\n        if (this == &amp;other)\n            return *this;\n\n        x = other.x;\n        y = other.y;\n\n        return *this;\n    }\n};\n\nint main() {\n    Vector2 a(22.33, 55.66);\n    Vector2 b;\n\n    b = a; // This triggers the copy assignment operator\n    b.x = 10.0;\n\n    std::cout &lt;&lt; \"a.x = \" &lt;&lt; a.x &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"b.x = \" &lt;&lt; b.x &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Init constructor called!\nCopy assignment operator called!\na.x = 22.33\nb.x = 10\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#move-constructor","title":"Move Constructor","text":"<p>Info</p> <p>We\u2019ve already covered move semantics in detail in earlier chapters. Here, we focus on how to implement a move constructor for your custom types, enabling them to support move semantics properly.</p> <p>Earlier in the book, we introduced move semantics\u2014a technique where an object\u2019s resources are transferred instead of copied. Now, let's see how this idea applies when working with classes and structs, especially when you're managing resources like heap-allocated memory.</p> <p>Moving in programming is like reusing an object\u2019s existing resources instead of duplicating them. While copying creates a new version of the data, moving transfers ownership from one object to another. This is especially useful when working with large objects, heap-allocated data, or temporary values, where performance matters.</p> <p>Warning</p> <p>After moving from an object, that object remains in a valid but unspecified state. In practice, this usually means its internal pointers are null or empty, but you shouldn't make assumptions beyond that unless you reset or reassign the object yourself.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string a = \"Hello World!\";\n\n    std::string b = std::move(a);\n\n    std::cout &lt;&lt; b &lt;&lt; std::endl;\n\n    if (a.empty())\n        std::cout &lt;&lt; \"a has been moved from\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hello World!\na has been moved from\n</code></pre> <p>In this example, <code>b</code> takes over the internal resources that were originally held by <code>a</code>. After the move, <code>a</code> is left in a valid but unspecified state. While many implementations leave moved-from strings empty, the C++ standard only guarantees that the object can still be safely destroyed or assigned to. You shouldn't rely on its contents unless you explicitly assign a new value.</p> <p>This is one of the main reasons move constructors are so useful\u2014they allow efficient transfer of ownership without unnecessary copying, while keeping resource management safe. But they're not really needed in classes that don't manage resources manually, such as those that only contain primitive types or rely entirely on STL containers like <code>std::vector</code> or <code>std::string</code>.</p> <p>In those cases, the default move constructor generated by the compiler is usually sufficient, because all the member types already know how to move themselves efficiently. You only need to define a custom move constructor when your class holds raw resources\u2014like heap memory, file handles, or pointers\u2014that require careful cleanup and transfer logic.</p> <p>When your class manages raw resources\u2014like heap memory\u2014you'll often want to take control of how those resources are transferred between objects. In such cases, defining a custom move constructor lets you explicitly steal ownership and prevent expensive deep copies.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double* data;\n\n    Vector2(double x, double y) {\n        data = new double[2]{x, y};\n    }\n\n    // Move constructor signiture\n    Vector2(Vector2&amp;&amp; other) {\n        std::cout &lt;&lt; \"Move constructor called!\" &lt;&lt; std::endl;\n        data = other.data;\n        other.data = nullptr; // Mark the source as \"moved-from\"\n    }\n\n    void print() const {\n        if (data)\n            std::cout &lt;&lt; \"x: \" &lt;&lt; data[0] &lt;&lt; \" y: \" &lt;&lt; data[1] &lt;&lt; std::endl;\n        else\n            std::cout &lt;&lt; \"Vector2 is in moved-from state\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Vector2 a(22.33f, 55.66f);\n\n    Vector2 b = std::move(a);\n\n    a.print();\n    b.print();\n}\n</code></pre> output<pre><code>Move constructor called!\nVector2 is in moved-from state\nx: 22.33 y: 55.66\n</code></pre> <p>This pattern is essential whenever your class directly manages memory or other system resources. It gives you precise control over how resources are moved, helping ensure both correctness and performance.</p>"},{"location":"08%20User%20Defined%20Types/#move-assignment-operator","title":"Move Assignment Operator","text":"<p>Just like how the copy assignment operator complements the copy constructor, the move assignment operator is the companion to the move constructor.</p> <p>Where the move constructor initializes a new object by stealing resources, the move assignment operator replaces the contents of an already existing object by taking ownership of another object\u2019s resources.</p> <p>This is especially important when working with resource-owning types, like classes that manage dynamic memory or handles.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double* data;\n\n    Vector2(double x, double y) {\n        data = new double[2]{x, y};\n    }\n\n    Vector2(Vector2&amp;&amp; other) {\n        std::cout &lt;&lt; \"Move constructor called!\" &lt;&lt; std::endl;\n        data = other.data;\n        other.data = nullptr;\n    }\n\n    // Move assignment operator\n    Vector2&amp; operator=(Vector2&amp;&amp; other) {\n        std::cout &lt;&lt; \"Move assignment operator called!\" &lt;&lt; std::endl;\n\n        // Self-assignment check\n        if (this == &amp;other)\n            return *this;\n\n        // Clean up existing resource\n        delete[] data;\n\n        // Steal the resource\n        data = other.data;\n        other.data = nullptr;\n\n        return *this;\n    }\n\n    void print() const {\n        if (data)\n            std::cout &lt;&lt; \"x: \" &lt;&lt; data[0] &lt;&lt; \" y: \" &lt;&lt; data[1] &lt;&lt; std::endl;\n        else\n            std::cout &lt;&lt; \"Vector2 is in moved-from state\" &lt;&lt; std::endl;\n    }\n\n    ~Vector2() {\n        delete[] data;\n    }\n};\n\nint main() {\n    Vector2 a(11.11f, 22.22f);\n    Vector2 b(0.0f, 0.0f);\n\n    b = std::move(a); // Triggers move assignment\n\n    a.print();\n    b.print();\n}\n</code></pre> <p>Tip</p> <p>Just like with the move constructor, if your type doesn't manage raw resources manually, you probably don\u2019t need to write a custom move assignment operator. The compiler-generated one is often sufficient.</p> <p>Together, the move constructor and move assignment operator complete your class's ability to participate in move semantics safely and efficiently.</p>"},{"location":"08%20User%20Defined%20Types/#explicit-constructor","title":"Explicit\u00a0Constructor","text":"<p>By default, if a constructor takes a single argument (or a set of arguments that could be matched in a single call), C++ allows implicit conversions from those argument types to the class type. This means the compiler might automatically create an object\u2014even if you didn\u2019t explicitly write a constructor call\u2014which can sometimes lead to unintended or surprising behavior.</p> <p>To prevent this, you can use the <code>explicit</code> keyword to disable automatic conversions. This makes your code safer and more predictable, especially when conversions shouldn\u2019t happen silently.</p> <p>An explicit constructor can only be called when written directly in code. The compiler won\u2019t use it for implicit type conversions.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Point {\n    int x;\n    int y;\n\n    Point(int x, int y)\n        : x(x), y(y) {    \n    }\n};\n\nvoid PrintPoint(Point p) {\n    std::cout &lt;&lt; \"x: \" &lt;&lt; p.x &lt;&lt; \" y: \" &lt;&lt; p.y &lt;&lt; std::endl;\n}\n\nint main() {\n    /*\n        Implicit conversion: allowed because\n        the constructor is not marked explicit\n    */\n    PrintPoint({5, 10});\n}\n</code></pre> output<pre><code>x: 5 y: 10\n</code></pre> <p>In this example, the compiler automatically creates a temporary <code>Point</code> from the <code>{5, 10}</code> initializer. That\u2019s possible because the constructor accepts two <code>int</code> values, and it isn\u2019t marked <code>explicit</code>.</p> <p>However, this might not always be desirable\u2014especially if you want to avoid accidental conversions. To make construction explicit-only, mark the constructor with the <code>explicit</code> keyword.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Point {\n    int x;\n    int y;\n\n    explicit Point(int x, int y)\n        : x(x), y(y) {\n    }\n};\n\nvoid PrintPoint(Point p) {\n    std::cout &lt;&lt; \"x: \" &lt;&lt; p.x &lt;&lt; \" y: \" &lt;&lt; p.y &lt;&lt; std::endl;\n}\n\nint main() {\n    /*\n        Error! Cannot implicitly convert {5, 10} to a Point\n\n        printPoint({5, 10});\n    */\n\n    Point p(5, 10); // Explicit construction\n    PrintPoint(p);  // Passing the object explicitly\n}\n</code></pre> output<pre><code>x: 5 y: 10\n</code></pre> <p>With explicit, the compiler no longer allows the conversion from <code>{5, 10}</code> to a <code>Point</code> automatically. You must create the object yourself before passing it into the function\u2014making your intention clear and preventing accidental misuse.</p>"},{"location":"08%20User%20Defined%20Types/#rule-of-zero-and-five","title":"Rule of Zero and Five","text":"<p>In C++, the Rule of Five is an important guideline when you're working with classes that manage resources manually\u2014like dynamic memory, file handles, or network sockets. If you define any one of the following special member functions, you should usually define all five to ensure consistent, predictable behavior. This is the Rule of Five.</p> Special Member Function When You Might Need It Destructor When your class manages resources like heap memory, file handles, or network sockets that must be manually released. Copy Constructor When you need to define how your object is copied (deep vs. shallow copy). Copy Assignment Operator When your object needs proper behavior during copy assignment (e.g., <code>a = b</code>). Move Constructor When you want to efficiently transfer resources from temporaries (e.g., <code>MyClass a = std::move(b)</code>). Move Assignment Operator When your object should efficiently take over resources during assignment from an rvalue (e.g., <code>a = std::move(b)</code>). <p>However, if your class doesn't manage resources directly\u2014and instead relies only on built-in types or STL containers like <code>std::vector</code> or <code>std::string</code>\u2014then you don't need to define any of these functions yourself. This is known as the Rule of Zero: let the compiler generate the special functions for you automatically.</p>"},{"location":"08%20User%20Defined%20Types/#destructors","title":"Destructors","text":"<p>Info</p> <p>This section is fairly short, as the core concept is straightforward. However, we\u2019ll return to the topic later\u2014particularly when we cover inheritance\u2014where destructors become a bit more important.</p> <p>Similar to a constructor, a destructor is a special method, but it's called automatically when an object goes out of scope or is explicitly deleted. Its job is to clean up\u2014releasing resources the object may have acquired during its lifetime, such as dynamic memory, file handles, or network connections.</p> <p>Just like constructors, destructors have a unique syntax:</p> <ul> <li>They have no return type (not even void).</li> <li>Their name matches the class, but with a tilde <code>~</code> prefix.</li> <li>A class can have only one destructor, and it cannot take any parameters.</li> </ul> <p>Destructors are declared public in most cases, especially when objects are created on the stack or dynamically via new. However, in more advanced designs (like factories or polymorphic hierarchies), destructors may be protected or virtual. We\u2019ll explore those patterns later.</p> <p>The most common use case for a destructor is to free dynamically allocated memory or close resources.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct FileHandle {\n    FileHandle() {\n        std::cout &lt;&lt; \"File opened\" &lt;&lt; std::endl;\n    }\n\n    ~FileHandle() {\n        std::cout &lt;&lt; \"File closed\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    {\n        FileHandle file;\n        std::cout &lt;&lt; \"Working with file...\" &lt;&lt; std::endl;\n    } // file goes out of scope here \u2014 destructor is called automatically\n\n    std::cout &lt;&lt; \"Program ending\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>File opened\nWorking with file...\nFile closed\nProgram ending\n</code></pre> <p>Note</p> <p>If your class acquires resources using <code>new</code>, <code>malloc</code>, or similar raw APIs, you should always define a destructor to release them. For polymorphic classes\u2014those meant to be used via base pointers\u2014you must make the destructor virtual to ensure the correct one is called. We\u2019ll cover that in detail when we get to inheritance.</p>"},{"location":"08%20User%20Defined%20Types/#arrow-operator","title":"Arrow Operator","text":"<p>Up until now, we've been using the dot operator to access members of structs and classes. But that only works when we have a direct instance of the object.</p> <p>When we have a pointer to an object, things change. We can\u2019t use the dot operator anymore \u2014 because the pointer itself doesn\u2019t have those members. Instead, we use the arrow operator (<code>-&gt;</code>) to access them through the pointer.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Point {\n    double x;\n    double y;\n\n    void Print() const {\n        std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \" y: \" &lt;&lt; y &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Point* ptr_point = new Point{41.32, 22.87};\n\n    /*\n        This won't work because ptr_point is a pointer, not an object:\n\n        ptr_point.Print();\n    */\n\n    // But this will:\n    ptr_point-&gt;Print();\n}\n</code></pre> output<pre><code>x: 41.32 y: 22.87\n</code></pre> <p>Note</p> <p>If you're thinking, \"Wait, couldn't we just dereference the pointer and call the method like this: <code>(*ptr_point).Print()</code>?\" \u2014 you're absolutely right. However, that syntax is a bit messy to read. That\u2019s exactly why the arrow operator exists: it's just a cleaner, more readable shortcut for <code>(*pointer).member</code>.</p> <p>The arrow operator can even be used in clever low-level tricks \u2014 like calculating the byte offset of a struct member from the beginning of the structure.</p> <p>Info</p> <p>This section covers advanced memory management concepts, including how data is organized in memory and how to optimize it. This knowledge is generally not required unless you are working in performance-critical or low-level systems.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\nstruct Point {\n    double x;\n    double y;\n    double z;\n};\n\nint main() {\n    // Use the arrow operator on a null pointer to compute member offsets\n    uintptr_t offset_x = (uintptr_t)&amp;((Point*)nullptr)-&gt;x;\n    uintptr_t offset_y = (uintptr_t)&amp;((Point*)nullptr)-&gt;y;\n    uintptr_t offset_z = (uintptr_t)&amp;((Point*)nullptr)-&gt;z;\n\n    /*\n        We could technically use a regular int here, but using uintptr_t is more correct,\n        as it is specifically designed to safely store pointer values as integers.\n    */\n\n    std::cout &lt;&lt; \"Byte Offset of x: \" &lt;&lt; offset_x &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Byte Offset of y: \" &lt;&lt; offset_y &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Byte Offset of z: \" &lt;&lt; offset_z &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Byte Offset of x: 0\nByte Offset of y: 8\nByte Offset of z: 16\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#current-instance-pointer","title":"Current Instance Pointer","text":"<p>In C++, we have access to a special keyword called <code>this</code>. It is only available inside member functions, and it points to the current instance of the class or object the method is acting on. While using <code>this</code> is often optional, it becomes especially useful when there is a name clash\u2014for example, between constructor parameters and member variables.</p> main.cpp<pre><code>struct Point {\n    double x;\n    double y;\n    double z;\n\n    // This works fine: the member variables are initialized using an initializer list\n    Point(double x, double y, double z) \n        : x(x), y(y), z(z) {\n    }\n\n    /* \n        This will not work as expected:\n        The assignments just assign the parameters to themselves,\n        leaving the member variables unchanged.\n\n        Point(double x, double y, double z) {\n            x = x;\n            y = y;\n            z = z;\n        }\n    */\n};\n</code></pre> <p>To resolve this ambiguity, we can use the <code>this</code> pointer to explicitly refer to the member variables. Since <code>this</code> is a pointer, we access members using the arrow operator.</p> example<pre><code>struct Point {\n    double x;\n    double y;\n    double z;\n\n    Point(double x, double y, double z) {\n        this-&gt;x = x;\n        this-&gt;y = y;\n        this-&gt;z = z;\n    }\n};\n</code></pre> <p>Note</p> <p>Remember that in many C++ style guides\u2014like Google\u2019s or others\u2014it\u2019s common to suffix member variables with <code>_</code> (e.g., <code>name_</code>) or prefix them with <code>m_</code> (e.g., <code>m_name</code>). This naming convention helps avoid name clashes entirely and improves readability without needing to use <code>this-&gt;</code>.</p>"},{"location":"08%20User%20Defined%20Types/#friend-functions","title":"Friend Functions","text":"<p>In C++, we can grant non-member functions access to a class\u2019s private and protected members by declaring them as friend. Although these functions are not part of the class itself, they are treated as trusted and can interact with the internal state of the class directly.</p> <p>This approach is useful when a function needs to work closely with a class\u2014such as when overloading operators\u2014but doesn\u2019t logically belong as a member, helping keep responsibilities separated while still allowing close access.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Box {\nprivate:\n    double edge_length_;\n\npublic:\n    Box(double edge_length_)\n        : edge_length_(edge_length_) {\n    }\n\n    // Declare a friend function inside public access specifier\n    friend void PrintEdgeLength(const Box&amp; box);\n};\n\n// Define friend function outside the class\nvoid PrintEdgeLength(const Box&amp; box) {\n    std::cout &lt;&lt; \"Edge length: \" &lt;&lt; box.edge_length_ &lt;&lt; std::endl;\n}\n\nint main() {\n    Box box(42.5);\n    PrintEdgeLength(box);  // Can access private width directly\n}\n</code></pre> output<pre><code>Edge length: 42.5\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#inheritance","title":"Inheritance","text":"<p>In more complex programs\u2014especially games\u2014we often need to structure our code in a way that\u2019s both reusable and maintainable. Imagine you have a <code>Player</code> class and an <code>Enemy</code> class. At first glance, they may seem different, but both share several common traits: they might have a <code>name</code>, <code>hitpoints</code>, a <code>level</code>, or a <code>position</code> in the game world.</p> <p>Rather than duplicating those shared members in every class, we can extract them into a more general-purpose class\u2014say, <code>Entity</code>. Both <code>Player</code> and <code>Enemy</code> can then be built on top of <code>Entity</code>, inheriting its functionality and enriching it with their own unique behavior. This mechanism is called inheritance.</p> <p>Inheritance lets us write cleaner, more modular code. It allows us to group shared functionality in one place and extend or override it as needed in specialized types.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Entity {\nprotected:\n    std::string name_;\n    double hitpoints_;\n    unsigned int level_;\n\npublic:\n    /*\n        'name' is passed by value (copied into this constructor),\n        so to avoid copying it again into name_, we move it instead.\n\n        This technique works with all STL containers\n        like std::vector, std::map as well as std::string.\n        Just remember: after moving a variable, \n        you should not use it again unless you reassign a valid value.\n\n        In many cases this optimization isn\u2019t strictly necessary,\n        but it serves as a good example of where move semantics\u2014\n        which we introduced earlier\u2014can be applied in real code.\n    */\n    Entity(std::string name, double hitpoints, unsigned int level)\n        : name_(std::move(name)), hitpoints_(hitpoints), level_(level) {\n    }\n\n    void PrintInfo() const {\n        std::cout &lt;&lt; \"name: \" &lt;&lt; name_ &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"hitpoints: \" &lt;&lt; hitpoints_ &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"level: \" &lt;&lt; level_ &lt;&lt; std::endl;\n    }\n};\n\n\n/*\n    You will almost always want to use the public inheritance\n    access specifier. See the detailed table below for why\n    that\u2019s usually the right choice.\n*/\nstruct Player : public Entity {\n    /*\n        We're using the constructor of the parent class (Entity),\n        which is one of the main benefits of inheritance:\n        reusing shared initialization logic.\n    */\n    Player(std::string name)\n        : Entity(std::move(name), 100.0, 1) {\n    }\n\n    void Attack() {\n        std::cout &lt;&lt; name_ &lt;&lt; \" attacks with a sword!\" &lt;&lt; std::endl;\n    }\n};\n\nstruct Enemy : public Entity {\n    Enemy(std::string name, double hp, unsigned int lvl)\n        : Entity(std::move(name), hp, lvl) {\n    }\n\n    void Taunt() {\n        std::cout &lt;&lt; name_ &lt;&lt; \" growls!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Player player(\"Archer\");\n    Enemy entity(\"Goblin\", 50.0, 2);\n\n    std::cout &lt;&lt; \"Player info\" &lt;&lt; std::endl;\n    player.PrintInfo();\n    player.Attack();\n\n    std::cout &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"Enemy info\" &lt;&lt; std::endl;\n    entity.PrintInfo();\n    entity.Taunt();\n}\n</code></pre> output<pre><code>Player info\nname: Archer\nhitpoints: 100\nlevel: 1\nArcher attacks with a sword!\n\nEnemy info\nname: Goblin\nhitpoints: 50\nlevel: 2\nGoblin growls!\n</code></pre> Inheritance Type <code>public</code> Members in Base <code>protected</code> Members in Base <code>private</code> Members in Base <code>public</code> Remain <code>public</code> in derived Remain <code>protected</code> in derived Not accessible <code>protected</code> Become <code>protected</code> Remain <code>protected</code> Not accessible <code>private</code> Become <code>private</code> Become <code>private</code> Not accessible"},{"location":"08%20User%20Defined%20Types/#polymorphism","title":"Polymorphism","text":"<p>Polymorphism refers to the ability of different classes to respond to the same function call in their own way. Unlike regular function overloading (where multiple functions share a name but differ in parameters), polymorphism usually involves methods of a base class that are overridden in derived classes to provide specialized behavior.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Entity {\npublic:\n    virtual void Speak() { // Must be marked virtual\n        std::cout &lt;&lt; \"Entity speaks.\" &lt;&lt; std::endl;\n    }\n};\n\nclass Player : public Entity {\npublic:\n    void Speak() override {\n        std::cout &lt;&lt; \"Player speaks.\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Entity* entity = new Player(); // Base class pointer to derived object\n    entity-&gt;Speak();               // Calls Player::Speak() thanks to polymorphism\n\n    delete entity;\n}\n</code></pre> output<pre><code>Player speaks.\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#virtual-methods","title":"Virtual Methods","text":"<p>In the previous section, we used the virtual keyword to enable polymorphism. Let\u2019s now take a moment to focus on what virtual methods actually are.</p> <p>A virtual method is a member function that can be overridden in a derived class. When you call it through a base class pointer or reference, the version that's selected is based on the actual type of the object \u2014 not the type of the pointer or reference.</p> <p>This mechanism is called dynamic dispatch, and it only happens when you're using a base class pointer or reference and the method is marked as virtual.</p> Keyword Purpose Where it's used Notes <code>virtual</code> Marks a method as overridable in derived classes In base class declarations Enables runtime polymorphism. <code>override</code> Indicates that a method intentionally overrides a base virtual method In derived class definitions Helps catch bugs caused by mismatched method signatures. <code>final</code> Prevents a virtual method from being overridden further In derived class definitions Can also be used to seal entire classes: <code>class MyFinalClass final {}</code> <p>Tip</p> <p>Always use override when overriding virtual methods. It makes your intent clear and helps the compiler catch mistakes.</p> example<pre><code>class Entity {\npublic:\n    virtual void Speak() {\n        std::cout &lt;&lt; \"Entity speaks.\" &lt;&lt; std::endl;\n    }\n};\n\nclass Player : public Entity {\npublic:\n    void Speak() override final { // overrides and seals the method\n        std::cout &lt;&lt; \"Player speaks.\" &lt;&lt; std::endl;\n    }\n};\n\n/*\n    This would cause a compile error:\n\n    class Boss : public Player {\n        void Speak() override { ... } // Not allowed as it was marked as final\n    };\n*/\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#interfaces","title":"Interfaces","text":"<p>Now that we've seen how virtual methods work, let's talk about a special case: interfaces.</p> <p>In C++, an interface is typically just a class that contains only pure virtual functions \u2014 methods that must be implemented by any derived class. They have no body and are declared using <code>= 0</code>.</p> <p>Interfaces are especially useful for enforcing consistent behavior across many unrelated types \u2014 for example, in plugins, simulation systems, or game objects. You can build systems that interact with any class that implements the interface, without caring what kind of object it is.</p> <p>You can think of an interface as an abstract base class made up entirely of pure virtual methods. And yes \u2014 in C++, a class can inherit from multiple interfaces.</p> <p>Note</p> <p>A class that contains at least one pure virtual method becomes an abstract class, and it cannot be instantiated directly.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Updatable {\npublic:\n    virtual void Update() = 0; // Pure virtual function\n};\n\nclass Player : public Updatable {\npublic:\n    void Update() override {\n        std::cout &lt;&lt; \"Player updates.\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Player player;\n    player.Update(); // Calls Player's implementation\n}\n</code></pre> output<pre><code>Player updates.\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#singletons","title":"Singletons","text":"<p>Sometimes, we only ever want a single instance of a class to exist across an entire program. Maybe it's a logger, a configuration manager, or a global game state\u2014whatever the case, the Singleton design pattern is exactly for this pupose. Instead of letting code freely create new objects, a Singleton class controls its own instantiation and ensures only one object is ever made. The typical approach involves a static method that hands out a reference to the sole instance, creating it the first time it's needed.</p> example<pre><code>class Game {\nprivate:\n    Game() {\n    }\n\npublic:\n    Game(const Game&amp;) = delete;\n    Game&amp; operator=(const Game&amp;) = delete;\n    Game(Game&amp;&amp;) = delete;\n    Game&amp; operator=(Game&amp;&amp;) = delete;\n\n    static Game&amp; Instance() {\n        static Game instance;\n        return instance;\n    }\n\n    void Run() {\n        // Game loop would go here\n    }\n};\n\nint main() {\n    Game::Instance().Run(); // Only one Game ever exists\n}\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#exercises","title":"Exercises","text":"task 1answer <pre><code>Define a `Book` struct with the following fields: `title`, `author`,\n`year`, and `price`. Then, write a function that takes a `Book`\nas a parameter and prints its contents in a human-readable format.\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Book {\n    std::string title;\n    std::string author;\n    unsigned int year;\n    double price; \n};\n\nvoid PrintBookContent(const Book&amp; book) {\n    std::cout &lt;&lt; \"Title: \" &lt;&lt; book.title &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Author: \" &lt;&lt; book.author &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Year: \" &lt;&lt; book.year &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Price: \" &lt;&lt; book.price &lt;&lt; std::endl;\n}\n\nint main() {\n    Book book{\n        .title = \"Learn CPlusPlus\",\n        .author = \"CL0001/ElGordoOfficial\",\n        .year = 2025,\n        .price = 0.0\n    };\n\n    PrintBookContent(book);\n}\n</code></pre> task 2answer <pre><code>Create a Rectangle class that stores width and height.\n\n- Provide a constructor.\n- Add getter and setter methods for both members.\n- Add a method area() that returns the area of the rectangle.\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nclass Rectangle {\npublic:\n    Rectangle(double width, double height)\n        : width_(width), height_(height) {\n    }\n\n    double GetWidth() const {\n        return width_;\n    }\n\n    double GetHeight() const {\n        return height_;\n    }\n\n    void SetWidth(double width) {\n        width_ = width;\n    }\n\n    void SetHeight(double height) {\n        height_ = height;\n    }\n\n    double CalculateArea() const {\n        return width_ * height_;\n    }\n\nprivate:\n    double width_;\n    double height_;\n};\n\nint main() {\n    Rectangle rectangle(10.32, 20.85);\n\n    rectangle.SetWidth(10.0);\n    rectangle.SetHeight(20.0);\n\n    std::cout &lt;&lt; \"Rectangle area: \" &lt;&lt; rectangle.CalculateArea() &lt;&lt; std::endl;\n}\n</code></pre> task 3answer <pre><code>Define a class Logger that writes custom user defined messages\ninto terminal when:\n\n- An object is constructed\n- An object is destructed\n\nCreate several `Logger` instances inside a `CreateLoggers` function\nand observe the output order.\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Logger {\npublic:\n    Logger(const std::string&amp; name)\n        : name_(name) {\n        std::cout &lt;&lt; \"Logger \" &lt;&lt; name_ &lt;&lt; \" constructed.\" &lt;&lt; std::endl;\n    }\n\n    ~Logger() {\n        std::cout &lt;&lt; \"Logger \" &lt;&lt; name_ &lt;&lt; \" destructed.\" &lt;&lt; std::endl;\n    }\n\nprivate:\n    std::string name_;\n};\n\nvoid CreateLoggers() {\n    Logger log1(\"First\");\n    Logger log2(\"Second\");\n    Logger log3(\"Third\");\n    std::cout &lt;&lt; \"Exiting CreateLoggers function...\" &lt;&lt; std::endl;\n}\n\nint main() {\n    CreateLoggers();\n    std::cout &lt;&lt; \"Back in main.\" &lt;&lt; std::endl;\n}\n</code></pre> <p>More to come ...</p>"},{"location":"09%20Error%20Handling/","title":"09 Error Handling","text":"<p>\ud83d\udea7 This chapter is under construction... \ud83d\udea7</p>"},{"location":"10%20Macros/","title":"10 Macros","text":"<p>\ud83d\udea7 This chapter is under construction... \ud83d\udea7</p>"},{"location":"11%20Templates%20and%20Metaprogramming/","title":"11 Templates and Metaprogramming","text":"<p>\ud83d\udea7 This chapter is under construction... \ud83d\udea7</p>"},{"location":"12%20Standard%20Template%20Library/","title":"12 Standard Template Library","text":"<p>\ud83d\udea7 This chapter is under construction... \ud83d\udea7</p>"},{"location":"13%20Build%20Systems%20and%20CMake/","title":"13 Build Systems with CMake","text":"<p>At this point, we want to build more than just command-line tools and utilities. Those were a necessary starting point\u2014but now it's time to scale up. As C++ isn\u2019t just used for small scripts; it\u2019s the backbone of massive systems, game engines, and high-performance cross-platform applications. And since these kinds of projects are often meant to run on more than one platform, we\u2019ll need a cross-platform build system to streamline the entire development and deployment process.</p> <p>That\u2019s not to say platform-specific tools don\u2019t exist\u2014they absolutely do. Each major IDE comes bundled with its own build system, and so far we\u2019ve relied on tools like Microsoft Visual Studio or Apple\u2019s Xcode, both of which handle that part for us. These are powerful environments, but they lock you into their ecosystems, making it difficult to move between platforms or collaborate with developers using different setups. And learning a different build system for every environment just isn\u2019t practical. It\u2019s far more efficient to master one flexible, portable tool that works everywhere. That\u2019s why cross-platform build systems are essential.</p> <p>This build system we've been mentioning automates the process of compiling, linking, and packaging our code. It manages file dependencies, handles platform-specific quirks, and generates all the necessary build files for our compiler or IDE. And when that build system is cross-platform, it means you can define our build logic once and have it work on Windows, macOS, or Linux without needing to rewrite anything.</p> <p>Also a build system becomes especially important when you're using third-party libraries, switching between compilers, or integrating tools like formatters, linters, and static analyzers.</p> <p>Fortunately, there are several solid options to choose from\u2014but only one is widely recognized as the industry standard and best suited for beginners: CMake. It\u2019s the most complete and flexible solution available, and it's already used by countless libraries and projects across the C++ ecosystem. Other notable examples include Bazel, developed by Google with a focus on speed and scalability, and Premake, which uses a Lua-based syntax and aims for readability and simplicity.</p> <p>So in this chapter, we\u2019ll focus on CMake: how it works, and how to use it in our projects.</p>"},{"location":"13%20Build%20Systems%20and%20CMake/#getting-started","title":"Getting Started","text":"<p>CMake is a standalone build system, which means it needs to be installed separately. Fortunately, installation is straightforward on all major platforms and can be done in a few simple steps.</p> <p>The easiest way is through the official CMake website: https://cmake.org/download/.</p> <p>Scroll down to the Binary Distributions section, choose the latest version available, and download the installer that matches our operating system and system architecture. Then just run the installer and follow the default steps\u2014it\u2019s a simple next-next-finish process on most platforms.</p> <p>Alternatively, we can install CMake through a package manager available on our platform, such as winget, Homebrew, or Chocolatey. This can be an even quicker option if you\u2019re already comfortable with the terminal, but either method will get you to the same result.</p>"},{"location":"13%20Build%20Systems%20and%20CMake/#cmake-basics","title":"CMake Basics","text":"<p>The first thing to understand is that CMake has its own scripting language, and it expects build scripts to be placed in files named <code>CMakeLists.txt</code>\u2014this is the specific filename CMake looks for when configuring a project. There\u2019s no limit to how many of these files a project can contain\u2014each subdirectory can have its own\u2014but just like in C++, there needs to be a clear entry point. For CMake, that entry point is the root <code>CMakeLists.txt</code> file located at the top level of our project. This is where the build configuration begins.</p> <p>It's also highly recommended to use a dedicated <code>build/</code> or <code>out/</code> directory. This is where CMake generates all the necessary build files, tailored specifically to our platform and compiler. Keeping these generated files separate helps maintain a clean project structure, free from clutter.</p> <p>The contents of this directory will vary depending on our system, compiler, and build tools, but that\u2019s exactly where CMake\u2019s power comes through. We only need to write a single <code>CMakeLists.txt</code> file, and CMake takes care of generating the appropriate build files for whatever environment we\u2019re targeting.</p> <p>This approach not only keeps our source code tidy but also makes it easier to manage multiple builds\u2014such as Debug and Release\u2014simultaneously by using separate build directories for each configuration.</p> <pre><code>cmake-example-project/\n\u251c\u2500\u2500 build/\n\u251c\u2500\u2500 include/\n\u2502   \u2514\u2500\u2500 calc.h\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 calc.cpp\n\u2502   \u2514\u2500\u2500 main.cpp\n\u2514\u2500\u2500 CMakeLists.txt\n</code></pre> calc.h<pre><code>#pragma once\n\nint Sum(int arr[], int size);\n</code></pre> calc.cpp<pre><code>#include \"calc.h\"\n\nint Sum(int arr[], int size) {\n    int sum = 0;\n\n    if (size &lt;= 0)\n        return 0;\n\n    for (int i = 0; i &lt; size; ++i)\n        sum += arr[i];\n\n    return sum;\n}\n</code></pre> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#include \"calc.h\"\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    std::cout &lt;&lt; \"Sum of array: \" &lt;&lt; Sum(arr, 5) &lt;&lt; std::endl;\n}\n</code></pre> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15...4.0)\n\nproject(\n    CMakeExampleProject\n    VERSION 0.1.0\n    DESCRIPTION \"A simple CMake project\"\n    LANGUAGES CXX\n)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nset(\n    SOURCES\n    include/calc.h src/calc.cpp\n    src/main.cpp\n)\n\nadd_executable(${PROJECT_NAME} ${SOURCES})\n\ntarget_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/include)\n</code></pre> output<pre><code>Sum of array: 15\n</code></pre> <p>Note</p> <p>CMake functions are case-insensitive, so you can write them as <code>SET()</code> or <code>set()</code>. However, the convention is to use snake_case, like <code>set()</code> or <code>add_executable()</code>.</p> <p>Info</p> <p>For versioning, it\u2019s best to follow a consistent versioning system such as Semantic Versioning. This approach uses a <code>MAJOR.MINOR.PATCH</code> format to clearly communicate the scope of changes:</p> <ul> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backwards-compatible manner</li> <li>PATCH version for backwards-compatible bug fixes</li> </ul> <p>Adopting semantic versioning helps maintain clarity and predictability as your project evolves.</p> <p>More info on Semantic Versioning can be found here: https://semver.org/</p> <p>Let's start by recreating the file structure shown above and placing the example code into the respective files. It is neccessary as we will build upon this example in the next few sections.</p> <ol> <li> <p><code>cmake_minimum_required()</code></p> <p>This is the first line in every root <code>CMakeLists.txt</code>. It sets the minimum required CMake version to 3.15 and supports any version up to (but not including) 4.0. The <code>...</code> syntax means \"compatible with versions from 3.15 up to 4.0.\" This range indicates the versions that were tested and should work correctly with your project.</p> </li> <li> <p><code>project()</code></p> <p>Defines the project name \"CMakeExampleProject\", version \"0.1.0\", description, and the programming languages used. CMake supports several languages including C, CXX (C++), Fortran, ASM, CUDA, CSharp, and Swift. Here we specify only CXX since it's a C++ project.</p> </li> <li> <p><code>set()</code></p> <p>Used to create or modify variables. Here, <code>CMAKE_CXX_STANDARD</code> is set to 20, which means the project uses C++20. <code>CMAKE_CXX_STANDARD_REQUIRED ON</code> means this version is mandatory \u2014 the compiler must support C++20 or higher.</p> </li> <li> <p><code>set(SOURCES ...)</code></p> <p>We define a variable named SOURCES listing all the source files and header files used in the project. Notice we also include header files even though they are not compiled directly. This is because CMake also informs IDEs and editors about which files belong to the project. Without listing headers here, tools like Visual Studio won't show them in the project explorer, or enable features like search and navigation properly.</p> </li> <li> <p><code>add_executable()</code></p> <p>This tells CMake to create an executable with the project name (<code>${PROJECT_NAME}</code> is a variable referencing the project name defined earlier) from the listed source files.</p> </li> <li> <p><code>target_include_directories()</code></p> <p>This sets the include paths for the compiler. Here, we add the include directory as a place to look for header files, so your source files can <code>#include \"log.h\"</code> without needing to write relative or absolute paths.</p> </li> </ol> <p>Generating the build files with CMake and then building the project is straightforward. First, open a terminal inside the <code>build/</code> directory\u2014or navigate to it if terminal is already open. Once there, run these two simple commands.</p> <ol> <li> <p><code>cmake ..</code></p> <p>Generates the build files in the current directory based on the CMakeLists.txt in the parent folder.</p> </li> <li> <p><code>cmake --build .</code></p> <p>Builds the project using the generated build system in the current directory.</p> </li> </ol> <p>The build executable is defaultly located inside the <code>build/Debug/</code> directory.</p>"},{"location":"13%20Build%20Systems%20and%20CMake/#creating-a-library","title":"Creating a Library","text":"<p>When a project includes larger, reusable components\u2014such as a logging system or a configuration manager\u2014that are used across multiple parts of the codebase, it's a good practice to separate them into their own modules, commonly referred to as libraries. These libraries represent code that functions as a self-contained unit and typically doesn't change often during development. By isolating them, we avoid the need to recompile everything from scratch every time we build the project\u2014saving time and improving build efficiency.</p> <p>Note</p> <p>This doesn\u2019t apply to small helper functions or quick utilities you might define in a single translation unit. A library is typically for stable, well-defined code that doesn\u2019t change often. Once finished, we rarely touch it\u2014and that means we can save time during the build process, since CMake won't recompile it every time the main program changes.</p> <p>In CMake, we can define a library using the <code>add_library()</code> command, along with a few optional tweaks to control how it's built and linked.</p> <p>let build upon the cmakelists and filestructure from the previous section and add to it a librry</p> <pre><code>cmake-example-project/\n\u251c\u2500\u2500 build/\n\u251c\u2500\u2500 include/\n\u2502   \u2514\u2500\u2500 calc.h\n\u251c\u2500\u2500 libs/\n\u2502   \u2514\u2500\u2500 logger/\n\u2502       \u251c\u2500\u2500 logger.cpp\n\u2502       \u2514\u2500\u2500 logger.h\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 calc.cpp\n\u2502   \u2514\u2500\u2500 main.cpp\n\u2514\u2500\u2500 CMakeLists.txt\n</code></pre> logger.h<pre><code>#pragma once\n\nnamespace logger {\n    void LOG(const char* message);\n    void LOG(int value);\n}\n</code></pre> logger.cpp<pre><code>#include \"logger.h\"\n\n#include &lt;iostream&gt;\n\nvoid logger::LOG(const char* message) {\n    std::cout &lt;&lt; message &lt;&lt; std::endl;\n}\n\nvoid logger::LOG(int value) {\n    std::cout &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre> main.cpp<pre><code>#include \"calc.h\"\n#include \"logger.h\"\n\nint main() {\n    logger::LOG(\"Hello, World!\");\n\n    int arr[] = {1, 2, 3, 4, 5};\n    logger::LOG(Sum(arr, 5));\n}\n</code></pre> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15...4.0)\n\nproject(\n    CMakeExampleProject\n    VERSION 0.1.0\n    DESCRIPTION \"A simple CMake project\"\n    LANGUAGES CXX\n)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nadd_library(\n    logger STATIC\n    libs/logger/logger.h\n    libs/logger/logger.cpp\n)\n\ntarget_include_directories(logger PUBLIC libs/logger)\n\nset(\n    SOURCES\n    include/calc.h src/calc.cpp\n    src/main.cpp\n)\n\nadd_executable(${PROJECT_NAME} ${SOURCES})\n\ntarget_include_directories(${PROJECT_NAME} PRIVATE include)\n\ntarget_link_libraries(${PROJECT_NAME} PRIVATE logger)\n</code></pre> output<pre><code>Hello, World!\n15\n</code></pre> <p>Note</p> <p>It's considered best practice to wrap each library in its own namespace. This helps avoid name clashes in the global namespace and makes it easier to identify which library a given function, class, or symbol comes from.</p> <p>Likewise, in larger (non-example) projects, the main project's source and header files (typically inside <code>src/</code> and <code>include/</code>) should also be wrapped inside a namespace matching the project's name.</p> <p>\ud83d\udea7 This chapter is under construction... \ud83d\udea7</p>"},{"location":"14%20Package%20Managers/","title":"14 Package Managers","text":"<p>\ud83d\udea7 This chapter is under construction... \ud83d\udea7</p>"}]}