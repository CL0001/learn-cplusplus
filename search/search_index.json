{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"About","text":"<p>Info</p> <p>This book is a living document. It will continue to evolve as I refine explanations, add examples and correct mistakes. If you notice anything confusing, incorrect or missing, please consider opening an issue on GitHub so I can improve it for everyone.</p> <p>Direct link to the issues: https://github.com/CL0001/learn-cplusplus/issues</p>"},{"location":"#why-i-wrote-this-book","title":"Why I Wrote This Book","text":"<p>I wrote this book because I always found it surprisingly difficult to find high-quality, relevant material on C++. It was the first programming language I\u2014and many others\u2014learned in school, but unfortunately, it was taught in a way that made it seem terrible.</p> <p>We were using a very old version of the language, and the teaching style leaned heavily on the old \u201cC with Classes\u201d approach\u2014the way C++ was originally introduced\u2014which almost everyone disliked. At the time, I didn\u2019t understand much and I certainly didn\u2019t learn enough to feel confident with the language; I just felt lost.</p> <p>Disappointed, I moved on to other languages with gentler learning curves and started teaching myself programming from scratch, combining what little I\u2019d learned in school with online tutorials and personal projects. Over time, I became fascinated with low-level performance programming\u2014especially game development and the idea of building my own game engines. That curiosity eventually brought me back to C++, and years later, to writing this book.</p>"},{"location":"#why-c-matters","title":"Why C++ Matters","text":"<p>Anything that demands raw performance or fine-grained control over hardware is usually a perfect fit for C++. From game engines and high-frequency trading systems to artificial intelligence, computer vision, robotics, and aerospace software\u2014C++ powers them all.</p> <p>It sits in a unique spot between low-level languages like C and high-level, more abstract ones like Python. You get the control and speed of the former, but with features that make building large, complex systems manageable. That balance is what makes C++ so enduring.</p> <p>Even after decades of evolution, C++ remains one of the most widely used languages in the world. Major engines like Unreal, browsers like Chrome, and countless operating systems and embedded systems rely on it every day. It\u2019s not just a legacy technology\u2014it\u2019s an essential one.</p> <p>And while newer languages often promise simplicity or safety, few can match the sheer versatility, maturity, and ecosystem that C++ offers. Once you learn it well, you\u2019ll find that the skills transfer naturally to almost any other language or domain.</p>"},{"location":"#what-youll-find-here","title":"What You\u2019ll Find Here","text":"<p>When I finally came back to C++, I realized it wasn\u2019t the confusing, outdated language I had remembered. Modern C++ is powerful, expressive, and\u2014surprisingly\u2014fun to use once you understand how its pieces fit together. But it took me a while to see that.</p> <p>Coming from high-level languages like Python, even simple low-level concepts felt foreign at first. I wasn\u2019t just trying to write programs\u2014I wanted to understand what was actually happening behind the scenes. That curiosity pushed me through a lot of trial and error, and even more late-night debugging sessions.</p> <p>Over time, I started to piece things together and realized that C++ didn\u2019t have to feel intimidating. It just needed to be explained in a way that made sense. That\u2019s what this book aims to do: to make C++ approachable without dumbing it down, and to guide you from the absolute basics to building a complete game from scratch\u2014no pre-built engines, no magic libraries, just real code.</p> <p>If you\u2019ve ever felt frustrated learning C++ or felt like it was \u201ctoo hard,\u201d this book is for you. My goal is that by the end, you\u2019ll not only understand how C++ works but also feel confident and maybe even a little excited about using it.</p>"},{"location":"00%20Table%20of%20Contents/","title":"00 Table of Contents","text":"<pre>\n\u251c\u2500\u2500 01 Introduction/\n\u2502   \u251c\u2500\u2500 Environment Setup/\n\u2502   \u2502   \u251c\u2500\u2500 Recommended Setup for Windows\n\u2502   \u2502   \u251c\u2500\u2500 Recommended Setup for macOS\n\u2502   \u2502   \u2514\u2500\u2500 Recommended Setup Without Installation\n\u2502   \u251c\u2500\u2500 Build Process/\n\u2502   \u2502   \u251c\u2500\u2500 Entry Point\n\u2502   \u2502   \u251c\u2500\u2500 Preprocessor Directives\n\u2502   \u2502   \u251c\u2500\u2500 Compiler\n\u2502   \u2502   \u251c\u2500\u2500 Assembler\n\u2502   \u2502   \u2514\u2500\u2500 Linker\n\u2502   \u251c\u2500\u2500 Header Files/\n\u2502   \u2502   \u251c\u2500\u2500 Header Guard\n\u2502   \u2502   \u2514\u2500\u2500 Header File Search\n\u2502   \u251c\u2500\u2500 Comments/\n\u2502   \u2502   \u2514\u2500\u2500 Comment Types\n\u2502   \u251c\u2500\u2500 Data Types and Variables/\n\u2502   \u2502   \u251c\u2500\u2500 Primitive Data Types\n\u2502   \u2502   \u251c\u2500\u2500 ASCII\n\u2502   \u2502   \u251c\u2500\u2500 Declaring and Naming Variables\n\u2502   \u2502   \u2514\u2500\u2500 Constants\n\u2502   \u251c\u2500\u2500 Console Input and Output/\n\u2502   \u2502   \u251c\u2500\u2500 Additional Output Streams\n\u2502   \u2502   \u251c\u2500\u2500 Stream Buffers\n\u2502   \u2502   \u2514\u2500\u2500 Newlines and Flushing\n\u2502   \u251c\u2500\u2500 Questions\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 02 Operators/\n\u2502   \u251c\u2500\u2500 Comparison Operators\n\u2502   \u251c\u2500\u2500 Logical Operators\n\u2502   \u251c\u2500\u2500 Arithmetic Operators/\n\u2502   \u2502   \u2514\u2500\u2500 Shortened Notations\n\u2502   \u251c\u2500\u2500 Operator Evaluation Order\n\u2502   \u251c\u2500\u2500 Bitwise Operators/\n\u2502   \u2502   \u251c\u2500\u2500 Binary Representation\n\u2502   \u2502   \u251c\u2500\u2500 Conversion Between Decimal and Binary Systems\n\u2502   \u2502   \u251c\u2500\u2500 Conversion Between Decimal and Hexadecimal Systems\n\u2502   \u2502   \u251c\u2500\u2500 Conversion Between Decimal and Octal Systems\n\u2502   \u2502   \u251c\u2500\u2500 Examining Memory Representation in Practice\n\u2502   \u2502   \u251c\u2500\u2500 Bitwise Shift Operators\n\u2502   \u2502   \u251c\u2500\u2500 Bitwise Logic Operators/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Bitwise AND\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Bitwise OR\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Bitwise XOR\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Bitwise NOT\n\u2502   \u2502   \u2514\u2500\u2500 Writing Binary, Hexadecimal and Octal Values in C++\n\u2502   \u251c\u2500\u2500 Ternary Operator\n\u2502   \u251c\u2500\u2500 Operator Overloading\n\u2502   \u251c\u2500\u2500 Questions\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 03 Control Flow/\n\u2502   \u251c\u2500\u2500 If Statements\n\u2502   \u251c\u2500\u2500 Switch Statements\n\u2502   \u251c\u2500\u2500 Go To Statements\n\u2502   \u251c\u2500\u2500 Loops/\n\u2502   \u2502   \u251c\u2500\u2500 While Loops\n\u2502   \u2502   \u251c\u2500\u2500 For Loops\n\u2502   \u2502   \u251c\u2500\u2500 Nested Loops\n\u2502   \u2502   \u2514\u2500\u2500 Break and Continue\n\u2502   \u251c\u2500\u2500 Shortened Notations\n\u2502   \u251c\u2500\u2500 Questions\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 04 Functions/\n\u2502   \u251c\u2500\u2500 Function Creation\n\u2502   \u2502   \u251c\u2500\u2500 Return Values/\n\u2502   \u2502   \u251c\u2500\u2500 Multiple Return Values/\n\u2502   \u2502   \u251c\u2500\u2500 Parameter List/\n\u2502   \u2502   \u251c\u2500\u2500 Default Arguments/\n\u2502   \u2502   \u251c\u2500\u2500 Function Attributes/\n\u2502   \u2502   \u251c\u2500\u2500 Function Specifiers/\n\u2502   \u2502   \u2514\u2500\u2500 Forward Declarations/\n\u2502   \u251c\u2500\u2500 Function Overloading\n\u2502   \u251c\u2500\u2500 Inline Functions\n\u2502   \u251c\u2500\u2500 Lambdas/\n\u2502   \u2502   \u251c\u2500\u2500 When to Use Lambdas\n\u2502   \u2502   \u2514\u2500\u2500 Lambda Use Case\n\u2502   \u251c\u2500\u2500 Recursion\n\u2502   \u251c\u2500\u2500 Questions\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 05 Data Types/\n\u2502   \u251c\u2500\u2500 Static Typing\n\u2502   \u251c\u2500\u2500 Strong Typing\n\u2502   \u251c\u2500\u2500 Primitive Data Types/\n\u2502   \u2502   \u251c\u2500\u2500 Standard Integer Types\n\u2502   \u2502   \u251c\u2500\u2500 Fixed-Width Integer Types\n\u2502   \u2502   \u251c\u2500\u2500 Unsigned Integers\n\u2502   \u2502   \u251c\u2500\u2500 Integer Literals\n\u2502   \u2502   \u251c\u2500\u2500 Floating-Point Types\n\u2502   \u2502   \u2514\u2500\u2500 Character Types\n\u2502   \u251c\u2500\u2500 Type Casts/\n\u2502   \u2502   \u251c\u2500\u2500 Conversions\n\u2502   \u2502   \u251c\u2500\u2500 C-Style Cast\n\u2502   \u2502   \u251c\u2500\u2500 C++ Casts/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Static Cast\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Dynamic Cast\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Constant Cast\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Reinterpret Cast\n\u2502   \u2502   \u2514\u2500\u2500 Cast Rules\n\u2502   \u251c\u2500\u2500 Automatic Type Inference\n\u2502   \u251c\u2500\u2500 Volatile Specifier\n\u2502   \u251c\u2500\u2500 Register Specifier\n\u2502   \u251c\u2500\u2500 Determining the Byte Size of Variables\n\u2502   \u251c\u2500\u2500 Compile-Time Constructs/\n\u2502   \u2502   \u251c\u2500\u2500 Constexpr\n\u2502   \u2502   \u2514\u2500\u2500 Consteval and Constinit\n\u2502   \u251c\u2500\u2500 Padding and Alignment/\n\u2502   \u2502   \u2514\u2500\u2500 Difference Between Alignment and Byte Size\n\u2502   \u251c\u2500\u2500 Type Punning\n\u2502   \u251c\u2500\u2500 Dynamic Typing/\n\u2502   \u2502   \u251c\u2500\u2500 Optional Data\n\u2502   \u2502   \u251c\u2500\u2500 Multi-Type Data Holder\n\u2502   \u2502   \u2514\u2500\u2500 Any Data Type\n\u2502   \u251c\u2500\u2500 Run-Time Type Identification/\n\u2502   \u2502   \u251c\u2500\u2500 Type ID\n\u2502   \u2502   \u2514\u2500\u2500 Considerations When Using RTTI\n\u2502   \u251c\u2500\u2500 Questions\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 06 Pointers and References/\n\u2502   \u251c\u2500\u2500 Memory Allocation\n\u2502   \u251c\u2500\u2500 Object Lifetimes\n\u2502   \u251c\u2500\u2500 Raw Pointers/\n\u2502   \u2502   \u251c\u2500\u2500 Declaring Pointers\n\u2502   \u2502   \u251c\u2500\u2500 Null Pointers\n\u2502   \u2502   \u251c\u2500\u2500 Accessing the Memory Address of a Variable\n\u2502   \u2502   \u251c\u2500\u2500 Dereferencing a Pointer\n\u2502   \u2502   \u251c\u2500\u2500 Dynamic Memory Allocation/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Initializing Heap Memory\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Heap Memory Management\n\u2502   \u2502   \u251c\u2500\u2500 Constant Pointers/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Pointer to Constant\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Constant Pointer\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Constant Pointer to Constant\n\u2502   \u2502   \u251c\u2500\u2500 Pointer to Pointer\n\u2502   \u2502   \u251c\u2500\u2500 Pointer Safety/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Dangling Pointers\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Memory Leaks\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Buffer Overflows\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Pointer Aliasing and Ownership\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Preventions\n\u2502   \u251c\u2500\u2500 Pointer Arithmetic\n\u2502   \u251c\u2500\u2500 References/\n\u2502   \u2502   \u251c\u2500\u2500 Reference vs. Address-of Operator\n\u2502   \u2502   \u251c\u2500\u2500 Pass by Value vs. Pass by Reference\n\u2502   \u2502   \u2514\u2500\u2500 When to Pass by Reference\n\u2502   \u251c\u2500\u2500 Function Pointer\n\u2502   \u251c\u2500\u2500 Where to Use Function Pointers\n\u2502   \u251c\u2500\u2500 Lvalues and Rvalues/\n\u2502   \u2502   \u251c\u2500\u2500 Lvalue Reference\n\u2502   \u2502   \u2514\u2500\u2500 Rvalue Reference\n\u2502   \u251c\u2500\u2500 Move Semantics/\n\u2502   \u2502   \u251c\u2500\u2500 Standard Move Function\n\u2502   \u2502   \u2514\u2500\u2500 Move Assignment Operator\n\u2502   \u251c\u2500\u2500 Smart Pointers/\n\u2502   \u2502   \u251c\u2500\u2500 Unique Pointer\n\u2502   \u2502   \u251c\u2500\u2500 Shared Pointer\n\u2502   \u2502   \u251c\u2500\u2500 Weak Pointer\n\u2502   \u2502   \u2514\u2500\u2500 When to Use Smart Pointers\n\u2502   \u251c\u2500\u2500 Questions\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 07 Collections of Data/\n\u2502   \u251c\u2500\u2500 C-Style Arrays/\n\u2502   \u2502   \u251c\u2500\u2500 Access and Modify Elements\n\u2502   \u2502   \u251c\u2500\u2500 Iterate Over Arrays\n\u2502   \u2502   \u251c\u2500\u2500 Pointer Arithmetic on Arrays\n\u2502   \u2502   \u251c\u2500\u2500 Array Heap Allocation\n\u2502   \u2502   \u251c\u2500\u2500 Multidimensional Arrays/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Dynamically Allocate a 2D Array\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Deallocate a 2D Array\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Access Multidimensional Arrays\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Optimize Memory Access for Multidimensional Arrays\n\u2502   \u251c\u2500\u2500 Strings/\n\u2502   \u2502   \u251c\u2500\u2500 C-Style Strings\n\u2502   \u2502   \u251c\u2500\u2500 Modifiable C-Style Strings\n\u2502   \u2502   \u251c\u2500\u2500 C++ Strings\n\u2502   \u2502   \u251c\u2500\u2500 String Concatenation\n\u2502   \u2502   \u251c\u2500\u2500 String Literals/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Raw String Literals\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Unicode String Literals\n\u2502   \u2502   \u251c\u2500\u2500 Small Strings\n\u2502   \u2502   \u251c\u2500\u2500 Optimize Strings in C++/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Substring Operations Overhead\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 String Views\n\u2502   \u251c\u2500\u2500 C++ Static Array\n\u2502   \u251c\u2500\u2500 Dynamic Array/\n\u2502   \u2502   \u2514\u2500\u2500 Vector Optimization\n\u2502   \u251c\u2500\u2500 HashMap/\n\u2502   \u2502   \u251c\u2500\u2500 Hashing Function\n\u2502   \u2502   \u2514\u2500\u2500 Index Operator\n\u2502   \u251c\u2500\u2500 Linked List\n\u2502   \u251c\u2500\u2500 Stack and Queue\n\u2502   \u251c\u2500\u2500 Iterators/\n\u2502   \u2502   \u2514\u2500\u2500 Range-Based For Loops\n\u2502   \u251c\u2500\u2500 Questions\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n\u251c\u2500\u2500 08 User Defined Types\n\u2502   \u251c\u2500\u2500 Structs\n\u2502   \u2502   \u2514\u2500\u2500 Bitfields\n\u2502   \u251c\u2500\u2500 Unions\n\u2502   \u251c\u2500\u2500 Enums\n\u2502   \u251c\u2500\u2500 Classes/\n\u2502   \u2502   \u251c\u2500\u2500 Static Inside Classes\n\u2502   \u2502   \u251c\u2500\u2500 Static Outside Classes\n\u2502   \u2502   \u251c\u2500\u2500 Getters and Setters\n\u2502   \u2502   \u251c\u2500\u2500 Constant Member Functions\n\u2502   \u2502   \u251c\u2500\u2500 Constructors/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Member Initializer List\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Copy Constructor\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Copy Assignment Operator\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Move Constructor\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Move Assignment Operator\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Explicit Constructor\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Rule of Zero and Five\n\u2502   \u2502   \u251c\u2500\u2500 Destructors\n\u2502   \u2502   \u251c\u2500\u2500 Arrow Operator\n\u2502   \u2502   \u2514\u2500\u2500 Current Instance Pointer\n\u2502   \u251c\u2500\u2500 Inheritance and Polymorphism\n\u2502   \u251c\u2500\u2500 Singletons\n\u2502   \u251c\u2500\u2500 Questions\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\n...\n\u2502\n\u251c\u2500\u2500 10 Macros\n\u2502   \u251c\u2500\u2500 Object Like Macros\n\u2502   \u251c\u2500\u2500 Function Like Macros\n\u2502   \u251c\u2500\u2500 Stringizing Operator\n\u2502   \u251c\u2500\u2500 Token Concatenation Operator\n\u2502   \u251c\u2500\u2500 Predefined Macros\n\u2502   \u251c\u2500\u2500 Conditional Compilation\n\u2502   \u251c\u2500\u2500 Multiline Macros\n\u2502   \u251c\u2500\u2500 Variadic Macros\n\u2502   \u251c\u2500\u2500 Questions\n\u2502   \u2514\u2500\u2500 Exercises\n\u2502\nWorking on more...\n</pre>"},{"location":"01%20Introduction/","title":"01 Introduction","text":"<p>We chose C++ as our language of choice for learning computer science because it\u2019s an incredibly powerful and versatile tool. It offers low-level access to memory when we need fine-grained control, yet also provides high-level abstractions when we prefer to think in broader, conceptual terms. C++ is used to build everything from command-line utilities and desktop applications to high-performance systems such as 3D engines, game frameworks, and low-latency trading platforms.</p> <p>To spark your interest, C++ is the language behind major AAA titles like Counter-Strike, Fortnite, the Warcraft series and many more. Every industry-grade game engine\u2014such as Unreal, Unity, or Godot\u2014is built on it, and even modern operating systems, including parts of Windows, rely on C++ under the hood.</p> <p>Also, it\u2019s important to note that even if you\u2019re not aiming for game development or high-performance programming\u2014the areas where C++ truly shines\u2014learning C++ gives you a remarkably solid foundation in software engineering. Along the way, you\u2019ll also get to peek into several programming paradigms and long-standing design ideas. Not all of these ideas are universally great or perfectly modern, but they provide valuable context for how today\u2019s languages evolved.</p> <p>This kind of low-level understanding tends to carry over to almost every other language or technology stack you\u2019ll encounter later on.</p> <p>Another big reason C++ remains so relevant is that, in addition to its performance, it offers excellent portability. It runs natively on everything\u2014Windows, Linux, macOS, embedded devices, mobile platforms, game consoles\u2014you name it. It supports both 32-bit and 64-bit architectures and compiles directly to machine code, which means it can be very fast when written well.</p> <p>But here\u2019s the flip side: C++ gives you a lot of control\u2014especially over memory\u2014and that also means it\u2019s easier to shoot yourself in the foot. Sloppy code can lead to memory leaks, crashes, or bugs that are notoriously tricky to track down. It\u2019s a language that rewards careful thinking and clean design.</p> <p>But despite its challenges, C++ remains one of the most enduring languages in modern computing. Part of that longevity comes from its roots: C++ is built on top of C, one of the oldest and most influential programming languages still in use today. Much of C code even compiles directly as valid C++, but C++ takes things further. It introduces features that make your programs safer, more maintainable, and more modern\u2014without losing the raw performance that made C so famous.</p> <p>In this book, we\u2019ll work through modern C++ from the ground up. Along the way, we\u2019ll occasionally dip into C concepts as well, especially when we want to get closer to the hardware or squeeze out every last bit of performance.</p> <p>Info</p> <p>Before we jump into actual coding, we need to cover a few essentials in this introduction chapter. We'll go through how to set up your development environment, introduce some basic terminology and conventions used throughout the book, and get familiar with how the C++ build process works. Once those foundations are in place, we\u2019ll be ready to start writing C++ code.</p>"},{"location":"01%20Introduction/#environment-setup","title":"Environment Setup","text":"<p>To write and run C++ code on your computer, you need two essential components:</p> <ul> <li> <p>Compiler: A program that translates your human-readable C++ source code\u2014essentially plain text\u2014into machine-readable binary. It acts as a bridge between your code and the hardware, allowing the CPU to execute your instructions.</p> </li> <li> <p>Code Editor or IDE (Integrated Development Environment): A tool that helps you write, edit, and manage your code. Most IDEs also provide features like syntax highlighting, auto-completion and debugging tools.</p> </li> </ul>"},{"location":"01%20Introduction/#recommended-setup-for-windows","title":"Recommended Setup for Windows","text":"<p>The easiest way to get started with C++ on Windows is to use Microsoft Visual Studio Community Edition. It\u2019s a fully featured IDE that comes preconfigured for C/C++ development and includes the MSVC compiler, so there\u2019s no need to install everything separately. Everything you need comes in a single package.</p> <p>Installation Steps</p> <ol> <li>Download Visual Studio Community Edition from the Microsoft official website    https://visualstudio.microsoft.com/vs/community/ or directly from the Microsoft Store.</li> <li>During installation, select \u201cDesktop development with C++\u201d to include the required compiler and tools.</li> <li>After installation, launch Visual Studio</li> <li>Click \u201cCreate a new project\u201d</li> <li>In the project language filter, choose C++</li> <li>Select \u201cConsole App\u201d</li> <li>Enter your desired project name</li> <li>Choose a location for the project (default is usually C:\\Users\\Username\\source\\repos)</li> <li>Click Create</li> </ol> <p>To test your setup, run the \"Console App\" sample program by clicking the green arrow button at the top center of the screen.</p> <p>If a command line window appears showing \u201cHello World!\u201d, your installation is complete and working correctly.</p> <p>Tip</p> <p>To add a new file in Visual Studio, right-click on Source Files or Header Files in the Solution Explorer, depending on the type of file you need. Then choose Add \u2192 New Item and give it a name, such as <code>example.cpp</code>.</p> <p>Keep in mind that Source Files and Header Files are just filters in the Solution Explorer\u2014they don\u2019t represent the actual folder structure on your system. All files you add will be placed in the same physical project directory on disk.</p> <p>Tip</p> <p>For a more advanced C++ development experience in Visual Studio, consider using Visual Assist. It enhances code navigation, refactoring, and auto-completion.</p> <p>It\u2019s not free (offers a 1-month trial or is free with a student ID), but it\u2019s highly recommended for serious C++ work. More info here: https://www.wholetomato.com/</p>"},{"location":"01%20Introduction/#recommended-setup-for-macos","title":"Recommended Setup for macOS","text":"<p>The easiest way to get started with C++ on macOS is by using Xcode, Apple\u2019s official IDE. It includes the Clang compiler and provides everything you need to build and run C++, all in one package.</p> <p>Installation Steps</p> <ol> <li>Open the Mac App Store and download Xcode.</li> <li>Once installed, launch Xcode.</li> <li>Click \u201cCreate a new Xcode project\u201d</li> <li>Under macOS, select \u201cCommand Line Tool\u201d and click Next</li> <li>Enter a product name (e.g., HelloCpp)</li> <li>Set Language to C++</li> <li>Click Next</li> <li>Choose a location to save your project and click Create</li> </ol> <p>To test the installation, run the sample code included in the project by clicking the Run button at the top-left corner of the Xcode window.</p> <p>Once you see \u201cHello, World!\u201d output in the console, your setup is complete.</p> <p>Tip</p> <p>If the console is not visible, go to View \u2192 Debug Area \u2192 Activate Console.</p>"},{"location":"01%20Introduction/#recommended-setup-without-installation","title":"Recommended Setup Without Installation","text":"<p>If your computer struggles to run large IDEs\u2014or if you simply want to start coding immediately without installing anything\u2014you can use an online C++ compiler. This is a fast and convenient way to write, compile and run C++ code directly from your browser.</p> <p>The best online environment is Compiler Explorer, created by Matt Godbolt. It\u2019s free, powerful and widely used by professional developers for testing and learning C++ features.</p> <p>How to Use</p> <ol> <li>Go to https://godbolt.org/.</li> <li>Select a compiler from the drop-down menu on the top-left</li> <li>Type your C++ code in the editor pane on the left.</li> <li>Click Run or press Ctrl + Enter to compile and execute your code.</li> <li>The output will appear in the console area at the bottom-right of the screen.</li> </ol> <p>Warning</p> <p>Compiler Explorer is ideal for quickly testing code snippets, comparing compiler behavior or experimenting with new C++ features without changing your local setup. However, it\u2019s not designed for large projects\u2014once you start building multi-file programs, you\u2019ll want to switch to a local IDE.</p>"},{"location":"01%20Introduction/#build-process","title":"Build Process","text":"<p>Info</p> <p>Don\u2019t worry if some words sound unfamiliar\u2014we\u2019ll explain everything clearly as we go.</p> <p>Now that the setup is behind us let\u2019s take a look at how C++ programs actually come together.</p> <p>To tell a computer what we want it to do, we write code using a programming language\u2014in our case, we've chosen C++. This code is written in plain text files, but instead of using the standard <code>.txt</code> extension, they use different extensions to reflect their purpose and indicate which programming language they're written in.</p> <p>Files referred to as source files\u2014usually with a <code>.cpp</code> extension (though you might also see <code>.cc</code> or <code>.cxx</code>)\u2014contain the actual logic and instructions that make your program run.</p> <p>Files referred to as header files\u2014commonly ending in <code>.h</code>, <code>.hh</code>, or <code>.hpp</code>\u2014are used to declare things like functions, classes, and variables so they can be shared across multiple source files.</p> <p>These file extensions are common, but they\u2019re just conventions\u2014they don\u2019t affect how the compiler interprets your code. Naming patterns help humans organize files, but technically, you could name them almost anything. This separation of code into source and header files is foundational to how C++ projects are structured.</p> <p>Once we\u2019ve written code describing what we want the computer to do, the next step is to turn it into a binary file\u2014a format the machine can execute directly.</p> <p>This binary is usually either an executable such as a <code>.exe</code> file or a library, which contains pre-written, pre-compiled code that can be linked into an executable, like <code>.lib</code> or <code>.dll</code> files. We'll dive deeper into libraries and the process of linking against them in later chapters.</p> <p>The next important piece to understand is the compilation process itself\u2014how your source code becomes a working program. This process is influenced by two key settings: project configuration and target platform.</p> <p>This determines how the compiled binary behaves. The two most common project configurations are:</p> Configuration Description Use Case Debug Includes extra information like error messages and debug symbols Ideal during development Release Optimized for performance; debugging info is removed For final builds <p>Target platform refers to the system architecture your program is intended to run on, such as x86 (32-bit) or x64 (64-bit).</p> <p>Note</p> <p>Programs must be compiled separately for each target platform. A binary built for Windows won\u2019t run on macOS or Linux and vice versa.</p> <p>Architecture also matters: a 32-bit program can usually run on a 64-bit system, but a 64-bit program will not run on a 32-bit system.</p>"},{"location":"01%20Introduction/#entry-point","title":"Entry Point","text":"<p>Every program needs an entry point\u2014the place where program execution begins and in C++, that entry point is always the <code>main</code> function.</p> <p>There must be exactly one entry point; if it\u2019s missing or if there\u2019s more than one, the compiler won\u2019t know where to start running your code, resulting in a compilation error.</p> <p>We\u2019ve already seen an entry point during setup, where a sample file was created for us by the IDE.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\\n\";\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>Note</p> <p><code>main.cpp</code> is a common filename for the source file containing your program\u2019s entry point, but it\u2019s not required. You can name the file anything you want\u2014what matters is the main function itself.</p> <p>In the example, the entry point is as expected\u2014the function called main highlighted on line 3.  This is where the program starts executing after it is launched.</p> <p>Everything inside the curly braces is called the function body, which contains the instructions that execute when the function is called\u2014in this case, when the program begins.</p> <p>One other thing to note about the main function is that, even though it declares a return type of integer, you might not always see a return statement. Don\u2019t worry\u2014we\u2019ll cover return statements in more detail in a later chapter focused solely on functions.</p> <p>For now, it\u2019s enough to know that what\u2019s happening here is that modern compilers automatically insert a <code>return 0;</code> at the end of main function body if you don\u2019t include it yourself. This behavior is specific to main and does not apply to other functions.</p>"},{"location":"01%20Introduction/#preprocessor-directives","title":"Preprocessor Directives","text":"<p>In C++, any line that begins with a sharp symbol is called a preprocessor directive. These are instructions handled before actual compilation begins\u2014hence the name preprocessor. They aren\u2019t part of the C++ language itself but are understood by a separate tool called the preprocessor, which runs just before the compiler in the build process.</p> <p>We\u2019ve already seen one of these in the sample program we ran earlier.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\\n\";\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>The highlighted line tells the preprocessor to find the file named <code>iostream</code> and copy-paste its entire contents into this file at that exact location. This makes all the functionality defined in <code>&lt;iostream&gt;</code> \u2014 such as input/output using <code>std::cout</code> (console output), <code>std::cin</code> (console input) \u2014 available in our program.</p> <p>Note</p> <p>This is only a brief introduction to what the preprocessor really is. The <code>#include</code> directive is just one of many, and preprocessors themselves are part of a much broader topic involving macros and metaprogramming\u2014concepts we\u2019ll gradually work our way toward much later in the book.</p>"},{"location":"01%20Introduction/#compiler","title":"Compiler","text":"<p>The C++ compiler transforms your human-readable code into a format that computers can understand\u2014but it does so in several stages.</p> <p>First, it creates intermediate files\u2014typically with a <code>.obj</code> extension on Windows or <code>.o</code> on macOS/Linux. These files are usually found inside your project directory, often in folders like <code>x64/Debug</code> or <code>build/</code>.</p> <p>During compilation, the compiler first processes all preprocessor directives, then tokenizes and parses your code. Parsing builds an internal representation called an Abstract Syntax Tree (AST), which describes the structure and meaning of your program.</p> <p>Once the AST is ready, the compiler generates machine code, producing a binary object file based on your original source code.</p> <p>Here\u2019s a sample of what a raw <code>.obj</code> file might look like.</p> main.obj<pre><code>00000000 64 86 6B D0 D7 95 06 69 BC 02 01 00 3E 02 00 00 d.k....i....&gt;...\n00000010 00 00 00 00 2E 64 72 65 63 74 76 65 00 00 00 00 ....drectve...\n00000020 00 00 00 00 CA 01 00 00 CC 10 00 00 00 00 00 00 ................\n00000030 00 00 00 00 00 00 00 00 00 0A 10 00 2E 64 65 62 ........ .deb\n00000040 75 67 24 53 00 00 00 00 00 00 00 CC AC 00 00 00 ug$S............\n00000050 96 12 00 00 62 BF 00 00 00 00 00 00 EE 00 00 00 ....b...........\n00000060 40 00 10 42 2E 62 73 73 00 00 00 00 00 00 00 00 @..B..bss.......\n00000070 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00000080 00 00 00 00 00 00 00 00 80 10 30 C0 2E 6D 73 76 ........ .msv\n00000090 63 6A 6D 63 00 00 00 00 00 00 00 00 00 00 00 00 cjmc............\n\n... (truncated for brevity)\n</code></pre> main.asm<pre><code>.LC0:\n        .string \"Hello World!\\n\"\nmain:\n        push    rbp\n        mov     rbp, rsp\n        mov     esi, OFFSET FLAT:.LC0\n        mov     edi, OFFSET FLAT:std::cout\n        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp;, char const*)\n        mov     eax, 0\n        pop     rbp\n        ret\n</code></pre> <p>You don\u2019t need to understand these low-level details right now\u2014they\u2019re just examples of how code is represented internally at different stages of compilation. Keep in mind that these snippets don\u2019t directly correspond to one another\u2014they\u2019re simplified excerpts from larger generated files.</p> <p>Tip</p> <p>You can easily explore how your C++ code is compiled into assembly using Compiler Explorer: https://godbolt.org/</p> <p>Each preprocessed source file in your project becomes what\u2019s known as a translation unit. The compiler processes each translation unit independently, generating one object file for each.</p> <p>If your program contains multiple source files, the compiler will produce multiple object files\u2014one per translation unit. These object files are then passed to the linker, which combines them into the final executable or library. If your program consists of only a single source file, you\u2019ll end up with just one object file.</p>"},{"location":"01%20Introduction/#assembler","title":"Assembler","text":"<p>Once the compiler generates low-level instructions from your translation units, these instructions are still not in a format the CPU can execute directly\u2014they\u2019re stored as human-readable assembly code inside object files.</p> <p>This is where the assembler comes in. The assembler converts those assembly instructions into pure machine code\u2014binary instructions made up of 0s and 1s that the CPU can understand and execute directly.</p> <p>In practice, this step is handled automatically by the compiler toolchain, so you rarely interact with the assembler directly. However, it\u2019s useful to know that this step exists because it explains why compiled languages like C++ are so fast: once assembled, the resulting machine code runs natively on the hardware without any intermediary layer like.</p>"},{"location":"01%20Introduction/#linker","title":"Linker","text":"<p>After the compiler processes each translation unit into object files, the linker\u2019s job is to bring everything together into a final executable. Without linking, each translation unit only knows about its own contents, so the program can\u2019t run as a whole.</p> <p>The linker connects all the pieces by resolving function calls, variables and other symbols across translation units. Even if your program consists of just a single translation unit, the linker still plays an important role\u2014it locates the program\u2019s entry point so execution knows where to begin.</p> <p>Below is an example illustrating a common linker error.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint Multiply(int a, int b); // Function declaration\n// Missing function definition \n\nint main() {\n    std::cout &lt;&lt; Multiply(3, 7) &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Linker Error: unresolved external symbol\n</code></pre> <p>Linker errors appear only after the program has been compiled and the linker tries to combine all object files into one executable. Although each individual source file may compile successfully on its own, the linker might still fail if it can\u2019t find a function or variable definition that was declared elsewhere.</p> <p>In this example, the problem occurs because the function <code>Multiply</code> is declared but never defined. The linker tries to connect the <code>Multiply</code> call to actual machine code, but it can\u2019t find it\u2014so the build fails.</p> <p>You can fix the error by simply providing the function definition.</p> <pre><code>#include &lt;iostream&gt;\n\nint Multiply(int a, int b) {\n    return a * b;\n}\n\nint main() {\n    std::cout &lt;&lt; \"Multiplication: \" &lt;&lt; Multiply(3, 7) &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Multiplication: 21\n</code></pre> <p>This might seem like a simple mistake, but in large projects with dozens of translation units and external libraries, linker errors like this can be surprisingly tricky to diagnose and fix.</p>"},{"location":"01%20Introduction/#header-files","title":"Header Files","text":"<p>We mentioned earlier that in C++, there are two main types of files: source files and header files.</p> <p>Source files (like the ones we\u2019ve been working with so far) contain the actual implementation and logic of your program. Each source file gets compiled into an object file, forming what\u2019s known as a translation unit.</p> <p>The second type is the header file. You\u2019ve already seen one in the sample your IDE generated.</p> main.cpp<pre><code>#include &lt;iostream&gt; // iostream is the name of a header file\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>Header files are used primarily for declarations\u2014not definitions. They describe what exists (functions, classes, constants, etc.), but not how they work. By including a header, you tell the compiler: \u201cHey, these functions and objects exist somewhere\u2014trust me, you\u2019ll find their definitions later during linking.\u201d</p> <p>Without these headers, the compiler would be completely unaware of things like std::cout, and you\u2019d get a long list of errors, as shown below.</p> example<pre><code>&lt;source&gt;: In function 'int main()':\n&lt;source&gt;:2:14: error: 'cout' is not a member of 'std'\n    2 |         std::cout &lt;&lt; \"Hello World!\\n\";\n      |              ^~~~\n&lt;source&gt;:1:1: note: 'std::cout' is defined in header '&lt;iostream&gt;'; this is probably fixable by adding '#include &lt;iostream&gt;'\n  +++ |+#include &lt;iostream&gt;\n    1 | int main() {\nCompiler returned: 1\n</code></pre> <p>Let\u2019s look at a simple example using our own header file.</p> log.h<pre><code>#pragma once\n\nvoid Log(const char* message);\n</code></pre> log.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid Log(const char* message) {\n    std::cout &lt;&lt; message &lt;&lt; '\\n';\n}\n</code></pre> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#include \"log.h\"\n\nint main() {\n    Log(\"Using Logging Function!\");\n}\n</code></pre> output<pre><code>Using Logging Function!\n</code></pre> <p>Here, <code>main.cpp</code> includes <code>log.h</code>, which declares the <code>Log</code> function, while the actual implementation lives in <code>log.cpp</code>. As we\u2019ve learned, <code>#include</code> is a preprocessor directive that tells the compiler to copy the contents of the specified file into the current translation unit.</p> <p>When compiled, both files become separate translation units. The linker then connects them by matching the function call in <code>main.cpp</code> with the definition in <code>log.cpp</code>.</p> <p>That\u2019s why <code>main.cpp</code> knows about the <code>Log</code> function\u2014even though it\u2019s implemented elsewhere. Without the header file, the compiler would have no idea what <code>Log</code> is and would throw an error during compilation, never making it to the linking stage.</p>"},{"location":"01%20Introduction/#header-guard","title":"Header Guard","text":"<p>You may have noticed a new directive at the top of <code>log.h</code>.</p> <pre><code>#pragma once\n</code></pre> <p>This is called a header guard. It ensures that the contents of the file are included only once per translation unit\u2014even if the file gets included multiple times through different paths. Without a header guard, the same declarations (such as functions or variables) could be included more than once, leading to redefinition errors during compilation.</p> <p>Header guards are especially important in larger projects, where headers may be chained together or included indirectly through other headers.</p> <p>The traditional (and more portable) approach uses the <code>#ifndef</code> directive. While a bit more verbose than <code>#pragma once</code>, it\u2019s more widely supported and commonly used.</p> log.h<pre><code>#ifndef LOG_H_\n#define LOG_H_\n\nvoid Log(const char* message);\n\n#endif\n</code></pre> <p>This pattern works by checking whether <code>LOG_H_</code> has already been defined. If not, it defines it and includes the content inside. If the file has already been included elsewhere, the compiler skips its contents\u2014avoiding duplicate declarations.</p>"},{"location":"01%20Introduction/#header-file-search","title":"Header File Search","text":"<p>In <code>main.cpp</code>, we used two different notations when including header files.</p> <pre><code>#include &lt;iostream&gt;\n#include \"log.h\"\n</code></pre> <p>The difference between them lies in where the compiler looks for the header file.</p> Syntax Search Path Typical Use Case <code>&lt;...&gt;</code> Searches system and standard library include paths. For standard headers like <code>&lt;iostream&gt;</code>. <code>\"...\"</code> Searches relative to the including file, usually starting with the current working directory. For project-specific headers like <code>log.h</code>."},{"location":"01%20Introduction/#comments","title":"Comments","text":"<p>Comments are lines in your code that are completely ignored by the compiler. This means they have no effect on what the program does\u2014they exist solely for humans to read.</p> <p>Comments are essential because, as programs grow larger and more complex, it becomes necessary to document your code. This helps others\u2014or even your future self\u2014understand what the code is doing and why certain decisions were made.</p> <p>However, keep in mind that good code should be self-documenting. Avoid writing comments that merely restate what the code already makes obvious, as comments should explain why the code does something, not what it does.</p> <p>Use comments to:</p> <ul> <li>Document non-obvious behavior or complex algorithms.</li> <li>Leave notes for future improvements or reminders.</li> <li>Temporarily disable code for debugging or testing purposes.</li> </ul>"},{"location":"01%20Introduction/#comment-types","title":"Comment Types","text":"Type Syntax Description Single-line comment <code>//</code> Anything after <code>//</code> on the same line is treated as a comment. Multi-line comment <code>/* ... */</code> Used for longer explanations that span multiple lines. main.cpp<pre><code>#include &lt;iostream&gt; // This is a single-line comment\n\n/* \n    This is a multi-line comment.\n    It can span multiple lines without needing // on each line. \n*/ \n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\\n\";\n}\n</code></pre> output<pre><code>\"Hello World!\"\n</code></pre>"},{"location":"01%20Introduction/#data-types-and-variables","title":"Data Types and Variables","text":"<p>In programming, data types and variables are fundamental concepts. Programming is ultimately about working with data\u2014and to work with it effectively, two things must happen.</p> Requirement Description Storage Data must be placed somewhere in the computer\u2019s memory. Typing The program must understand what kind of data it\u2019s dealing with (e.g., a number, a character, or a boolean). <p>To represent different kinds of data, we use data types. To actually hold that data in memory, we use variables.</p> <p>Even though all data in memory is ultimately stored as binary, data types give those raw bits meaning. The main differences between data types come down to how much memory they use and how those bits are interpreted.</p> <p>Info</p> <p>Data types are important enough to deserve their own full chapter\u2014but for now, this brief introduction will do just fine.</p>"},{"location":"01%20Introduction/#primitive-data-types","title":"Primitive Data Types","text":"<p>The most basic data types in C++ are called primitive types. They form the foundation for all more complex types you\u2019ll encounter later.</p> Type Name Description Size (bytes) <code>int</code> Integer Stores whole numbers Typically 4 <code>float</code> Floating-point number Stores numbers with decimals. Precision is limited. 4 <code>double</code> Double-precision float Similar to <code>float</code>, but with more precision. 8 <code>char</code> Character Stores a single ASCII character (e.g., 'A', 'b', '#'). 1 <code>bool</code> Boolean Stores only <code>true</code> (1) or <code>false</code> (0). 1 (implementation-defined) <p>Tip</p> <p>In programming, instead of using spaces to separate large numbers for readability (which would cause a syntax error), you can group digits using single quotes. For example, instead of writing 1976834, you can write 1'976'834\u2014this makes the number easier to read, especially when dealing with thousands or millions.</p>"},{"location":"01%20Introduction/#ascii","title":"ASCII","text":"<p>When we talk about text or characters in code, what we\u2019re really dealing with under the hood are just numbers.</p> <p>Each character\u2014whether a letter, digit, or symbol\u2014is stored as an integer value defined by the ASCII (American Standard Code for Information Interchange) standard. ASCII assigns a unique numeric code to each printable and control character.</p> ASCII Code Character 65 A 66 B 97 a 48 0 <p>That means characters can participate in arithmetic operations just like integers.</p> <p>So, whenever you see a character literal, remember: it\u2019s really just an integer with a special meaning attached.</p> <p>You can explore the full ASCII table here: https://www.ascii-code.com/</p>"},{"location":"01%20Introduction/#declaring-and-naming-variables","title":"Declaring and Naming Variables","text":"<p>A variable is a named storage location for data in memory. When we create a variable, we assign it a data type and name so that we can refer to it later in our program.</p> <p>Rules for Naming Variables:</p> <ul> <li>Must start with a letter or underscore, but cannot start with a number.</li> <li>Can contain letters, numbers, and underscores, but no spaces.</li> <li>Cannot use C++ reserved keywords (e.g., <code>int</code>, <code>float</code>, <code>return</code>).</li> <li>Should be descriptive (e.g., <code>user_age</code> instead of <code>x</code>).</li> </ul> <p>We assign values to variables using the <code>=</code> symbol, called the assignment operator. There are a few important rules to keep in mind when assigning values:</p> <ul> <li>Floating-point numbers: Use a dot instead of a comma, e.g., <code>3.14</code>, <code>-2.71</code>.</li> <li>Characters: Must be enclosed in single quotes, e.g., <code>'A'</code>, <code>'b'</code>, <code>'#'</code>.</li> <li>Escape sequences such as <code>\\t</code> (tab) and <code>\\n</code> (new line) are special characters that affect text formatting.</li> </ul> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main () {\n    int user_age = 25;\n    const float pi = 3.14;    \n    char user_grade = 'A';\n    bool underaged = false;\n\n    std::cout &lt;&lt; \"User age: \" &lt;&lt; user_age &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"PI: \" &lt;&lt; pi &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"User grade: \" &lt;&lt; user_grade &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Underaged? \" &lt;&lt; underaged;\n}\n</code></pre> output<pre><code>User age: 25\nPI: 3.14\nUser grade: 25\nUnderaged? 0\n</code></pre> <p>In C++, each declaration or statement must end with a semicolon <code>;</code>. This symbol tells the compiler that the statement is complete.</p> <p>Danger</p> <p>You might come across codebases or developers who declare multiple variables of the same type on a single line, as shown in the snippet below.  </p> <pre><code>int number_one, number_two;\n</code></pre> <p>While this is allowed and will work, it\u2019s considered a bad habit because it reduces readability and can lead to subtle bugs.</p> <p>Additionally, in the example above, you might have noticed a specific way of naming variables. This naming style is called snake_case, where all characters are lowercase and words are separated by underscores (e.g., user_age, player_score). This style improves readability, especially in longer variable names, and is commonly used in many C++ codebases.</p> <p>Info</p> <p>Throughout this book, we will follow the Google C++ Style Guide, which recommends using snake_case for variable names and PascalCase for function and class names.</p> <p>You can learn more about these conventions and other best practices here:  https://google.github.io/styleguide/cppguide.html</p>"},{"location":"01%20Introduction/#constants","title":"Constants","text":"<p>Sometimes, we want our stored data to be read-only. To achieve this, we use the <code>const</code> keyword in front of a variable declaration, which ensures the variable remains unchangeable after initialization.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    const int number = 54;\n\n    number = 34;\n\n    std::cout &lt;&lt; number; \n}\n</code></pre> output<pre><code>error: assignment of read-only variable \u2018number\u2019\n</code></pre> <p>As shown in the example above, a constant variable cannot be reassigned a value\u2014it results in an error.</p>"},{"location":"01%20Introduction/#console-input-and-output","title":"Console Input and Output","text":"<p>So far, we've focused on how programs come together and store data internally. Equally important, however, is understanding how data enters and exits a program. While programs can receive input and produce output through many sources\u2014such as files, databases, or different APIs\u2014the most fundamental method is through console input and output.</p> <p>In C++, this is handled by the standard library header <code>&lt;iostream&gt;</code>, which provides tools for displaying messages to the user and reading input from the console.</p> <p>The following example demonstrates how to use <code>std::cout</code> to prompt the user and <code>std::cin</code> to read their response.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int user_age;\n\n    std::cout &lt;&lt; \"Enter your age: \";\n    std::cin &gt;&gt; user_age;\n\n    std::cout &lt;&lt; \"Entered age was - \" &lt;&lt; user_age;\n}\n</code></pre> output<pre><code>Depends on the input you provided\n</code></pre> <p>It can be tricky at first to remember which symbols to use for input and output streams. A helpful way to visualize them is to think of them as arrows showing the direction of data flow.</p> Type Statement Description input <code>std::cin &gt;&gt; variable;</code> Data flows from the console into the variable. output <code>std::cout &lt;&lt; message;</code> Data flows from the program out to the console."},{"location":"01%20Introduction/#additional-output-streams","title":"Additional Output Streams","text":"<p>Up to this point, we\u2019ve only used <code>std::cout</code> to send output to the console. In practice, however, C++ provides three standard output streams, each intended for a slightly different purpose.</p> <p>Alongside <code>std::cout</code>, we are also provided with <code>std::cerr</code> and <code>std::clog</code>.</p> <p>All three can print text to the console using the same syntax, but <code>std::cerr</code> and <code>std::clog</code> are primarily intended for diagnostic output\u2014such as error messages, warnings, or debugging information. As you\u2019ll see in the next subsection, the key difference between them lies in how their output is handled internally.</p> <p>This distinction may not matter much in very small programs, but it becomes important as programs grow larger.</p>"},{"location":"01%20Introduction/#stream-buffers","title":"Stream Buffers","text":"<p>When we output something to the screen, it may feel like the text appears instantly. Behind the scenes, however, the process is a little more involved.</p> <p>Every time a program writes output, it must make a system call\u2014a request to the operating system\u2014to display text on the console. System calls are relatively slow, and performing one for every small piece of output would be inefficient.</p> <p>To avoid this, C++ uses stream buffers.</p> <p>A stream buffer is a temporary area in memory that collects output data before it is actually written to the console or a file. Instead of sending each character immediately, the program stores output in the buffer and writes it out in larger chunks.</p> <p>The contents of a buffer are written out (this is called flushing) when one of the following occurs:</p> <ul> <li>The buffer becomes full</li> <li>An explicit flush is requested, such as by using <code>std::flush</code> or <code>std::endl</code></li> <li>The program finishes execution normally</li> </ul> <p>This buffering behavior is why different output streams exist. For example, <code>std::cerr</code> is typically unbuffered, ensuring that error messages appear immediately, while <code>std::clog</code> is buffered, making it more suitable for logging.</p> <p>One subtle point to note is that <code>std::cout</code> is tied to <code>std::cin</code> by default. This means that whenever your program reads input from <code>std::cin</code>, <code>std::cout</code> is automatically flushed first. This ensures that prompts or messages appear before the program waits for input. <code>std::clog</code>, on the other hand, is not tied to <code>std::cin</code>, so it does not flush automatically when reading input.</p> <p>Warning</p> <p>One small caveat is worth keeping in mind when mixing output streams. Since <code>std::cerr</code> is typically unbuffered, its output is written immediately, while output sent to buffered streams like <code>std::cout</code> or <code>std::clog</code> may be delayed.</p> <p>As a result, error messages written to <code>std::cerr</code> can sometimes appear before earlier output, even though the program executed the statements in the expected order.</p> <p>When the exact order of diagnostic messages matters\u2014such as when logging program behavior\u2014it can be preferable to use std::clog, which is buffered and preserves a more predictable output sequence.</p>"},{"location":"01%20Introduction/#newlines-and-flushing","title":"Newlines and Flushing","text":"<p>In many classic C++ examples, you might see the following line.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n</code></pre> <p>This works fine, but it can be misleading. Unlike the newline character <code>\\n</code>, <code>std::endl</code> not only moves the output to a new line\u2014it also forces the output buffer to flush immediately. Internally, <code>std::endl</code> expands to the following.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; '\\n' &lt;&lt; std::flush;\n}\n</code></pre> <p>For small programs, this difference doesn\u2019t matter. But in larger programs or when printing lots of text quickly, forcing a flush on every line can become a performance bottleneck.</p> <p>Note</p> <p>In modern C++, we should avoid using <code>std::endl</code> altogether because it forces a flush every time, slowing down our program. If we want a newline, we should use the newline character <code>\\n</code>.</p> <p>When we really need to flush the output immediately\u2014for example, when printing error messages or debugging information. We have streams like <code>std::cerr</code> which are unbuffered and automatically print immediately, so in those cases, we do not need <code>std::endl</code> for flushing either.</p>"},{"location":"01%20Introduction/#questions","title":"Questions","text":"question 1answer <p>How many entry points can a valid C/C++ program have?</p> <p>Exactly one \u2014 the main function.</p> question 2answer <p>How does the <code>#include</code> preprocessor directive work?</p> <p>It copies the contents of the specified file directly into the location where it was included.</p> question 3answer <p>What is a preprocessed source file called?</p> <p>A translation unit.</p> question 4answer <p>During the compile step, does the compiler require a full function definition, or is a declaration enough?</p> <p>A declaration is enough \u2014 the actual connection to the definition happens during the linking phase.</p> question 5answer <p>What does a header guard protect against?</p> <p>Against multiple inclusion of the same header file.</p> question 6answer <p>Name the primitive data types mentioned in this chapter and their typical byte sizes.</p> <p>int    - 4 float  - 4 double - 8 char   - 1 bool   - 1</p> question 7answer <p>Which header provides input and output stream functionality in C++?</p> <p><code>&lt;iostream&gt;</code></p> question 8answer <p>What is a stream buffer used for?</p> <p>It temporarily stores output data before sending it to the terminal or file.</p> question 9answer <p>List the standard output streams covered in this chapter and explain their primary differences and typical use cases.</p> <ul> <li><code>std::cout</code> \u2014 Normal program output; buffered.</li> <li><code>std::cerr</code> \u2014 Error messages; unbuffered, prints immediately.</li> <li><code>std::clog</code> \u2014 Logging and diagnostic messages; buffered, prints in order, useful for tracking program behavior.</li> </ul> <p>Primary differences:</p> <ul> <li>Buffered vs unbuffered (affects when output appears)</li> <li>Intended purpose (normal output vs error vs logging)</li> <li><code>std::cerr</code> is immediate, <code>std::clog</code> preserves order like <code>std::cout</code></li> <li>While both <code>std::clog</code> and <code>std::cout</code> are buffered, <code>std::cout</code> is tied to <code>std::cin</code>, so reading input from <code>std::cin</code> will automatically flush the <code>std::cout</code> buffer.</li> </ul> question 10answer <p>Explain difference between a <code>\\n</code> and <code>std::endl</code> for writing a new line.</p> <p><code>\\n</code> only adds a newline character to the output. <code>std::endl</code> adds a newline and flushes the output buffer, which can slow the program down if used excessively.</p>"},{"location":"01%20Introduction/#exercises","title":"Exercises","text":"exercise 1answer <p>Write a program that prints your first name on one line  and your surname on the next line in the terminal.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Name\\n\";\n    std::cout &lt;&lt; \"Surname\";\n}\n</code></pre> exercise 2answer <p>Write a program that asks the user for their age, stores it in a variable, and then prints it back to the command line.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int user_age;\n\n    std::cout &lt;&lt; \"Enter your age: \";\n    std::cin &gt;&gt; user_age;\n\n    std::cout &lt;&lt; \"User age: \" &lt;&lt; user_age;\n}\n</code></pre>"},{"location":"02%20Operators/","title":"02 Operators","text":"<p>Info</p> <p>This chapter goes hand in hand with the 03 Control Flow/ chapter. So keep in mind that the two chapters are closely related, and many concepts work together. If something seems skipped here, it's likely because it was better suited for that chapter.</p> <p>In programming, operators are special symbols or keywords that perform actions on variables and values. They allow us to manipulate data, perform calculations, and control program logic. Whether it\u2019s adding numbers, comparing values, or modifying bits directly, operators are fundamental to how code behaves.</p> <p>At their core, operators resemble mathematical symbols, but they go far beyond basic arithmetic.</p>"},{"location":"02%20Operators/#comparison-operators","title":"Comparison Operators","text":"<p>The first and most fundamental type of operators are comparison operators, which are commonly used in conditions\u2014such as inside <code>if</code> statements or loops. They are similar to those found in mathematics. These operators allow us to compare values and control the flow of a program by returning <code>true</code> or <code>false</code> based on the result.</p> Operator Description Example <code>&gt;</code> Greater than <code>a &gt; b</code> <code>&lt;</code> Less than <code>a &lt; b</code> <code>&gt;=</code> Greater than or equal to <code>a &gt;= b</code> <code>&lt;=</code> Less than or equal to <code>a &lt;= b</code> <code>==</code> Equal to <code>a == b</code> <code>!=</code> Not equal to <code>a != b</code> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int user_age = 10;\n\n    if (user_age &lt; 0) {\n        std::cout &lt;&lt; \"Invalid age. Age cannot be negative.\";\n    } else if (user_age &lt; 12) {\n        std::cout &lt;&lt; \"Sorry, you are too young to enter.\";\n    } else {\n        std::cout &lt;&lt; \"Welcome to the game!\";\n    }\n}\n</code></pre> output<pre><code>Sorry, you are too young to enter.\n</code></pre>"},{"location":"02%20Operators/#logical-operators","title":"Logical Operators","text":"<p>Logical operators are used to combine multiple comparison expressions to form complex decision-making conditions. When used alongside comparison operators, they enable more precise control flow.</p> Operator Name Description <code>&amp;&amp;</code> Logical AND True only if both conditions are true. <code>||</code> Logical OR True if at least one condition is true. <code>!</code> Logical NOT Inverts the value of a condition (true \u2192 false, false \u2192 true). main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int x = 5;\n    bool is_ready = false;\n\n    if (x &gt; 0 &amp;&amp; x &lt; 10) {\n        std::cout &lt;&lt; \"x is between 1 and 9\\n\";\n    }\n\n    if (x &lt; 0 || x &gt; 100) {\n        std::cout &lt;&lt; \"x is out of range\\n\";\n    }\n\n    if (!is_ready) {\n        std::cout &lt;&lt; \"Not ready yet!\\n\";\n    }\n}\n</code></pre> output<pre><code>x is between 1 and 9\nNot ready yet!\n</code></pre>"},{"location":"02%20Operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<p>Next in line are arithmetic operators. They function just like in mathematics, helping us perform basic mathematical operations such as addition, multiplication, and more.</p> Operator Description Example <code>+</code> Adds two values <code>a + b</code> <code>-</code> Subtracts one value from another <code>a - b</code> <code>*</code> Multiplies two values <code>a * b</code> <code>/</code> Divides one value by another <code>a / b</code> <code>%</code> Computes the remainder of a division <code>a % b</code> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10 * 10;\n    int b = 20;\n    int c = a + b;\n\n    std::cout &lt;&lt; \"Number C: \" &lt;&lt; c;\n}\n</code></pre> output<pre><code>Number C: 120\n</code></pre> <p>Warning</p> <p>If a program tries to divide by zero, it will result in a runtime error (crash) because division by zero is undefined.</p> <p>Note</p> <p>The division operator <code>/</code> behaves differently depending on the operand types.</p> <p>If both operands are integers, the result is also an integer, discarding the decimal part. If at least one operand is a floating-point number, the result retains decimals.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Integer division: \" &lt;&lt; 9 / 2 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"One is floating point number: \" &lt;&lt; 9.0 / 2;\n}\n</code></pre> output<pre><code>Integer division: 4\nOne is floating point number: 4.5\n</code></pre> <p>The modulus operator <code>%</code> is only valid for integers and gives the remainder of a division. It is commonly used to check divisibility, such as determining whether a number is even or odd.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int x = 7;\n\n    if (x % 2 == 0) {\n        std::cout &lt;&lt; \"Number is even\";\n    } else {\n        std::cout &lt;&lt; \"Number is odd\";\n    }\n}\n</code></pre> output<pre><code>Number is odd\n</code></pre>"},{"location":"02%20Operators/#shortened-notations","title":"Shortened Notations","text":"<p>There are also shorthand notations that make coding more concise. Instead of writing full expressions like <code>a = a + b</code>, we can use compound assignment operators to simplify the syntax.</p> <p>For example, if we want to increase or multiply <code>a</code> by <code>b</code>, we can use the following shorthand notations:</p> Operator Description Equivalent Expression <code>+=</code> Adds and assigns <code>a = a + b</code> <code>-=</code> Subtracts and assigns <code>a = a - b</code> <code>*=</code> Multiplies and assigns <code>a = a * b</code> <code>/=</code> Divides and assigns <code>a = a / b</code> <code>%=</code> Remainder and assigns <code>a = a % b</code> <p>In addition to these, we have increment and decrement operators.</p> Operator Description Equivalent Expression <code>++</code> Increases a variable by <code>1</code> <code>a = a + 1</code> <code>--</code> Decreases a variable by <code>1</code> <code>a = a - 1</code> <p>Difference between postfix increment and prefix increment:</p> <ul> <li><code>++a</code> is the prefix increment: the variable is incremented first, then its new value is used in the expression.</li> <li><code>a++</code> is the postfix increment: the variable\u2019s current value is used first, and then it is incremented.</li> </ul> <p>For clarity, prefer using the prefix method when the previous value is not needed. In console outputs or function arguments, postfix can be misleading, as it will display or use the old value before incrementing.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10;\n    int b = 5;\n\n    a += b;\n    std::cout &lt;&lt; \"Number A after +=: \" &lt;&lt; a &lt;&lt; '\\n'; \n\n    a *= 2;\n    std::cout &lt;&lt; \"Number A after *=: \" &lt;&lt; a &lt;&lt; '\\n';\n\n    a++;\n    std::cout &lt;&lt; \"Number A after ++: \" &lt;&lt; a++;\n}\n</code></pre> output<pre><code>Number A after +=: 15\nNumber A after *=: 30\nNumber A after ++: 31\n</code></pre>"},{"location":"02%20Operators/#operator-evaluation-order","title":"Operator Evaluation Order","text":"<p>When working with operators in C++, understanding how they are evaluated is crucial to avoid unexpected behavior. Operator evaluation determines the order in which operations are performed and how expressions are processed.</p> <p>C++ follows a set of rules to decide which operators take precedence over others in an expression. These rules dictate whether multiplication happens before addition, or how logical and comparison operators interact.</p> Term Definition Operator precedence Defines which operator is evaluated first in an expression. Operator associativity Determines the order of evaluation when multiple operators of the same precedence appear in an expression. <p>Note</p> <p>Arithmetic operators follow standard mathematical rules: multiplication and division are evaluated before addition and subtraction, and expressions inside parentheses are evaluated always first.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nbool first() {\n    std::cout &lt;&lt; \"First\\n\";\n    return false;\n}\n\nbool second() {\n    std::cout &lt;&lt; \"Second\\n\";\n    return true;\n}\n\nint main() {\n    if (first() &amp;&amp; second()) {\n    }\n}\n</code></pre> output<pre><code>First\n</code></pre> <p>The output remains unchanged because the <code>if</code> statement uses the logical AND operator, which evaluates conditions from left to right. Since <code>first()</code> returns <code>false</code>, the entire condition can never be true, so the second function is never called.</p> <p>Note</p> <p>This behavior is known as short-circuit evaluation.</p>"},{"location":"02%20Operators/#bitwise-operators","title":"Bitwise Operators","text":"<p>While arithmetic operators work with base-10 numbers, bitwise operators operate on numbers in base-2 (binary), manipulating each individual bit. A bit is the smallest unit of memory and can be either 0 or 1. This is because they operate on transistors, which have only two states: ON (1) or OFF (0). These bits are grouped into bytes, where 8 bits = 1 byte. A half byte (4 bits) is referred to as a nibble.</p>"},{"location":"02%20Operators/#binary-representation","title":"Binary Representation","text":"<p>As computers store values using binary (base-2), meaning unlike our familiar decimal (base-10) system, where numbers are represented using digits from 0 to 9, they can only use the numbers 0 and 1. </p> <p>Below is a comparison of base-10 numbers and their binary (base-2) equivalents.</p> Base 10 Base 2 0 0 1 1 2 10 3 11 4 100 5 101 <p>Each new bit (binary digit) doubles the range of representable numbers.</p> <p>Tip</p> <p>You can experiment with binary, hexadecimal, and other number representations using the Windows Calculator in Programmer mode.</p> <p>A 32-bit integer (regular <code>int</code>) storing the number <code>5</code> would be represented in memory like displayed below. <pre><code>0000 0101 | 0000 0000 | 0000 0000 | 0000 0000 \n</code></pre></p> <p>You might wonder why the number doesn\u2019t start from the right, as that might seem more intuitive. This depends on the endianness of your CPU. Most modern CPUs use little-endian ordering, meaning less significant bytes are stored at lower memory addresses, while more significant bytes are stored at higher addresses. If we were to compile the same program on a big-endian CPU, the memory layout would be reversed.</p> <pre><code>0000 0000 | 0000 0000 | 0000 0000 | 0000 0101\n</code></pre> <p>Endianness affects the order of bytes, not the order of bits within a byte, so you wouldn\u2019t see something like this for number <code>5</code>.</p> <pre><code>0000 0000 | 0000 0000 | 0000 0000 | 0101 0000\n</code></pre>"},{"location":"02%20Operators/#conversion-between-decimal-and-binary-systems","title":"Conversion Between Decimal and Binary Systems","text":"<p>To convert a decimal number into binary, we repeatedly divide the number by 2 until 0 is reached and keeping track of the remainders. The binary representation is formed by reading these remainders from bottom to top.</p> <p>For example, converting <code>5</code> from decimal to binary.</p> <pre><code>5 / 2 = 2 -&gt; reminder 1\n2 / 2 = 1 -&gt; reminder 0\n1 / 2 = 0 -&gt; reminder 1\n</code></pre> <p>Reading the remainders from bottom to top, <code>5</code> in decimal is <code>101</code> in binary.</p> <p>To convert a binary number into decimal, each position in the binary representation corresponds to a power of 2, starting from 2\u2070 at the rightmost bit. The decimal value is calculated by summing up these powers where 1s appear.</p> <p>For example, converting <code>101</code> from binary to decimal:</p> <pre><code>  1          0          1\n1 \u00d7 2\u00b2  +  0 \u00d7 2\u00b9  +  1 \u00d7 2\u2070\n  4     +    0     +    1    =  5\n</code></pre>"},{"location":"02%20Operators/#conversion-between-decimal-and-hexadecimal-systems","title":"Conversion Between Decimal and Hexadecimal Systems","text":"<p>To convert a decimal number into hexadecimal, we repeatedly divide the number by 16 until 0 is reached and keeping track of the remainders. The hexadecimal representation is then formed by reading these remainders from bottom to top.</p> <p>Hexadecimal uses digits <code>0\u20139</code> and letters <code>A\u2013F</code> to represent values from <code>0\u201315</code>.</p> <pre><code>0 1 2 3 4 5 6 7 8 9 A B C D E F\n</code></pre> <p>For example, converting <code>192</code> from decimal to hexadecimal:</p> <pre><code>192 / 16 = 12 -&gt; remainder  0 -&gt; 0\n12  / 16 =  0 -&gt; remainder 12 -&gt; C\n</code></pre> <p>Reading the remainders from bottom to top, <code>192</code> in decimal is <code>C0</code> in hexadecimal.</p> <p>To convert hexadecimal back into decimal, each digit is multiplied by a power of 16, starting from the rightmost digit (which is multiplied by 16\u2070).</p> <p>For example, converting <code>C0</code> from hexadecimal to decimal:</p> <pre><code>   C         0\n C \u00d7 16\u00b9 + 0 \u00d7 16\u2070\n12 \u00d7 16  + 0 \u00d7  1  = 192\n</code></pre>"},{"location":"02%20Operators/#conversion-between-decimal-and-octal-systems","title":"Conversion Between Decimal and Octal Systems","text":"<p>To convert a decimal number into octal, divide the number repeatedly by 8 until 0 is reached and keep track of the remainders. The octal number is then formed by reading the remainders from bottom to top.</p> <p>Octal is base-8, so it uses digits from <code>0</code> to <code>7</code>.</p> <p>For example, converting <code>65</code> from decimal to octal:</p> <pre><code>65 / 8 = 8 remainder 1\n8  / 8 = 1 remainder 0\n1  / 8 = 0 remainder 1\n</code></pre> <p>Reading the remainders from bottom to top, <code>65</code> in decimal is <code>101</code> in octal.</p> <p>To convert octal back to decimal, multiply each digit by a power of 8, starting from the rightmost digit (8\u2070).</p> <p>For example, converting <code>101</code> from octal to decimal:</p> <pre><code>  1        0        1\n1 \u00d7 8\u00b2 + 0 \u00d7 8\u00b9 + 1 \u00d7 8\u2070\n 64    +   0    +   1    = 65\n</code></pre>"},{"location":"02%20Operators/#examining-memory-representation-in-practice","title":"Examining Memory Representation in Practice","text":"<p>Now that we understand how binary works, we can examine how memory is structured using Visual Studio by writing a simple program. This examination was done in Visual Studio, but it can be performed in almost any code editor or IDE.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    std::cout &lt;&lt; a &lt;&lt; '\\n';\n}\n</code></pre> <p>When this simple script is pasted into your code editor or IDE, place a breakpoint at the highlighted line by clicking on the empty space to the left of the line number. This will pause the program at that exact point, right after the variable declaration, allowing us to inspect memory.</p> <p>Run the program, and you\u2019ll see it pause. Then, in the top utility bar, navigate to Debug \u2192 Windows \u2192 Memory \u2192 Memory 1. This will open a memory panel where you\u2019ll find an address search field. Enter <code>&amp;a</code> to jump to the memory address where the variable is stored.</p> <p>At this memory location, you\u2019ll see our number 5, but instead of just 0s and 1s, you\u2019ll also notice characters like <code>F</code> and <code>B</code>. That\u2019s because memory is displayed using hexadecimal system instead of binary.</p> <p>Using pure binary would be inefficient for reading and searching, as long sequences of 0s and 1s are hard to interpret. Hexadecimal is useful because it aligns perfectly with binary, each hex digit represents exactly 4 bits, meaning two hex digits make up one byte. This significantly shortens binary representation.</p> <pre><code>   0    5 |    0    0 |    0    0 |    0    0\n0000 0101 | 0000 0000 | 0000 0000 | 0000 0000 \n</code></pre> <p>For comparison, in decimal, 8 bits can represent values up to 255, requiring three digits. In hexadecimal, however, <code>255</code> is simply <code>FF</code>, retaining the one hex digit per 4 bits rule. This makes hexadecimal more efficient for representing memory values.</p> <p>While these concepts primarily apply to integers, they can also be used with floating-point numbers. However, working with floats at the binary level requires specifying the correct data type to interpret the stored bits correctly. In most cases, though, bitwise operations are used with integers only.</p>"},{"location":"02%20Operators/#bitwise-shift-operators","title":"Bitwise Shift Operators","text":"<p>Shift operators are simple and intuitive they move the bits within a number by one to the left or the right, effectively doubling or halving the value.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int b = 7;\n\n    a &lt;&lt;= 2;\n    b &gt;&gt;= 2;\n\n    std::cout &lt;&lt; \"Number A: \" &lt;&lt; a &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number B: \" &lt;&lt; b;\n}\n</code></pre> output<pre><code>Number A: 20\nNumber B: 1\n</code></pre> explanation<pre><code>&lt;&lt;2 0101 = 5     \n--------\n  010100 = 20\n\n\n&gt;&gt;2 0111 = 7\n--------\n      01 = 1\n</code></pre> <p>In the examples, we can see that when a bit shifts out of scope, it is replaced with a zero on the opposite side of the shift direction.</p> <p>Note</p> <p>It is not necessary to use bit shifting instead of multiplying normally because the compiler is smart. When normal multiplication is involved and optimization is possible, the compiler will use the bit-shifting method automatically. Therefore, it is better to keep the code simple, understandable, and readable.</p>"},{"location":"02%20Operators/#bitwise-logic-operators","title":"Bitwise Logic Operators","text":"<p>Similar to regular logical operators that compare two variables, bitwise logic operators operate directly on individual bits and compare them between each other. Each logical operation can be described using a truth table.</p>"},{"location":"02%20Operators/#bitwise-and","title":"Bitwise AND","text":"<p>Bitwise AND (<code>&amp;</code>) is used for masking and isolating specific bits. This is exactly what happens, for example, in IPv4 networking when masks are used to separate the network and host portions of an address.</p> A B AND 0 0 0 0 1 0 1 0 0 1 1 1 main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int b = 13;\n    a &amp;= b;\n\n    std::cout &lt;&lt; \"Number A: \" &lt;&lt; a;\n}\n</code></pre> output<pre><code>Number A: 5\n</code></pre> explanation<pre><code>  0101   = 5\n&amp; 1101   = 13\n--------\n  0101   = 5\n</code></pre> <p>Let\u2019s go through how masking works using the bitwise AND operator. We\u2019ll use the example of a private IPv4 address: <code>192.168.0.10</code> with a <code>/24</code> prefix. </p> <p>If you have no background in networking, don\u2019t worry \u2014 we\u2019ll briefly explain what\u2019s going on.</p> <p>The address is a 32-bit number, divided into 4 octets separated by dots. It represents the address of a host device, such as a laptop.</p> <p>The prefix (in this case <code>/24</code>) indicates how many bits belong to the network part of the address.</p> explanation<pre><code>  1100 0000 . 1010 1000 . 0000 0000 . 0000 1010 = 192.168.0.10  -&gt; host address\n&amp; 1111 1111 . 1111 1111 . 1111 1111 . 0000 0000 = 255.255.255.0 -&gt; prefix /24\n  ---------------------------------------------\n  1100 0000 . 1010 1000 . 0000 0000 . 0000 0000 = 192.168.0.0   -&gt; network address\n</code></pre> <p>This way, we can determine which network the IP address belongs to and how many bits remain for identifying host devices within that network.</p> <p>In our example, the <code>/24</code> prefix means that the first 24 bits (3 full octets) are used to identify the network, while the remaining 8 bits are reserved for host addresses. That gives us:</p> Type Address Network address <code>192.168.0.0</code> Range of host addresses <code>192.168.0.1</code> to <code>192.168.0.254</code> Broadcast address <code>192.168.0.255</code> <p>This technique of using a bitmask (in this case, <code>255.255.255.0</code>) allows computers and routers to efficiently determine whether two IP addresses are part of the same network, which is essential for routing traffic.</p>"},{"location":"02%20Operators/#bitwise-or","title":"Bitwise OR","text":"<p>Bitwise OR (<code>|</code>) is used for setting and combining bits. It\u2019s helpful when you want to ensure that certain bits are turned on (set to 1) without affecting the others.</p> A B OR 0 0 0 0 1 1 1 0 1 1 1 1 main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int b = 13;\n    a |= b;\n\n    std::cout &lt;&lt; \"Number A: \" &lt;&lt; a;\n}\n</code></pre> output<pre><code>Number A: 13\n</code></pre> explanation<pre><code>  0101   = 5\n| 1101   = 13\n--------\n  1101   = 13\n</code></pre> <p>With bitwise OR in combination with a bitwise left shift (<code>&lt;&lt;</code>), we can reconstruct a number after part of it was masked using a bitwise AND. This is particularly useful in low-level programming tasks like restoring structured binary data, combining partial values, or decoding packed data fields.</p> <p>The idea is that if you previously split a number into two parts \u2014 for example, by masking the lower bits and extracting the upper bits \u2014 you can later restore the original by placing the upper part back into its correct position (via shifting) and using <code>|</code> to merge both parts.</p> explanation<pre><code>      00000101             -&gt; Lower 4 bits (e.g., extracted via AND)\n&lt;&lt; 4  10110000             -&gt; Shift upper 4 bits back into place\n--------------\n      10110000\n|     00000101             -&gt; Combine both with OR\n--------------\n      10110101             -&gt; Reconstructed original value\n</code></pre>"},{"location":"02%20Operators/#bitwise-xor","title":"Bitwise XOR","text":"<p>Bitwise XOR (<code>^</code>) is commonly used in low-level programming for toggling bits, clearing flags, and also in more advanced applications like encryption, checksums, and hashing.</p> A B XOR 0 0 0 0 1 1 1 0 1 1 1 0 main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int b = 13;\n    a ^= b;\n\n    std::cout &lt;&lt; \"Number A: \" &lt;&lt; a; \n}\n</code></pre> output<pre><code>Number A: 8\n</code></pre> explanation<pre><code>  0101  = 5\n^ 1101  = 13\n------\n  1000  = 8\n</code></pre> <p>An interesting property of XOR is that when a number is XORed with itself, the result is always zero.</p> <p>Another powerful aspect of XOR is its reversibility, if you XOR a number with another value and then XOR the result with the same value again, you get back the original number. This enables swapping values without a temporary variable.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int b = 13;\n\n    std::cout &lt;&lt; \"Before swap: a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt; '\\n';\n\n    a ^= b;\n    b ^= a;\n    a ^= b;\n\n    std::cout &lt;&lt; \"After swap:  a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b;\n}\n</code></pre> output<pre><code>Before swap: a = 5, b = 13\nAfter swap:  a = 13, b = 5\n</code></pre> explanation<pre><code>  0101  = 5\n^ 1101  = 13\n------\n  1000  = 8   -&gt; new value of 'a'\n^ 1101  = 13\n------\n  0101  = 5   -&gt; new value of 'b'\n^ 1000  = 8\n------\n  1101  = 13  -&gt; new value of 'a'\n</code></pre>"},{"location":"02%20Operators/#bitwise-not","title":"Bitwise NOT","text":"<p>Bitwise NOT (<code>~</code>) is used to invert all bits in a number.</p> A NOT 0 1 1 0 main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    std::cout &lt;&lt; \"Original: \" &lt;&lt; std::bitset&lt;4&gt;(a) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Inverted: \" &lt;&lt; std::bitset&lt;4&gt;(~a);\n}\n</code></pre> output<pre><code>Original: 0101\nInverted: 1010\n</code></pre> explanation<pre><code>~ 0101  = 5\n------\n  1010  = 10\n</code></pre>"},{"location":"02%20Operators/#writing-binary-hexadecimal-and-octal-values-in-c","title":"Writing Binary, Hexadecimal and Octal Values in C++","text":"<p>We covered an introduction to binary number representation and how bitwise operators manipulate individual bits. So far, we\u2019ve used integers assigned through the decimal system, but it\u2019s also possible to assign values directly using binary, hexadecimal, or even octal notation. This is done by prefixing the number with <code>0b</code> for binary, <code>0x</code> for hexadecimal, or a leading <code>0</code> for octal, followed by the appropriate value.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 0b0101;\n    int b = 0xff;\n    int c = 015;\n\n    std::cout &lt;&lt; \"Number A: \" &lt;&lt; a &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number B: \" &lt;&lt; b &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number C: \" &lt;&lt; c;\n}\n</code></pre> output<pre><code>Number A: 5\nNumber B: 255\nNumber C: 13\n</code></pre> <p>This can also be done in reverse, we can assign values using decimal numbers and output their binary, hexadecimal, and octal representations. However, for the binary representation, we will need the <code>&lt;bitset&gt;</code> header file.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n\nint main() {\n    int a = 5;\n    int b = 13;\n\n    std::cout &lt;&lt; \"Decimal: \"   &lt;&lt; a\n              &lt;&lt; \" | Binary: \" &lt;&lt; std::bitset&lt;4&gt;(a)\n              &lt;&lt; \" | Hex: \"    &lt;&lt; std::hex &lt;&lt; a\n              &lt;&lt; \" | Octal: \"  &lt;&lt; std::oct &lt;&lt; a &lt;&lt; std::dec &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Decimal: \"   &lt;&lt; b\n              &lt;&lt; \" | Binary: \" &lt;&lt; std::bitset&lt;4&gt;(b)\n              &lt;&lt; \" | Hex: \"    &lt;&lt; std::hex &lt;&lt; b\n              &lt;&lt; \" | Octal: \"  &lt;&lt; std::oct &lt;&lt; b &lt;&lt; std::dec;\n}\n</code></pre> output<pre><code>Decimal: 5 | Binary: 0101 | Hex: 5 | Octal: 5\nDecimal: 13 | Binary: 1101 | Hex: d | Octal: 15\n</code></pre> <p>The new function used here is <code>std::bitset&lt;T&gt;(int)</code>, which converts an integer into its binary representation as a string. Replace <code>T</code> with the number of bits you want to display, and provide the integer value as the argument.</p> <p>For hexadecimal output, we use <code>std::hex</code>, which tells the stream to display numbers in base 16. Similarly, <code>std::oct</code> is used for base 8 representation.</p> <p>Warning</p> <p>Remember to reset the output stream back to decimal using <code>std::dec</code>, as the formatting change is persistent. If you don\u2019t reset it, the program will continue printing numbers in the last format you set.</p>"},{"location":"02%20Operators/#ternary-operator","title":"Ternary Operator","text":"<p>The ternary operator is a shorthand for an <code>if-else</code> statement, often called an inline if statement. It provides a more concise way to express simple conditional expressions.</p> <p>It uses the <code>?</code> operator to check a condition and the <code>:</code> operator to separate the two possible results (true case : false case).</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int number = 5;\n\n    if (number % 2 == 0) {\n        std::cout &lt;&lt; \"number is even\\n\";\n    } else {\n        std::cout &lt;&lt; \"number is odd\\n\";\n    }\n\n    number % 2 == 0 ? std::cout &lt;&lt; \"number is even\\n\"\n                    : std::cout &lt;&lt; \"number is odd\\n\";\n}\n</code></pre> output<pre><code>number is odd\nnumber is odd\n</code></pre>"},{"location":"02%20Operators/#operator-overloading","title":"Operator Overloading","text":"<p>Info</p> <p>This section is considered more advanced at this point, as it requires knowledge of functions and user-defined types. If you're not yet comfortable with those concepts, feel free to skip this section and return to it later once you're more confident.</p> <p>Behind the scenes, operators are just functions. Much like functions, they can also be overloaded\u2014that is, given custom behavior for specific types.</p> <p>This can be useful when working with custom data structures like vectors, matrices, or complex numbers. For instance, if you create a class representing a 3D vector, it would be convenient to use <code>+</code> to add two vectors together, rather than calling a member function like <code>add()</code> manually.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Vector3 {\npublic:\n    Vector3(double x, double y, double z)\n        : x_(x), y_(y), z_(z) {}\n\n    Vector3 operator+(const Vector3&amp; other) const {\n        return Vector3(x_ + other.x_, y_ + other.y_, z_ + other.z_);\n    }\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector3&amp; v) {\n        os &lt;&lt; \"(\" &lt;&lt; v.x_ &lt;&lt; \", \" &lt;&lt; v.y_ &lt;&lt; \", \" &lt;&lt; v.z_ &lt;&lt; \")\";\n        return os;\n    }\n\nprivate:\n    double x_;\n    double y_;\n    double z_;\n};\n\nint main() {\n    Vector3 position(13.22, 51.79, 73.46);\n    Vector3 speed(54.87, 91.37, 65.87);\n\n    Vector3 result = position + speed;\n\n    std::cout &lt;&lt; \"Resulting vector: \" &lt;&lt; result &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Resulting vector: (68.09, 143.16, 139.33)\n</code></pre> <p>Operator overloading can make code more intuitive and expressive, but it should be used with care.</p> <p>Warning</p> <p>Only overload operators when it makes logical sense. For example, overloading <code>+</code> for vectors or <code>==</code> for custom types is clear and intuitive. Overloading <code>++</code> or <code>!</code> for unrelated classes, on the other hand, can make code confusing.</p>"},{"location":"02%20Operators/#questions","title":"Questions","text":"question 1answer <p>Name the six basic comparison operators in C++.</p> <p><code>&gt;</code> , <code>&lt;</code> , <code>&gt;=</code> , <code>&lt;=</code> , <code>==</code> , <code>!=</code></p> question 2answer <p>What is the difference between the <code>&amp;&amp;</code> and <code>||</code> logical operators?</p> <p><code>&amp;&amp;</code> (AND) is true only if both conditions are true. <code>||</code> (OR) is true if at least one condition is true.</p> question 3answer <p>How does integer division differ from floating-point division in C++?</p> <p>Integer division discards any decimal part, while floating-point division retains decimals if at least one operand is a floating-point number.</p> question 4answer <p>Which operator is used to find the remainder of an integer division?</p> <p>The modulus operator</p> question 5answer <p>What is the difference between <code>a++</code> and <code>++a</code>?</p> <p><code>a++</code> is the postfix increment: the current value of <code>a</code> is used first, then it is incremented. <code>++a</code> is the prefix increment: <code>a</code> is incremented first, then the new value is used.</p> question 6answer <p>What is operator precedence?</p> <p>Operator precedence defines the order in which operators are evaluated in an expression.</p> question 7answer <p>What does short-circuit evaluation mean?</p> <p>In logical expressions, evaluation stops as soon as the result is determined. For example, in <code>false &amp;&amp; expr</code>, <code>expr</code> is never evaluated.</p> question 8answer <p>Name the six main bitwise operators in C++.</p> <p>AND (<code>&amp;</code>), OR (<code>|</code>), XOR (<code>^</code>), NOT (<code>~</code>), left shift (<code>&lt;&lt;</code>), right shift (<code>&gt;&gt;</code>)</p> question 9answer <p>What is the ternary operator and how does it work?</p> <p>The ternary operator <code>? :</code> is a shorthand for <code>if-else</code>. Syntax: <code>condition ? expression_if_true : expression_if_false</code>.</p>"},{"location":"02%20Operators/#exercises","title":"Exercises","text":"exercise 1answer <p>Write a program that asks the user for two doubles and prints their sum, difference, product, and quotient.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    double a;\n    double b;\n\n    std::cout &lt;&lt; \"Enter first number: \";\n    std::cin &gt;&gt; a;\n\n    std::cout &lt;&lt; \"Enter second number: \";\n    std::cin &gt;&gt; b;\n\n    std::cout &lt;&lt; \"Their sum is: \" &lt;&lt; a + b &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Their difference is: \" &lt;&lt; a - b &lt;&lt; '\\n'; \n    std::cout &lt;&lt; \"Their product is: \" &lt;&lt; a * b &lt;&lt; '\\n';\n\n    if (b != 0) {\n        std::cout &lt;&lt; \"Their quotient is: \" &lt;&lt; a / b;\n    } else {\n        std::cout &lt;&lt; \"Cannot divide by zero!\";\n    }\n}\n</code></pre> exercise 2answer <p>Write a program that asks the user for an integer and prints whether it is divisible by both 3 and 5.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int number;\n\n    std::cout &lt;&lt; \"Enter a number: \";\n    std::cin &gt;&gt; number;\n\n    if (number % 3 == 0 &amp;&amp; number % 5 == 0) {\n        std::cout &lt;&lt; \"Number is divisible by both 3 and 5.\";\n    } else {\n        std::cout &lt;&lt; \"Number is not divisible by both 3 and 5.\";\n    }\n}\n</code></pre> exercise 3answer <p>Write a program that reads an integer and prints its square and cube using arithmetic operators.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int number;\n\n    std::cout &lt;&lt; \"Enter a number: \";\n    std::cin &gt;&gt; number;\n\n    std::cout &lt;&lt; \"Square of the number is \" &lt;&lt; number * number &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Cube of the number is \" &lt;&lt; number * number * number;\n}\n</code></pre> question 4answer <p>Write a program that reads two integers and uses bitwise operators to print their AND, OR, XOR, and NOT results.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a;\n    int b;\n\n    std::cout &lt;&lt; \"Enter first number: \";\n    std::cin &gt;&gt; a;\n\n    std::cout &lt;&lt; \"Enter second number: \";\n    std::cin &gt;&gt; b;\n\n    std::cout &lt;&lt; \"Bitwise AND: \" &lt;&lt; (a &amp; b) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Bitwise OR: \" &lt;&lt; (a | b) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Bitwise XOR: \" &lt;&lt; (a ^ b) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Bitwise NOT of a: \" &lt;&lt; ~a &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Bitwise NOT of b: \" &lt;&lt; ~b;\n}\n</code></pre>"},{"location":"03%20Control%20Flow/","title":"03 Control Flow","text":"<p>Info</p> <p>This chapter goes hand in hand with the 02 Operators/ chapter. So keep in mind that the two chapters are closely related, and many concepts work together. If something seems skipped here, it's likely because it was better suited for that chapter.</p> <p>There always comes a point when our code needs to branch out \u2014 meaning we only want certain actions to happen if specific conditions are met.</p> <p>For example, in a game, we might want to restrict access to certain areas for low-level players to keep beginner zones separate from tougher ones. Or maybe a quest can only be completed if the player has a specific item. These decisions depend on conditions \u2014 and the possibilities are endless. It can also be used to check for errors \u2014 something we'll explore more deeply in the chapter focused on error handling.</p> <p>We manage this kind of behavior using control flow statements, which let us check a condition and decide what happens based on whether it\u2019s true or false. Think of them as checkpoints in your code: Before moving forward, the program asks if the condition is true. If it is, the code inside the check runs; otherwise, it is skipped.</p>"},{"location":"03%20Control%20Flow/#if-statements","title":"If Statements","text":"<p>The most basic and essential control flow tool in programming is the <code>if</code> statement. It does exactly what it sounds like: it checks a condition and decides what to do based on the result.</p> <p>The condition is written inside parentheses immediately following the <code>if</code> keyword. We typically use comparison and logical operators to form this condition \u2014 it must evaluate to either <code>true</code> or <code>false</code>.</p> <p>If the condition is <code>true</code>, the code inside the curly braces (called the statement body, block, or scope) will execute. If the condition is <code>false</code>, that block is skipped.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    bool player_has_item = true;\n\n    if (player_has_item) {\n        std::cout &lt;&lt; \"Quest Completed!\\n\";\n    }\n}\n</code></pre> output<pre><code>Quest Completed!\n</code></pre> <p>It\u2019s also possible to extend an <code>if</code> statement with two additional keywords to form a complete conditional structure.</p> <p>The first is <code>else if</code>, which allows us to check another condition if the original if condition wasn\u2019t met. For example, if a player level is too low, the first condition will block them from entering. But with <code>else if</code>, we can also check if the player level is too high for a specific zone \u2014 and handle that differently, such as temporarily reducing their level or showing a warning.</p> <p>The final piece is <code>else</code>, which does not take a condition. It acts as a fallback: if none of the previous conditions were met, the code inside the else block will execute.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int player_level = 42;\n\n    if (player_level &lt; 20) {\n        std::cout &lt;&lt; \"Your level is too low to enter this zone.\\n\";\n    } else if (player_level &gt; 80) {\n        std::cout &lt;&lt; \"You are overleveled for this area! Your level will be capped at 80.\\n\";\n    } else {\n        std::cout &lt;&lt; \"You\u2019ve entered the zone. Good luck, adventurer!\\n\";\n    }\n}\n</code></pre> output<pre><code>You\u2019ve entered the zone. Good luck, adventurer!\n</code></pre>"},{"location":"03%20Control%20Flow/#switch-statements","title":"Switch Statements","text":"<p>When we need to compare a variable against several fixed values, writing a long chain of if-else statements can get messy and harder to read. In these situations, a <code>switch</code> statement offers a cleaner and often more efficient alternative.</p> <p>One reason <code>switch</code> can be faster is that many compilers optimize it using a jump table, allowing the program to instantly jump to the matching case without checking each condition one by one.</p> <p>Also, unlike an <code>if</code> statement, a <code>switch</code> doesn\u2019t evaluate full conditions inside its parentheses. Instead, it works with a single variable and checks its value against several predefined options, known as cases.</p> <p>You place the variable you want to match inside the parentheses of the <code>switch</code> statement, then list the possible values using <code>case</code> followed by each specific value. After each case, you write the code that should run when that value matches. Each case typically ends with a <code>break</code> to prevent the program from unintentionally continuing into the next case. If none of the cases match, you can include a <code>default</code> case at the end to handle all other values.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main()  {\n    char grade = 'C';\n\n    switch (grade) {\n        case 'A': \n            std::cout &lt;&lt; \"Excellent!\\n\";\n            break;\n        case 'B': \n            std::cout &lt;&lt; \"Good job!\\n\";\n            break;\n        case 'C': \n            std::cout &lt;&lt; \"You passed.\\n\";\n            break;\n        case 'D': \n            std::cout &lt;&lt; \"You should work harder.\\n\";\n            break;\n        case 'F': \n            std::cout &lt;&lt; \"You failed.\\n\";\n            break;\n        default:\n            std::cout &lt;&lt; \"Invalid grade.\\n\";\n    }\n}\n</code></pre> output<pre><code>You passed.\n</code></pre> <p>Note</p> <p>The values a <code>switch</code> statement can match against must be integer types, such as <code>int</code> or <code>char</code>. Whole strings (text) cannot be used directly.</p> <p>In a <code>switch</code> statement, leaving out the <code>break</code> between cases causes what's called a fallthrough\u2014the execution \"falls through\" to the next case until it encounters a break or reaches the end of the <code>switch</code>. This can be intentional and useful when multiple cases should trigger the same behavior, like grouping <code>'A'</code>, <code>'B'</code>, and <code>'C'</code> to all print the same thing. However, be careful: unintentional fallthroughs can lead to bugs, and since the compiler doesn\u2019t always warn you, they can be tricky to catch.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main()  {\n    char grade = 'A';\n\n    switch (grade) {\n        case 'A':\n        case 'B':\n        case 'C': \n            std::cout &lt;&lt; \"You passed.\\n\";\n            break;\n        case 'D': \n            std::cout &lt;&lt; \"You should work harder.\\n\";\n            break;\n        case 'F': \n            std::cout &lt;&lt; \"You failed.\\n\";\n            break;\n        default:\n            std::cout &lt;&lt; \"Invalid grade.\\n\";\n    }\n}\n</code></pre> output<pre><code>You passed.\n</code></pre>"},{"location":"03%20Control%20Flow/#go-to-statements","title":"Go To Statements","text":"<p>The <code>goto</code> statement is a control flow mechanism that allows you to jump to a labeled part of the code. While it does exist in C++, it's generally discouraged because it can make your code harder to read, understand, and maintain. Introducing arbitrary jumps in the program breaks the natural, structured flow of execution and often leads to what's known as \u201cspaghetti code.\u201d</p> <p>There are very few legitimate use cases for <code>goto</code>, such as breaking out of deeply nested loops or handling errors in older codebases, but in modern C++, there are almost always better alternatives. In short: avoid using goto unless absolutely necessary \u2014 and in most cases, it won\u2019t be.</p> example<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value;\n\nstart:\n\n    std::cout &lt;&lt; \"Enter a number (0 to exit): \";\n    std::cin &gt;&gt; value;\n\n    if (value == 0) {\n        goto end;\n    }\n\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; value &lt;&lt; '\\n';\n\n    goto start;\n\nend:\n\n    std::cout &lt;&lt; \"Program ended.\\n\";\n}\n</code></pre> <p>In the example, it's easy to see how using <code>goto</code> makes the code feel awkward and harder to follow. It introduces an unnatural jump in the program\u2019s flow, which hurts readability \u2014 especially in larger projects.</p> <p>Whenever you find yourself reaching for <code>goto</code>, it\u2019s usually a sign that the code structure should be rethought. There's almost always a cleaner alternative.</p>"},{"location":"03%20Control%20Flow/#loops","title":"Loops","text":"<p>One of the most common challenges in programming is how to repeat a task multiple times without writing the same code over and over again.</p> <p>Sure, if we need to print a message a hundred times, we could write the same line of code a hundred times \u2014 but that would be tedious, error-prone, and completely impractical. And for example, what if we want to keep displaying something endlessly until the user closes the program, writing it out manually just isn\u2019t an option.</p> <p>Loops let us repeat a block of code as long as a certain condition is met, making repetitive tasks much cleaner and easier to manage.</p>"},{"location":"03%20Control%20Flow/#while-loops","title":"While Loops","text":"<p>The simplest type of loop in C++ is the <code>while</code> loop. It works similarly to an <code>if</code> statement, but instead of running just once, it repeatedly executes the code block as long as the condition remains true. This loop is especially useful when you don\u2019t know in advance how many times a task needs to be repeated\u2014for example, reading a password from a user or processing lines in a file where the total number of lines isn\u2019t known.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    while (true) {\n        std::cout &lt;&lt; \"Hello World!\\n\";\n    }\n}\n</code></pre> output<pre><code>Hello World!\nHello World!\nHello World!\nHello World!\nHello World!\n...\n</code></pre> <p>In this example, the condition is checked before each loop iteration. As long as the condition is <code>true</code>, the code inside the block continues to run. Since <code>true</code> never becomes <code>false</code>, this creates an infinite loop.</p> <p>There\u2019s also a variation called the do-while loop, where the code block is executed at least once, and the condition is checked afterward. It\u2019s essentially an inverted while loop that guarantees the code executes at least once before the condition is checked.</p> example<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value;\n\n    do {\n        std::cout &lt;&lt; \"Enter number: \";\n        std::cin &gt;&gt; value;\n    } while (value &gt; 0);\n\n    std::cout &lt;&lt; \"Program ended.\\n\";\n}\n</code></pre> <p>As you can see, the condition in a <code>while</code> loop or do-while loop can be more complex than just a single variable or value, similar to an <code>if</code> statement. It can also involve expressions that evaluate to <code>true</code> or <code>false</code>.</p>"},{"location":"03%20Control%20Flow/#for-loops","title":"For Loops","text":"<p>When we don\u2019t know how many times a process should repeat\u2014because it depends on user input, external conditions, or when the program is closed\u2014we use a while loop. On the other hand, when we do know exactly how many times we want to repeat a process, a for loop is a cleaner and more concise choice.</p> <p>For example, if we want to print numbers from 1 to 10, a for loop is ideal. A for loop consists of three parts.</p> # Part Description 1 Initialization Sets the starting value of the loop variable. 2 Condition Defines when the loop should stop executing. 3 Increment/Decrement Controls how the loop variable changes after each iteration. <p>Because all three parts are combined in the loop header, a <code>for</code> loop keeps your code compact and easy to read, especially when the number of repetitions is fixed or known ahead of time.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    for (int i = 1; i &lt;= 10; ++i) {\n        std::cout &lt;&lt; i &lt;&lt; ' ';\n    }\n}\n</code></pre> output<pre><code>1 2 3 4 5 6 7 8 9 10\n</code></pre>"},{"location":"03%20Control%20Flow/#nested-loops","title":"Nested Loops","text":"<p>Sometimes you\u2019ll need to repeat a loop inside another loop \u2014 this is called a nested loop. Each iteration of the outer loop runs the entire inner loop. This is useful for working with multi-dimensional data or creating patterns.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int rows = 5;\n\n    for (int i = 1; i &lt;= rows; ++i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            std::cout &lt;&lt; \"* \";\n        }\n        std::cout &lt;&lt; '\\n';\n    }\n}\n</code></pre> output<pre><code>* \n* * \n* * * \n* * * * \n* * * * * \n</code></pre> <p>Warning</p> <p>Always use a different variable name for the inner loop. If the inner and outer loops share the same variable, it can cause unexpected behavior and logic errors.</p>"},{"location":"03%20Control%20Flow/#break-and-continue","title":"Break and Continue","text":"<p>Control flow inside loops can be further refined with the <code>break</code> and <code>continue</code> statements.</p> Keyword Description <code>break</code> Immediately exits the loop, skipping all remaining iterations. <code>continue</code> Skips the current iteration and jumps to the next one. <p>These are helpful to control loop execution without complicating conditions. </p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    for (int i = 1; i &lt;= 10; ++i) {\n        // Exit loop when i is 5\n        if (i == 5) {\n            break;\n        }\n\n        // Skip even numbers\n        if (i % 2 == 0) {\n            continue;\n        }\n\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n    }\n}\n</code></pre> output<pre><code>1 3 \n</code></pre>"},{"location":"03%20Control%20Flow/#shortened-notations","title":"Shortened Notations","text":"<p>These statements we went trough follow the same pattern and therefore this applies to all of them. And that is that they can also be written without curly braces when they contain only a single line of the code inside of the body.</p> example<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int count = 1;\n\n    // While loop without braces\n    while (count &lt;= 5)\n        std::cout &lt;&lt; count++ &lt;&lt; \" \";\n\n    std::cout &lt;&lt; '\\n';\n\n    // For loop without braces\n    for (int i = 1; i &lt;= 10; ++i)\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n\n    std::cout &lt;&lt; '\\n';\n\n    int x = 3;\n\n    // If statement without braces\n    if (x &gt; 0)\n        std::cout &lt;&lt; \"x is positive\\n\";\n}\n</code></pre> output<pre><code>1 2 3 4 5 \n1 2 3 4 5 6 7 8 9 10 \nx is positive\n</code></pre> <p>Warning</p> <p>While shortened notations can make the code look cleaner, it\u2019s always preferred to use curly braces. Omitting them can lead to subtle bugs, especially when a statement you intended to execute doesn\u2019t actually run.</p>"},{"location":"03%20Control%20Flow/#questions","title":"Questions","text":"question 1answer <p>What is the purpose of an <code>if</code> statement?</p> <p>To check a condition and execute a block of code only if the condition evaluates to <code>true</code>.</p> question 2answer <p>How do <code>else if</code> and <code>else</code> extend the functionality of an <code>if</code> statement?</p> <p><code>else if</code> allows checking additional conditions if the first <code>if</code> is false, while <code>else</code> provides a fallback block when none of the previous conditions are met.</p> question 3answer <p>When is a <code>switch</code> statement more appropriate than an <code>if-else</code> chain?</p> <p>When comparing a single variable against multiple fixed values, as it is cleaner and often more efficient than a long chain of <code>if-else</code> statements.</p> question 4answer <p>What is the purpose of the <code>break</code> statement inside a <code>switch</code> or a loop?</p> <p>To immediately exit the <code>switch</code> or loop, preventing further execution of subsequent cases or iterations.</p> question 5answer <p>What does the <code>continue</code> statement do in a loop?</p> <p>It skips the rest of the current iteration and proceeds directly to the next iteration of the loop.</p> question 6answer <p>Why is using <code>goto</code> generally discouraged in modern C++?</p> <p>Because it breaks structured control flow, making code harder to read, maintain, and debug, often leading to \u201cspaghetti code.\u201d</p> question 7answer <p>What is the difference between a <code>while</code> loop and a <code>do-while</code> loop?</p> <p>A <code>while</code> loop checks its condition before each iteration, so it may not run at all, whereas a <code>do-while</code> loop executes the block at least once and checks the condition afterward.</p> question 8answer <p>What are the three parts of a <code>for</code> loop header?</p> <ol> <li>Initialization: Sets the starting value of the loop variable.</li> <li>Condition: Determines when the loop should stop.</li> <li>Increment/Decrement: Updates the loop variable after each iteration.</li> </ol> question 9answer <p>When is it safe to omit curly braces in control flow statements?</p> <p>Only when the body contains a single statement, but it is generally recommended to always use braces to avoid subtle bugs.</p>"},{"location":"03%20Control%20Flow/#exercises","title":"Exercises","text":"exercise 1answer <p>Write a program that asks the user to enter an integer. Use an if-else statement to determine whether the number is even or odd. For each case, print an appropriate message.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int number;\n\n    std::cout &lt;&lt; \"Enter an integer: \";\n    std::cin &gt;&gt; number;\n\n    if (number % 2 == 0) {\n        std::cout &lt;&lt; \"Number is even\" &lt;&lt; '\\n';\n    } else {\n        std::cout &lt;&lt; \"Number is odd\" &lt;&lt; '\\n';\n    }\n}\n</code></pre> exercise 2answer <p>Write a program that counts down and prints the numbers from 10 to 1 using a for loop. Skip the number 5, and stop the loop entirely when the number reaches 2.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    for (int i = 10; i &gt;= 1; --i) {\n        if (i == 5) {\n            continue;\n        }\n\n        if (i == 2) {\n            break;\n        }\n\n        std::cout &lt;&lt; i &lt;&lt; ' ';\n    }\n}\n</code></pre> exercise 3answer <p>Write a program that prints a 5 \u00d7 5 square made of <code>#</code> characters. Skip the third row entirely so that it appears as a blank line in the output.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    for (int i = 0; i &lt; 5; ++i) {\n        if (i == 2) {\n            std::cout &lt;&lt; '\\n';\n            continue;\n        }\n\n        for (int j = 0; j &lt; 5; ++j) {\n            std::cout &lt;&lt; \"# \";\n        }\n\n        std::cout &lt;&lt; '\\n';\n    }\n}\n</code></pre> exercise 4answer <p>Write a program that asks the user for an integer <code>n</code>, then prints a reversed pyramid of @ characters. The first row should contain <code>n</code> symbols, and each subsequent row should have one fewer.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int n;\n\n    std::cout &lt;&lt; \"Enter an integer: \";\n    std::cin &gt;&gt; n;\n\n    for (int i = n; i &gt; 0; --i) {\n        for (int j = i; j &gt; 0; --j) {\n            std::cout &lt;&lt; \"@ \";\n        }\n\n        std::cout &lt;&lt; '\\n';\n    }\n}\n</code></pre> exercise 5hintanswer <p>Write a program that repeatedly asks the user to enter an odd number between 1 and 15 until a valid number is entered. Then, draw a star pattern made of <code>*</code> characters with the size specified by the user.</p> example input<pre><code>5\n</code></pre> example output<pre><code>* * *\n ***\n*****\n ***\n* * *\n</code></pre> <p>Try breaking the star problem into simpler patterns, such as a cross (+) and an X (\u00d7).</p> <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    int number;\n\n    do {\n        std::cout &lt;&lt; \"Enter an odd integer in range &lt;1 - 15&gt;: \";\n        std::cin &gt;&gt; number;\n    } while (number % 2 == 0 || number &lt; 1 || number &gt; 15);\n\n    for (int row = 1; row &lt;= number; ++row) {\n        for (int column = 1; column &lt;= number; ++column) {\n            if (row == column\n                || row == number - column + 1\n                || row == (number + 1) / 2\n                || column == (number + 1) / 2) {\n                std::cout &lt;&lt; '*';\n            } else {\n                std::cout &lt;&lt; ' ';\n            }\n        }\n        std::cout &lt;&lt; '\\n';\n    }\n}\n</code></pre>"},{"location":"04%20Functions/","title":"04 Functions","text":"<p>When writing code, we often run into situations where the same logic needs to be used multiple times. Take, for example, calculating the hypotenuse using the Pythagorean theorem, or performing an action to move a player in a video game.</p> <p>If we needed to perform this calculation several times\u2014say, four times, or in the case of a game, once every frame\u2014we wouldn\u2019t want to rewrite the same code repeatedly. In fact, in many cases, doing so wouldn\u2019t even be practical.</p> <p>Not only would that be inefficient, but if we ever needed to make a change, we\u2019d have to update every copy of that code manually. That creates extra work and increases the risk of bugs creeping in.</p> <p>Instead, we want our code to be reusable, readable, and easy to maintain\u2014and that\u2019s exactly where functions come in. Functions let us define a block of code once and reuse it as many times as we need, simply by calling its name. This keeps programs concise and makes them far easier to understand and modify.</p> <p>You\u2019ve already seen one example of a function: the main function. It\u2019s the special entry point of every C/C++ program. However, main is unique in that it only appears once per program and cannot be renamed.</p>"},{"location":"04%20Functions/#function-creation","title":"Function Creation","text":"<p>A function in C++ is made up of two parts; the declaration, which specifies how to call the function, and the definition, which contains the actual code that runs when the function is called.</p> <p>The declaration, also called the function signature, consists of four key elements.</p> # Part Description 1 Return Type The data type of the value the function returns. 2 Function Name A unique identifier to call the function. 3 Parameter List Input values the function accepts. 4 Function Body The block of code executed when the function is called. function signature structure<pre><code>&lt;return-type&gt; &lt;function-name&gt;(&lt;parameter-list&gt;) {\n    &lt;function-body&gt;\n}\n</code></pre> <p>When creating functions, it\u2019s important to declare them before they are used to avoid errors. Also, keep each function focused on a single task as it helps make your code easier to read, maintain, and reuse.</p> <p>Warning</p> <p>Additionally, every time a function is called, the compiler generates a call instruction, which introduces overhead. The program must:</p> <ol> <li>Create a stack frame for the function</li> <li>Push the parameters onto the stack</li> <li>Store the return address</li> <li>Jump to a different part of the binary to execute the function</li> </ol> <p>All these memory operations can slow down the program\u2014especially if the function isn't inlined meaning that the implementation is expanded directly at the call site by the compiler.</p> <p>A good rule of thumb is that if you find yourself repeating the same logic multiple times, it\u2019s likely a good candidate for a function.</p> <p>Functions receive input and output data, but there is no rule that requires them to take arguments or return a value. If a function doesn't return any data, we use a unique data type called <code>void</code>, which explicitly indicates that the function does not return a value.</p> <p>Functions with a <code>void</code> return type are primarily used for performing actions such as outputting to the terminal or working with pointers and references, where returning a value is unnecessary.</p> <p>Example of the simplest function used to reduce the amount of code needed to print output to the terminal.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid PrintText() {\n    std::cout &lt;&lt; \"Hello World!\\n\";\n    std::cout &lt;&lt; \"I am learning C++\\n\";\n}\n\nint main() {\n    PrintText();\n    PrintText();\n    PrintText();\n    PrintText();\n}\n</code></pre> output<pre><code>Hello World!\nI am learning C++\nHello World!\nI am learning C++\nHello World!\nI am learning C++\nHello World!\nI am learning C++\n</code></pre>"},{"location":"04%20Functions/#return-values","title":"Return Values","text":"<p>When we want to retrieve information from an operation performed inside a function and use it elsewhere\u2014such as in the <code>main</code> function\u2014we use the <code>return</code> keyword. This sends data (a number, a variable\u2019s value, or even a direct expression) back to the function\u2019s caller. However, the function\u2019s declared return type must match the type of value being returned.</p> <p>In the example below, we calculate the length of a hypotenuse using the Pythagorean theorem and return the result to the caller for output.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\ndouble CalculateHypotenuse() {\n    return std::sqrt(std::pow(3, 2) + std::pow(4, 2));\n}\n\nint main() {\n    std::cout &lt;&lt; \"Hypotenuse = \" &lt;&lt; CalculateHypotenuse();\n}\n</code></pre> output<pre><code>Hypotenuse = 5\n</code></pre> <p>Note</p> <p>This example introduces the <code>&lt;cmath&gt;</code> header, which provides functions for a wide range of mathematical operations. Whenever you need to perform mathematical computations, <code>&lt;cmath&gt;</code> is the go-to header.</p> <p>You can explore its full list of available functions here: https://cplusplus.com/reference/cmath/</p> <p>Warning</p> <p>When a function has a non-void return type, it must return a value of the specified data type. Failing to do so results in undefined behavior.</p> <p>The only exception to this rule is the <code>main</code> function. Although <code>main</code> is typically declared as returning an <code>int</code>, we don\u2019t always see an explicit return statement. This is because modern C++ compilers automatically insert <code>return 0;</code> at the end of <code>main</code>, indicating that the program executed successfully.</p>"},{"location":"04%20Functions/#multiple-return-values","title":"Multiple Return Values","text":"<p>Info</p> <p>This section is considered more advanced at this point, as it requires knowledge of user-defined types. If you're not yet comfortable with those concepts, feel free to skip this section and return to it later once you're more confident.</p> <p>There are situations where we need to return more than one value from a function. For example, in a game, you might want a function to return a player's position \u2014 <code>x</code>, <code>y</code>, and <code>z</code> coordinates. It would be inefficient and messy to create a separate function for each coordinate.</p> <p>This problem can be solved in several ways, but the most preferred and readable solution is using a structure, which groups related values into a single type.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vec3 {\n    double x;\n    double y;\n    double z;\n};\n\nVec3 GetPlayerCoords() {\n    return Vec3 {\n        .x = 43.4,\n        .y = 38.2,\n        .z = 29.5\n    };\n}\n\nint main() {\n    Vec3 player_position = GetPlayerCoords();\n\n    std::cout &lt;&lt; \" x: \" &lt;&lt; player_position.x &lt;&lt; '\\n';\n    std::cout &lt;&lt; \" y: \" &lt;&lt; player_position.y &lt;&lt; '\\n';\n    std::cout &lt;&lt; \" z: \" &lt;&lt; player_position.z;\n}\n</code></pre> output<pre><code> x: 43.4\n y: 38.2\n z: 29.5\n</code></pre> <p>While using a <code>struct</code> is not the only way to return multiple values in C++, These will be discussed later, but for now, <code>struct</code> is an excellent starting point for clean and readable code.</p>"},{"location":"04%20Functions/#parameter-list","title":"Parameter List","text":"<p>To make the function even more reusable, it would be useful to pass our own values into it. This is possible through the parameter list. The parameter list is created by declaring empty variables inside the parentheses of the function declaration, these are called parameters.</p> <p>Also, parameters and arguments are often used interchangeably, but technically:</p> <ul> <li>Parameters refer to the variables in the function declaration.</li> <li>Arguments are the actual values passed when calling the function.</li> </ul> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\ndouble CalculateHypotenuse(double a, double b) {\n    return std::sqrt(pow(a, 2) + std::pow(b, 2));\n}\n\nint main() {\n    std::cout &lt;&lt; \"Hypotenuse = \" &lt;&lt; CalculateHypotenuse(3, 4) &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Hypotenuse = 5\n</code></pre> <p>Parameters are assigned values during the function call, following the exact order in which they were defined. These values can be either direct numbers or variables, but their types must always match the function's parameter types.</p>"},{"location":"04%20Functions/#default-arguments","title":"Default Arguments","text":"<p>Now that we understand how parameters receive input through arguments, we can take this idea a step further. In many functions, a parameter often uses the same value repeatedly. Writing that value every time doesn\u2019t add clarity \u2014 it only adds noise. This is where default arguments become useful.</p> <p>Default arguments allow you to assign a value directly in the function declaration. If the caller doesn\u2019t provide an argument for that parameter, the default is used automatically.</p> <p>A default argument is written by assigning a value to a parameter inside the function declaration. When a function call omits that argument, the compiler fills in the missing value with the default.</p> output<pre><code>#include &lt;iostream&gt;\n\nvoid PrintNumber(int number, int repeat_count = 1) {\n    for (int i = 0; i &lt; repeat_count; ++i) {\n        std::cout &lt;&lt; number &lt;&lt; ' ';\n    }\n\n    std::cout &lt;&lt; '\\n';\n}\n\nint main() {\n    PrintNumber(87);\n    PrintNumber(87, 10);\n}\n</code></pre> output<pre><code>87 \n87 87 87 87 87 87 87 87 87 87\n</code></pre> <p>Default arguments must appear from right to left in the parameter list. Once a parameter has a default value, every parameter after it must also have one \u2014 this ensures the compiler always knows which argument corresponds to which parameter.</p> <p>Defaults also belong at the point of declaration, not definition. If a function is declared in a header and defined in a source file, the default values should be placed in the header so all translation units see the same defaults.</p> <p>Default arguments keep function calls clean without restricting flexibility. They remove unnecessary repetition while still allowing callers to override the defaults whenever needed.</p>"},{"location":"04%20Functions/#function-attributes","title":"Function Attributes","text":"<p>In addition to a function\u2019s signature, C++ lets us describe extra behavior around a function. One way to do this is through function attributes, a standardized mechanism for attaching metadata to declarations.</p> <p>Attributes use the <code>[[...]]</code> syntax and are designed to be portable, structured, and easy for compilers\u2014and readers\u2014to understand. They don\u2019t change how a function fundamentally works; instead, they provide additional information or guidance. In practice, only a small number of attributes are both common and broadly useful.</p> Attribute Meaning Typical Use <code>[[nodiscard]]</code> Warns if a caller ignores the return value. Functions that compute results where ignoring the output is likely a mistake. <code>[[maybe_unused]]</code> Suppresses \u201cunused variable/parameter\u201d warnings. Conditional compilation, placeholder parameters, or temporary scaffolding. <code>[[deprecated]]</code> Marks a function as old or to be avoided. APIs you want callers to transition away from. <code>[[likely]]</code>, <code>[[unlikely]]</code> Hints which branches the compiler should optimize. Performance-critical conditions where profiling shows a consistent trend. main.cpp<pre><code>[[nodiscard]] int Multiply(int a, int b) {\n    return a * b;\n}\n\nint main() {\n    Multiply(10, 20);\n}\n</code></pre> output<pre><code>&lt;source&gt;: In function 'int main()':\n&lt;source&gt;:6:13: warning: ignoring return value of 'int Multiply(int, int)', declared with attribute 'nodiscard' [-Wunused-result]\n    6 |     Multiply(10, 20);\n      |     ~~~~~~~~^~~~~~~~\n&lt;source&gt;:1:19: note: declared here\n    1 | [[nodiscard]] int Multiply(int a, int b) {\n      |                   ^~~~~~~~\nCompiler returned: 0\n</code></pre> <p>These attributes appear frequently in modern C++ codebases and help make APIs clearer without introducing any runtime overhead. They\u2019re small additions that improve communication\u2014between you, future maintainers, and the compiler.</p>"},{"location":"04%20Functions/#function-specifiers","title":"Function Specifiers","text":"<p>While attributes serve as metadata, C++ also provides a set of function specifiers\u2014keywords that directly influence how a function behaves. These differ from attributes and do not use the <code>[[...]]</code> syntax. Instead, they modify the rules a function must follow or introduce additional capabilities, such as compile-time evaluation, inlining hints, or exception guarantees.</p> <p>The most immediately relevant specifier is <code>static</code>.</p> <p>The <code>static</code> specifier changes how a function is linked and accessed. For free (non-member) functions, it gives the function internal linkage, meaning it is only visible within the translation unit where it is defined. This is useful for \u201cprivate\u201d helper functions that shouldn\u2019t be used outside their file.</p> main.cpp<pre><code>[[nodiscard]] static int Multiply(int a, int b) {\n    return a * b;\n}\n\nint main() {\n    std::cout &lt;&lt; Multiply(10, 20);\n}\n</code></pre> output<pre><code>200\n</code></pre> <p>We\u2019ll encounter a few more specifiers as we move deeper into the language. Introducing them gradually keeps the learning curve reasonable. Whenever a new specifier appears in the book, it will be clearly called out and explained in context.</p>"},{"location":"04%20Functions/#forward-declarations","title":"Forward Declarations","text":"<p>So far, all of our examples have followed a simple rule: a function is created and fully defined before it is used elsewhere in the program.</p> <p>This works well in small programs, but as soon as your code grows, that restriction starts to feel limiting. You may want <code>main</code> function at the top of the file for readability, or you may want functions to call each other in a natural order. Unfortunately, the compiler doesn\u2019t read your program the way a human does.</p> <p>C++ is compiled top to bottom. When the compiler encounters a function call, it must already know that the function exists and how it can be called. If it doesn\u2019t, compilation fails\u2014even if the function is defined later in the file.</p> <p>This is the problem that forward declaration solve.</p> <p>A forward declaration tells the compiler \u201cthis function exists, and this is its signature\u201d, without providing the actual implementation yet. It gives the compiler just enough information to allow function calls before the definition appears.</p> <p>A forward declaration looks exactly like a function declaration\u2014but without the function body.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\ndouble CalculateHypotenuse(double a, double b); // forward declaration\n\nint main() {\n    std::cout &lt;&lt; \"Hypotenuse = \" &lt;&lt; CalculateHypotenuse(3, 4);\n}\n\ndouble CalculateHypotenuse(double a, double b) {\n    return std::sqrt(std::pow(a, 2) + std::pow(b, 2));\n}\n</code></pre> output<pre><code>Hypotenuse = 5\n</code></pre> <p>Notice what\u2019s happening here:</p> <ul> <li>The compiler sees the declaration first and learns the function\u2019s return type and parameters.</li> <li>The function can safely be called inside main.</li> <li>The full definition appears later and provides the actual behavior.</li> </ul> <p>Forward declarations simply act as a promise that \u201cthis function will be defined somewhere\u201d. If the definition is missing\u2014or doesn\u2019t match the declaration\u2014the linker will report an error.</p> <p>Forward declarations become especially important once our programs are split across multiple files. In practice, this is exactly how header files work. They typically contain forward declarations, while source files contain the actual definitions.</p>"},{"location":"04%20Functions/#function-overloading","title":"Function Overloading","text":"<p>Function overloading occurs when we define multiple functions with the same name but different types or counts of parameters. This allows the function to perform the same action for different types of input.</p> <p>For example, imagine we want to create a function for printing to the terminal that can handle multiple data types, such as integers or strings. If a function is defined to accept only an integer, passing a string, float, or char might cause data loss or a compiler error.</p> <p>To solve this, we can overload the function\u2014define multiple versions of it, each tailored to handle a different type of input. The compiler will then automatically choose the correct one based on the arguments we pass.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nvoid Print(int value) {\n    std::cout &lt;&lt; \"Integer only version: \" &lt;&lt; value &lt;&lt; '\\n';\n}\n\nvoid Print(double value) {\n    std::cout &lt;&lt; \"Double only version: \" &lt;&lt; value &lt;&lt; '\\n';\n}\n\nvoid Print(int value1, double value2) {\n    std::cout &lt;&lt; \"Combined version: \" &lt;&lt; value1 &lt;&lt; \" | \" &lt;&lt; value2 &lt;&lt; '\\n';\n}\n\nint main() {\n    Print(11);\n    Print(74.53);\n    Print(11, 74.53);\n}\n</code></pre> output<pre><code>Integer only version: 11\nDouble only version: 74.53\nCombined version: 11 | 74.53\n</code></pre>"},{"location":"04%20Functions/#inline-functions","title":"Inline Functions","text":"<p>When we define a function, even if it's just a single line, every time we call it, the program performs a jump to the function's memory location, runs the code, and then jumps back. This adds a bit of overhead, especially when calling very small functions repeatedly.</p> <p>To reduce this overhead for frequently used functions, we can use the inline keyword. Instead of making the program jump, the compiler replaces the function call with the actual code of the function\u2014essentially copying and pasting it at the call site.</p> <p>This technique can improve performance slightly by avoiding function call overhead\u2014especially in tight loops or small helper functions.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\ninline int Square(int x) {\n    return x * x;\n}\n\nint main() {\n    std::cout &lt;&lt; Square(4) &lt;&lt; '\\n';\n    std::cout &lt;&lt; Square(7);\n\n    /*\n        In both cases, because we used the inline keyword,\n        the function calls will be replaced by the compiler\n        with the actual expression\n\n        std::cout &lt;&lt; 4 * 4 &lt;&lt; '\\n';\n        std::cout &lt;&lt; 7 * 7;\n    */\n}\n</code></pre> <p>Note</p> <p>The <code>inline</code> keyword is a suggestion to the compiler, not a command. Modern compilers are smart enough to decide whether inlining is worth it, even without the keyword.</p> <p>Inline functions are best used for very short functions (like getters, setters, or simple calculations).</p> <p>Avoid using <code>inline</code> on large functions\u2014it can increase code size, which may negatively affect performance due to cache misses.</p>"},{"location":"04%20Functions/#lambdas","title":"Lambdas","text":"<p>Info</p> <p>This section is considered more advanced at this point, as it requires knowledge of pointers and references. If you're not yet comfortable with those concepts, feel free to skip this section and return to it later once you're more confident.</p> <p>Lambdas, also known as anonymous functions, let you define small, unnamed functions directly at the point of use. They're mainly intended for short, one-off operations and behave like disposable function objects. Lambdas are especially useful when you need to run a quick piece of logic without declaring a full function elsewhere. They can also capture and use variables from the surrounding scope, making them both powerful and flexible.</p>"},{"location":"04%20Functions/#when-to-use-lambdas","title":"When to use lambdas","text":"<p>Whenever you have a function pointer, you can use a lambda in C++. The best example of this is when we need to pass a function to an API or event handler so that it can call the function at a later time. Lambdas are ideal for defining code that should run in the future.</p> <p>This is useful when:</p> <ul> <li>The function requires data that isn\u2019t available yet.</li> <li>We want to defer execution but still specify which function to call when needed.</li> </ul> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n\nvoid ForEach(const std::vector&lt;int&gt;&amp; values, const std::function&lt;void(int)&gt;&amp; func) {\n    for (const auto&amp; value : values) {\n        func(value);\n    }\n}\n\nint main() {\n    std::vector&lt;int&gt; values = {27, 64, 3, 89, 51};\n\n    std::function&lt;void(int)&gt; lambda = [](int value) { \n        std::cout &lt;&lt; value &lt;&lt; ' '; \n    };\n\n    ForEach(values, lambda);\n}\n</code></pre> output<pre><code>27 64 3 89 51 \n</code></pre> <p>The square brackets before a lambda expression are called capture clauses. They allow the lambda to access variables from the surrounding scope using different capture modes, which are specified with various symbols.</p> # Capture Syntax Description 1 <code>[]</code> No capture \u2013 the lambda has no access to outer variables. 2 <code>[variable]</code> Capture by value \u2013 creates a copy of <code>variable</code>. 3 <code>[&amp;variable]</code> Capture by reference \u2013 modifies the original <code>variable</code>. 4 <code>[=]</code> Capture all by value \u2013 copies all outer variables used. 5 <code>[&amp;]</code> Capture all by reference \u2013 references all outer variables. 6 <code>[variable1, &amp;variable2]</code> Mixed capture \u2013 <code>variable1</code> by value, <code>variable2</code> by reference. <p>These captured variables are read-only by default when captured by value. If you want to modify them inside the lambda, you need to use the <code>mutable</code> specifier after the parameter list.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int count = 10;\n\n    auto lambda = [count]() mutable { \n        count++;  // Allowed because of `mutable`\n        std::cout &lt;&lt; \"Lambda modified count: \" &lt;&lt; count &lt;&lt; '\\n';\n    };\n\n    lambda();\n\n    std::cout &lt;&lt; \"Original count: \" &lt;&lt; count;\n}\n</code></pre> output<pre><code>Lambda modified count: 11\nOriginal count: 10\n</code></pre>"},{"location":"04%20Functions/#lambda-use-case","title":"Lambda Use Case","text":"<p>A common use case for lambda expressions is within algorithm functions, such as <code>std::find_if</code>. This function, which is part of the <code>&lt;algorithm&gt;</code> header file, is used to find a specific value in an iterable data structure based on a given condition.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    std::vector&lt;int&gt; values = {1, 5, 4, 2, 3};\n\n    auto it = std::find_if(values.begin(), values.end(), [](int value) { \n        return value &gt; 3;\n    });\n\n    std::cout &lt;&lt; \"First number bigger than 3: \" &lt;&lt; *it;\n}\n</code></pre> output<pre><code>First number bigger than 3: 5\n</code></pre>"},{"location":"04%20Functions/#recursion","title":"Recursion","text":"<p>Sometimes, the simplest way to solve a problem is to break it into smaller instances of the same problem. This approach is called recursion.</p> <p>A recursive function is a function that calls itself, either directly or indirectly, to handle a smaller piece of the original problem. Each call gradually approaches a situation that can be solved directly, known as the base case. Once the base case is reached, the function stops calling itself, and the results of the smaller problems are combined to produce the final solution.</p> <p>Recursion is particularly useful for tasks that naturally involve repetition or hierarchy. Examples include navigating tree-like structures, calculating mathematical sequences such as factorials or Fibonacci numbers, and solving puzzles or problems that can be divided into smaller, similar steps.</p> <p>A recursive function generally consists of two essential components: the base case, which defines the condition under which the recursion stops, and the recursive case, where the function calls itself with a simpler or smaller version of the problem. Without a base case, a recursive function would continue indefinitely, eventually consuming all available memory and causing the program to crash.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint Factorial(int number) {\n    if (number &lt;= 1) { // base case: 0! = 1 and 1! = 1\n        return 1;\n    }\n    return number * Factorial(number - 1); // recursive case\n}\n\nint main() {\n    int value = 5;\n    std::cout &lt;&lt; \"Factorial of \" &lt;&lt; value &lt;&lt; \" is \" &lt;&lt; Factorial(value);\n}\n</code></pre> output<pre><code>Factorial of 5 is 120\n</code></pre> <p>Info</p> <p>Recursion can feel unintuitive at first\u2014and that\u2019s completely normal. The key is to stay patient and focus on the structure: every recursive function must make progress toward a simple base case.</p>"},{"location":"04%20Functions/#questions","title":"Questions","text":"question 1answer <p>What are the four key elements of a function creation?</p> <ol> <li>Return type  </li> <li>Function name  </li> <li>Parameter list  </li> <li>Function body</li> </ol> question 2answer <p>What keyword is used in C++ to indicate a function does not return a value?</p> <p><code>void</code></p> question 3answer <p>What is the difference between parameters and arguments?</p> <p>Parameters are variables in the function declaration; arguments are the actual values passed when calling the function.</p> question 4answer <p>How do default arguments work, and where should they be declared?</p> <p>A default argument provides a value for a parameter if the caller does not supply one. Default values must appear in the function declaration, not the definition. They are processed from right to left, so once a parameter has a default, all parameters to its right must also have defaults.</p> question 5answer <p>What does the <code>[[nodiscard]]</code> attribute do?</p> <p>It warns the programmer if the return value of a function is ignored.</p> question 6answer <p>What is a function specifiers? Give one common example.</p> <p>A function specifiers is a keyword that modifies a function\u2019s behavior or guarantees (not an attribute). Example: <code>static</code>, which restricts a free function\u2019s visibility to the translation unit where it is defined, effectively giving it internal linkage.</p> question 7answer <p>How does function overloading work in C++?</p> <p>Multiple functions can have the same name as long as their parameter types or counts differ. The compiler chooses the correct version based on the arguments provided.</p> question 8answer <p>What is an inline function, and when should it be used?</p> <p>An inline function suggests to the compiler to replace the function call with its body to avoid call overhead. Best for very short functions; avoid using on large functions. Thou for modern compilers its only a suggestion and they will desice on theyre own</p> question 9answer <p>What is a lambda function, and what is the purpose of its capture list?</p> <p>A lambda is an unnamed function defined at the point of use. The capture list specifies which variables from the surrounding scope the lambda can access, and whether by value or reference.</p> question 10answer <p>What are the two essential parts of a recursive function?</p> <ol> <li>Base case \u2014 condition under which recursion stops  </li> <li>Recursive case \u2014 the function calls itself on a smaller or simpler problem</li> </ol>"},{"location":"04%20Functions/#exercises","title":"Exercises","text":"exercise 1answer <p>Write a function named <code>Greet</code> that prints \"Hello, C++ Learner!\" to the console. In main, call this function <code>n</code> times, where <code>n</code> is a number entered through the terminal.</p> <pre><code>#include &lt;iostream&gt;\n\nvoid Greet() {\n    std::cout &lt;&lt; \"Hello, C++ Learner!\\n\";\n}\n\nint main() {\n    int number;\n\n    std::cout &lt;&lt; \"Enter number of repetetions: \";\n    std::cin &gt;&gt; number;\n\n    for (int i = 0; i &lt; number; ++i) {\n        Greet();\n    }\n}\n</code></pre> exercise 2answer <p>Write a function <code>Square</code> that takes a number parameter and returns its square. In <code>main</code>, call it with the values loaded from the terminal, and print the results.</p> <pre><code>#include &lt;iostream&gt;\n\n[[nodiscard]] double Square(double a) {\n    return a * a;\n}\n\nint main() {\n    double number;\n\n    std::cout &lt;&lt; \"Enter a number: \";\n    std::cin &gt;&gt; number;\n\n    std::cout &lt;&lt; \"Output: \" &lt;&lt; Square(number);\n}\n</code></pre> exercise 3answer <p>Write a custom function <code>Pow</code> that takes a number and an exponent parameter and returns its power. Let the exponent default to 2, and ensure the function is accessible only within the current translation unit. In <code>main</code>, read the number and exponent values from the terminal, call the function, and print the result.</p> <pre><code>#include &lt;iostream&gt;\n\n[[nodiscard]] static double Pow(double base, int exponent = 2) {\n    if (exponent == 0) {\n        return 1.0;\n    }\n\n    double result = 1.0;\n\n    for (int i = 0; i &lt; exponent; ++i) {\n        result *= base;\n    }\n\n    return result;\n}\n\nint main() {\n    double number;\n    int exponent;\n\n    std::cout &lt;&lt; \"Enter a number: \";\n    std::cin &gt;&gt; number;\n\n    std::cout &lt;&lt; \"Enter an exponent: \";\n    std::cin &gt;&gt; exponent;\n\n    std::cout &lt;&lt; \"Default exponent: \" &lt;&lt; Pow(number) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Custom exponent: \" &lt;&lt; Pow(number, exponent);\n}\n</code></pre> exercise 4answer <p>Write a recursive function <code>Fibonacci</code> that returns the n-th number in the Fibonacci sequence. Read the value of <code>n</code> from the terminal in main, call the function, and print the result.</p> <pre><code>#include &lt;iostream&gt;\n\nint Fibonacci(int n) {\n    if (n &lt;= 2) {\n        return 1;\n    }\n\n    return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nint main() {\n    int number;\n\n    std::cout &lt;&lt; \"Enter a positive number: \";\n    std::cin &gt;&gt; number;\n\n    std::cout &lt;&lt; \"Fibonacci \" &lt;&lt; number &lt;&lt; \"th is: \" &lt;&lt; Fibonacci(number);\n}\n</code></pre>"},{"location":"05%20Data%20Types/","title":"05 Data Types","text":"<p>By now, we've covered the absolute basics. As part of that foundation, we introduced fundamental primitive data types, along with the kinds of values they can represent.</p> <p>In the next few chapters, we\u2019ll start working more closely with memory. As we go deeper into the language, it becomes increasingly important to understand how memory behaves\u2014especially when working with a lower-level language like C++. At this point, it\u2019s not just about writing code that works; it\u2019s about knowing what\u2019s really happening behind the scenes.</p> <p>Now, it\u2019s time to look more closely at how these basic types can be refined and extended into more specialized or optimized forms, depending on the needs of your data.</p>"},{"location":"05%20Data%20Types/#static-typing","title":"Static Typing","text":"<p>C++ is a statically typed language. This means that the type of every variable must be known at compile time. In other words, the compiler needs to know what kind of data each variable will hold before the program even runs.</p> <p>This gives us a few advantages. First, it allows the compiler to catch many type-related errors early, before the program executes. Second, it lets the compiler optimize memory usage and CPU instructions because it knows exactly how much space each variable takes and how to interpret it.</p>"},{"location":"05%20Data%20Types/#strong-typing","title":"Strong Typing","text":"<p>C++ is also considered strongly typed. This means the language enforces rules about how different types can interact. While you can convert between types using casts, the compiler won\u2019t allow incompatible types to be mixed unintentionally.</p> <p>For example, you can\u2019t assign a double to a pointer to an int or automatically treat a <code>std::string</code> as a number. The compiler forces you to be explicit, which prevents subtle bugs and unintended behavior.</p> <p>In short, static typing tells the compiler what a variable is, and strong typing tells it what a variable cannot be.</p>"},{"location":"05%20Data%20Types/#primitive-data-types","title":"Primitive Data Types","text":"<p>In the introduction chapter, we introduced some of the primitive data types to kick-start our learning\u2014but that was just the absolute core. To give you more control and flexibility, C++ actually offers a broader range of primitive types, enabling more precise management of memory.</p>"},{"location":"05%20Data%20Types/#standard-integer-types","title":"Standard Integer Types","text":"Type Size (bytes) Signed Range <code>char</code> 1 -128 to 127 <code>short</code> 2 -32,768 to 32,767 <code>int</code> 4 -2,147,483,648 to 2,147,483,647 <code>long</code> 4 or 8 Depends on the system <code>long long</code> 8 -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 <p>Note</p> <p>On many 64-bit systems, <code>int</code> and <code>long</code> are both 4 bytes, but this can vary depending on the compiler and platform.</p>"},{"location":"05%20Data%20Types/#fixed-width-integer-types","title":"Fixed-Width Integer Types","text":"<p>These types guarantee their size across different systems and compilers. But to use the fixed-width integer types ending with <code>_t</code>, you need to include the <code>&lt;cstdint&gt;</code> header.</p> Type Size (bytes) Signed Range <code>int8_t</code> 1 -128 to 127 <code>int16_t</code> 2 -32,768 to 32,767 <code>int32_t</code> 4 -2,147,483,648 to 2,147,483,647 <code>int64_t</code> 8 -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 <code>size_t</code> 4 or 8 Represents the size of any object in memory (always unsigned) <p>Note</p> <p>Types like <code>intptr_t</code> and <code>uintptr_t</code> are integer types capable of storing pointer values. They\u2019re mostly useful in low-level or systems programming, such as writing memory managers or interfacing with hardware. But these data types will most C++ applications never need.</p> <p>Note</p> <p>Similarly, <code>intmax_t</code> and <code>uintmax_t</code> represent the largest signed and unsigned integer types available on a given platform. While they sound powerful, they\u2019re rarely used and are mainly helpful in highly portable libraries or template-heavy code. For most use cases, fixed-width types like <code>int64_t</code> or <code>size_t</code> are a better fit.</p>"},{"location":"05%20Data%20Types/#unsigned-integers","title":"Unsigned Integers","text":"<p>Signed integers divide their range between positive and negative numbers, effectively splitting their capacity in half.</p> <p>However, in many cases, negative numbers are unnecessary or nonsensical. For example, color channels such as RGBA are represented by values between 0 and 255, and quantities like array sizes or memory addresses can never be negative.</p> <p>In these scenarios, using a signed integer like <code>int8_t</code> would be wasteful because half of the range goes unused.</p> <p>To allocate the entire bit range exclusively for non-negative values you can use unsigned types. For example, <code>uint8_t</code> ranges from 0 to 255, doubling the maximum value you can store in the same memory size.</p> Type Size (bytes) Unsigned Range <code>unsigned char</code> 1 0 to 255 <code>unsigned short</code> 2 0 to 65,535 <code>unsigned int</code> 4 0 to 4,294,967,295 <code>unsigned long</code> 4 or 8 Depends on system <code>unsigned long long</code> 8 0 to 18,446,744,073,709,551,615 <code>uint8_t</code> 1 0 to 255 <code>uint16_t</code> 2 0 to 65,535 <code>uint32_t</code> 4 0 to 4,294,967,295 <code>uint64_t</code> 8 0 to 18,446,744,073,709,551,615"},{"location":"05%20Data%20Types/#integer-literals","title":"Integer Literals","text":"<p>An integer literal is a numeric value written directly in your source code, such as <code>42</code> or <code>1'000'000</code>. When no extra information is provided, the compiler infers the most appropriate integer type based on the value itself and the platform\u2019s integer sizes.</p> <p>In most cases, this automatic inference is exactly what you want. However, when working with large numbers, unsigned values, or APIs that expect specific integer types, you may need to explicitly control how a literal is interpreted. C++ allows this by appending suffixes to integer literals.</p> Suffix Inferred Type Example none <code>int</code>, <code>long</code>, or <code>long long</code> <code>42</code> <code>u</code> <code>unsigned int</code> <code>42u</code> <code>l</code> <code>long</code> <code>42l</code> <code>ul</code> <code>unsigned long</code> <code>42ul</code> <code>ll</code> <code>long long</code> <code>42ll</code> <code>ull</code> <code>unsigned long long</code> <code>42ull</code> <p>Info</p> <p>Uppercase and lowercase suffixes are equivalent (<code>U</code> vs <code>u</code>, <code>LL</code> vs <code>ll</code>), though lowercase is commonly preferred for readability.</p>"},{"location":"05%20Data%20Types/#floating-point-types","title":"Floating-Point Types","text":"Type Size (bytes) Precision (Approx.) Range <code>float</code> 4 ~6-7 decimal digits \u00b11.5 \u00d7 10\u207b\u2074\u2075 to \u00b13.4 \u00d7 10\u00b3\u2078 <code>double</code> 8 ~15-16 decimal digits \u00b15.0 \u00d7 10\u207b\u00b3\u00b2\u2074 to \u00b11.8 \u00d7 10\u00b3\u2070\u2078 <code>long double</code> 8-16 Varies Higher precision than <code>double</code> <p>Note</p> <p><code>double</code> is the default choice for floating-point arithmetic, providing more precision with minimal performance loss. However, when memory usage is critical, float may be preferred. To use floats, you must explicitly specify them by appending the value with an <code>f</code> suffix (e.g., 3.14f). Otherwise, the compiler treats floating-point literals as double by default.</p>"},{"location":"05%20Data%20Types/#character-types","title":"Character Types","text":"<p>So far, we have introduced only ASCII character encoding, which supports 128 characters (or 256 in extended ASCII). However, ASCII is insufficient for representing the full range of characters used worldwide.</p> <p>To address this, other encodings were developed, with UTF-8 becoming the most widely used due to its flexibility and backward compatibility with ASCII.</p> <p>UTF-8 can represent a wide variety of characters, including:</p> <ul> <li>Latin characters with diacritics: <code>\u00e9, \u00f1, \u00fc, \u010d, \u0161</code></li> <li>Mathematical symbols: <code>\u221e, \u2211, \u03c0, \u221a</code></li> <li>Currency symbols: <code>\u20ac, \u00a5, \u20b9, \u20bf</code></li> <li>Emoji: <code>\ud83d\ude00, \u2764\ufe0f, \ud83d\ude80, \ud83d\udd25</code></li> <li>Non-Latin scripts: <code>\u4f60\u597d (Chinese), \u041f\u0440\u0438\u0432\u0435\u0442 (Russian), \u0928\u092e\u0938\u094d\u0924\u0947 (Hindi), \u0627\u0644\u0639\u0631\u0628\u064a\u0629 (Arabic)</code></li> </ul> Type Size (bytes) Prefix Description <code>char</code> 1 None Holds a single character (typically ASCII) <code>wchar_t</code> 2 or 4 <code>L'A'</code> Wide character (Unicode, size platform-dependent) <code>char8_t</code> 1 <code>u8'A'</code> UTF-8 character (C++20) <code>char16_t</code> 2 <code>u'A'</code> UTF-16 character (Unicode) <code>char32_t</code> 4 <code>U'A'</code> UTF-32 character (Unicode) <p>These specialized types require prefixes before assigning literals to indicate their encoding.</p> <p>Handling non-ASCII characters in the terminal can be tricky, especially on Windows. To support UTF-8 output, you need to include the <code>&lt;Windows.h&gt;</code> header and adjust settings via its functions. On Linux and macOS, this usually works without additional setup.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n\n#pragma execution_character_set(\"utf-8\")\n\nint main() {\n    SetConsoleOutputCP(CP_UTF8);\n\n    std::cout &lt;&lt; \"Testing unicode:\\n\";\n    std::cout &lt;&lt; \" - English\\n\";\n    std::cout &lt;&lt; \" - \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac\\n\";\n    std::cout &lt;&lt; \" - Espa\u00f1ol\\n\";\n    std::cout &lt;&lt; \" - \u0420\u0443\u0441\u0441\u043a\u0438\u0439\\n\";\n    std::cout &lt;&lt; \" - a\u00e4bcdefghijklmno\u00f6pqrs\u00dftu\u00fcvwxyz\\n\";\n}\n</code></pre> output<pre><code>Testing unicode:\n - English\n - \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac\n - Espa\u00f1ol\n - \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n - a\u00e4bcdefghijklmno\u00f6pqrs\u00dftu\u00fcvwxyz\n</code></pre> <p>Note</p> <p>It\u2019s  best to avoid non-ASCII characters in your source code unless necessary (e.g., in GUI applications). Non-ASCII characters can complicate compatibility across different environments and are rarely required in typical C++ code.</p>"},{"location":"05%20Data%20Types/#type-casts","title":"Type Casts","text":"<p>Sometimes, we need to reinterpret the data a variable holds by changing its type. This process is called type casting.</p> <p>But not all types in C++ are directly compatible, and trying to mix them without conversion can lead to errors or unexpected behavior. Fortunately, C++ provides two main ways to perform type conversions.</p> <ul> <li>Implicit Conversion (Automatic):   In many cases, the compiler can handle type conversions for you\u2014this is called implicit conversion.   For example, assigning an <code>int</code> to a <code>double</code> works automatically, because the compiler knows how to safely widen the value without losing information.</li> <li>Explicit Conversion (Casting):   When a conversion isn\u2019t safe or obvious, C++ requires you to perform an explicit cast.   This tells the compiler, \u201cYes, I know what I\u2019m doing\u2014convert this anyway.\u201d There are several ways to do this, and we\u2019ll cover them.</li> </ul>"},{"location":"05%20Data%20Types/#conversions","title":"Conversions","text":"<p>In C++, conversions are implicit. They occur when the compiler automatically converts one type to another without data loss, such as in arithmetic operations between different types or when assigning a <code>double</code> to an <code>int</code>.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    double pi = 3.14;\n    int value = pi; // Implicit conversion: fractional part is lost\n\n    char a = 'A';\n    int b = a; // Implicit conversion: 'b' is assigned 65 (ASCII value of 'A')\n\n    std::cout &lt;&lt; \"Double to integer conversion: \" &lt;&lt; value &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Character to integer conversion: \" &lt;&lt; a &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Double to integer conversion: 3\nCharacter to integer conversion: 65\n</code></pre>"},{"location":"05%20Data%20Types/#c-style-casts","title":"C-Style Casts","text":"<p>Since C++ is built on top of C, it inherits nearly all of its features, including its casting techniques. The C-style cast is one of the most commonly used casting methods due to its simplicity and ease of use. It is applied by prefixing a variable with a type in parentheses.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int number = 42;\n    void* ptr = &amp;number; // Implicit conversion allowed (int* -&gt; void*)\n\n    int* ptr_num = (int*)ptr; // Explicit cast\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; *ptr_num &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Value: 42\n</code></pre>"},{"location":"05%20Data%20Types/#c-casts","title":"C++ Casts","text":"<p>C-style casts are simple but potentially dangerous. They allow almost any kind of conversion without checks, which can easily lead to undefined behavior. That\u2019s why C++ introduced its own casting operators\u2014<code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, and <code>reinterpret_cast</code>.</p> <p>It\u2019s important to understand that C++ casts don\u2019t add new capabilities beyond what C-style casts can do. Instead, they provide safer and more controlled ways to perform conversions. By using explicit keywords, C++ casts make your intent clear and help the compiler enforce stricter type checks. This reduces the risk of accidental or unsafe conversions.</p> <p>Another benefit is maintainability. Because each cast uses a specific keyword, it's easier to search for and reason about casting operations in your code. That makes tasks like debugging or refactoring much more manageable.</p> <p>In short, C++ casts offer the same power as C-style casts, but with better safety and clarity. While C-style casts are still widely used, especially in older code, you should prefer C++ casts in modern C++ projects. They\u2019re more explicit, more readable overall.</p>"},{"location":"05%20Data%20Types/#static-cast","title":"Static Cast","text":"<p>C++ equivalent of a traditional C-style cast is the <code>static_cast</code>. Unlike C-style casts, it provides better type safety by restricting certain conversions (e.g., removing <code>const</code> or casting between incompatible pointer types) that could lead to undefined behavior.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value = 42;\n    void* void_ptr = &amp;value;\n\n    int* int_ptr = static_cast&lt;int*&gt;(void_ptr);\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; *int_ptr &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Value: 42\n</code></pre>"},{"location":"05%20Data%20Types/#dynamic-cast","title":"Dynamic Cast","text":"<p>Info</p> <p>It is recommended to go through user-defined structures before proceeding further, as the upcoming examples will focus on class behavior and involve casting between classes.</p> <p><code>dynamic_cast</code> adds another layer of safety to <code>static_cast</code> by performing runtime validation. If the cast is unsuccessful, it returns a <code>nullptr</code>. Unlike <code>static_cast</code>, which is evaluated at compile-time, <code>dynamic_cast</code> is evaluated at runtime, making it slightly slower but significantly safer when working with polymorphic class hierarchies.</p> <p>Imagine we have three classes in our game: <code>Entity</code> (the base class), <code>Player</code> and <code>Enemy</code> (both derived from <code>Entity</code>). Casting a <code>Player</code> to <code>Entity</code> is straightforward, as <code>Player</code> already inherits all the properties of <code>Entity</code>, only losing its own unique members in the process.</p> <p>The challenge arises when trying to cast an <code>Entity</code> to a <code>Player</code>. The compiler has no way of knowing whether the <code>Entity</code> instance actually represents a <code>Player</code>, an <code>Enemy</code>, or just a base <code>Entity</code>. With <code>static_cast</code>, the compiler trusts the programmer, but if the cast is incorrect, accessing <code>Player</code>-specific members can lead to a crash.</p> <p>This is where <code>dynamic_cast</code> becomes valuable. If we have an <code>Entity</code> instance that is actually an <code>Enemy</code> and try to cast it to <code>Player</code> using <code>dynamic_cast</code>, the cast will fail and return <code>nullptr</code>, allowing us to safely check the result before accessing <code>Player</code>-specific members.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Entity {\npublic:\n    // Necessary for dynamic_cast to work (ensures a vtable)\n    virtual void PrintName() {\n    }\n};\n\nclass Player : public Entity {\n};\n\nclass Enemy : public Entity {\n};\n\nint main() {\n    // Implicit Cast (correct): Upcasting is safe\n    // Player* player = new Player();\n    // Entity* entity = player;\n\n    // Implicit Cast (incorrect): Attempting to cast an Enemy to a Player\n    Entity* unknown_entity = new Enemy();\n\n    // Explicit C-style Cast (incorrect): It is unsafe without validation\n    // Player* player_cast = (Player*)unknown_entity;\n\n    // Correct usage of dynamic_cast\n    Player* safe_player = dynamic_cast&lt;Player*&gt;(unknown_entity);\n\n    // We can perform a simple check because dynamic_cast returns nullptr if the cast fails\n    if (safe_player) {\n        std::cout &lt;&lt; \"Cast successful\";\n        safe_player-&gt;PrintName();\n    } else {\n        std::cout &lt;&lt; \"Cast failed\";\n    }\n}\n</code></pre> output<pre><code>Cast failed\n</code></pre>"},{"location":"05%20Data%20Types/#constant-cast","title":"Constant Cast","text":"<p>Constant cast serves a single purpose: adding or removing the <code>const</code> qualifier from a variable. This might sound simple, but it has important use cases, especially when dealing with legacy code, function parameters, or APIs that don\u2019t support <code>const</code> properly.</p> <p>Imagine you have a <code>const</code> variable, but you need to modify its value. Normally, C++ prevents this to ensure safety, but <code>const_cast</code> allows you to override this restriction. However, this should only be done when you\u2019re absolutely sure it\u2019s safe, modifying truly <code>const</code> values leads to undefined behavior.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid ChangeValue(const int* ptr) {\n    int* modifiable_ptr = const_cast&lt;int*&gt;(ptr);\n    *modifiable_ptr = 99;\n}\n\nint main() {\n    int value = 42;\n\n    ChangeValue(&amp;value);\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Value: 99\n</code></pre>"},{"location":"05%20Data%20Types/#reinterpret-cast","title":"Reinterpret Cast","text":"<p>Info</p> <p>It is recommended to go through user-defined types before proceeding further, as the upcoming examples will focus on class behavior and involve casting between classes.</p> <p>Reinterpret cast is the most dangerous of all C++ casts, as it allows converting any pointer type to any other pointer type, even if they are unrelated. Unlike <code>static_cast</code>, which ensures some level of type safety, <code>reinterpret_cast</code> simply reinterprets the memory without any validation.</p> <p>The <code>reinterpret_cast</code> is commonly used in low-level programming, such as bit manipulation, working with hardware registers, or handling network protocols. It allows for type punning, which enables treating a block of memory as a different type. However, this cast should be used with caution, as improper usage can lead to undefined behavior and memory corruption.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Data {\n    int x;\n    float y;\n};\n\nint main() {\n    Data data = { 42, 3.14f };\n\n    int* int_ptr = reinterpret_cast&lt;int*&gt;(&amp;data);\n\n    std::cout &lt;&lt; \"Interpreted int: \" &lt;&lt; *int_ptr &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Interpreted int: 42\n</code></pre> <p><code>reinterpret_cast</code> can also convert a pointer into an integer type (<code>uintptr_t</code>), which may be useful in low-level debugging or custom memory management, but should generally be avoided in high-level C++ code.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\nint main() {\n    int value = 42;\n    int* ptr = &amp;value;\n\n    uintptr_t address = reinterpret_cast&lt;uintptr_t&gt;(ptr);\n\n    std::cout &lt;&lt; \"Memory address: \" &lt;&lt; address &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Memory address: 140727907748748\n</code></pre>"},{"location":"05%20Data%20Types/#cast-rules","title":"Cast Rules","text":"<p>Casting should be avoided whenever possible. If explicit conversion is required, consider alternative approaches before resorting to a cast. C++ provides safer mechanisms, such as uniform initialization syntax and automatic type inference, which can help minimize unnecessary conversions.</p> <p>General Guidelines for Casting:</p> <ul> <li>Prefer explicit casting over implicit casting whenever possible.</li> <li>Use uniform initialization (<code>T2{T1}</code>) and <code>auto</code> to reduce unnecessary implicit conversions.</li> <li>During code reviews, scrutinize casts carefully and require clear documentation explaining their necessity. Polymorphism is a valid justification.</li> <li>If casting is unavoidable, document its usage with well-written comments next to each cast or group of casts.</li> <li>Avoid C-style casts (<code>(T)expression</code>), as they are unsafe, bypass type checks, and make code harder to maintain.</li> <li>Do not misuse <code>reinterpret_cast</code> unless you fully understand the potential consequences.</li> <li>Do not remove <code>const</code> qualifiers unless absolutely necessary, as it can lead to unintended side effects.</li> </ul>"},{"location":"05%20Data%20Types/#automatic-type-inference","title":"Automatic Type Inference","text":"<p>Info</p> <p>Before diving into this section, it\u2019s helpful to have a grasp of collections of data, since type inference often involves more complex types like containers and iterators.</p> <p>In C++, data types determine what kind of data a variable can hold and how much memory it uses. Manually specifying types can sometimes be tedious or verbose\u2014especially when the type is obvious from the context. That\u2019s where the auto keyword comes in: it lets the compiler automatically deduce the variable\u2019s type based on its initializer, assignment, or the return value of a function.</p> <p>Using auto can simplify your code and make it more concise, but it\u2019s not without trade-offs. Overusing it may reduce readability, making it harder to quickly understand what a variable represents. It can also introduce subtle bugs if the inferred type doesn\u2019t match your intentions, especially as your code evolves over time.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstd::string GetName() {\n    return \"name\";\n}\n\nint main() {\n    auto name = GetName(); // inferred as std::string\n\n    // safe, std::string supports .size()\n    std::cout &lt;&lt; \"String size: \" &lt;&lt; name.size();\n}\n</code></pre> output<pre><code>String size: 4\n</code></pre> <p>Here, name is correctly inferred as <code>std::string</code>. However, if the return type of <code>GetName()</code> were changed to <code>const char*</code>, this code would no longer compile\u2014C-style strings don\u2019t support the <code>.size()</code> method.</p> <p>This is a good example of how type inference can become fragile when the underlying return type changes. In such cases, using an explicit type can help make your code more predictable.</p> <p>One place where auto truly shines is in range-based for loops, where the element type is usually obvious and unlikely to change.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nint main() {\n    std::array&lt;int, 5&gt; array{17, 48, 92, 64, 88};\n\n    for (const auto&amp; element : array) {\n        std::cout &lt;&lt; element &lt;&lt; '\\t';\n    }\n}\n</code></pre> output<pre><code>17  48  92  64  88\n</code></pre> <p>Here, <code>auto</code> makes the loop cleaner and more readable, without sacrificing clarity or safety. Since the type of element is tightly bound to the container, there's little risk of confusion or error.</p>"},{"location":"05%20Data%20Types/#volatile-specifier","title":"Volatile Specifier","text":"<p>The <code>volatile</code> keyword acts as a directive to the compiler\u2019s optimizer: \"Do not cache this value.\" It informs the compiler that a variable's state can be altered by external factors\u2014such as hardware, an interrupt, or a signal\u2014that the compiler cannot see. Consequently, the program must re-read the variable from memory every single time it is referenced, rather than relying on a previously stored value in a CPU register.</p> <p>Normally, compilers aggressively optimize code by caching values in registers, reordering instructions, or eliminating repeated reads. For most variables, this is exactly what we want\u2014it makes programs faster. However, in some low-level scenarios, these assumptions are incorrect.</p> <p>A variable should be declared volatile when its value can change due to external factors, such as:</p> <ul> <li>Hardware devices (Status registers)</li> <li>Signal handlers (Interacting with a running program)</li> <li>Memory-mapped I/O (Communicating with peripherals)</li> </ul> <p>In these cases, every read and write must go directly to memory.</p> example<pre><code>#include &lt;iostream&gt;\n#include &lt;csignal&gt;\n\nvolatile bool stop_flag = false;\n\nvoid handle_signal(int signal) {\n    stop_flag = true; \n}\n\nint main() {\n    // Register the handler for Ctrl+C (SIGINT)\n    std::signal(SIGINT, handle_signal);\n\n    std::cout &lt;&lt; \"Waiting for Ctrl+C...\\n\";\n\n    while (!stop_flag) {\n        // The compiler might optimize this into an infinite loop\n    }\n\n    std::cout &lt;&lt; \"Signal received! Exiting ...\";\n}\n</code></pre> <p>Without <code>volatile</code>, the compiler might assume that <code>stop_flag</code> never changes inside the loop and aggressively optimize the code\u2014potentially turning the loop into an infinite one. By marking the variable as <code>volatile</code>, we explicitly tell the compiler that its value may change unexpectedly, forcing it to reload the value from memory on every iteration.</p> <p>It\u2019s important to be precise about what it actually guarantees.</p> <p>When a variable is declared <code>volatile</code>, the compiler is prevented from optimizing away reads and writes to that variable. Every access is performed directly against memory rather than being cached in a register. This ensures correct behavior when the value can change outside the normal flow of the program, such as through hardware or external events.</p> <p>Note</p> <p><code>volatile</code> should be used only in situations where the compiler\u2019s normal assumptions about program flow do not hold. This typically includes low-level programming tasks such as interacting with hardware, working with memory-mapped registers, responding to signal handlers, or writing embedded or systems-level code.</p> <p>In regular application code, volatile is rarely needed. If you find yourself wanting to use it in ordinary logic, it\u2019s often a sign that a different design or abstraction would be more appropriate.</p>"},{"location":"05%20Data%20Types/#register-specifier","title":"Register Specifier","text":"<p>Same as <code>volatile</code> the <code>register</code> specifier acts as a hint to the compiler suggesting that a variable should be stored in a CPU register rather than in memory. The motivation was simple: accessing registers is faster than accessing memory, so keeping frequently used variables in registers could improve performance.</p> <p>In early C and C++ compilers, this hint could sometimes make a noticeable difference. Developers would mark loop counters or heavily used variables as register in an attempt to reduce memory access overhead.</p> example<pre><code>int main() {\n    register int counter = 0;\n\n    for (counter = 0; counter &lt; 10; ++counter) {\n        // work...\n    }\n}\n</code></pre> <p>However, modern compilers are far better at optimization than humans. They perform sophisticated analysis to decide which variables should live in registers, how long they should stay there, and when spilling to memory is necessary. As a result, the register keyword is almost always ignored by today\u2019s compilers.</p> <p>In fact, starting with C++17, <code>register</code> has been officially deprecated. Using it no longer provides any performance benefit and may even trigger warnings in some compilers.</p> <p>Note</p> <p>Although <code>register</code> no longer influences optimization, it still has one observable effect: you cannot take the address of a variable inside of a register. This restriction exists because a variable stored purely in a register does not have a stable memory address.</p>"},{"location":"05%20Data%20Types/#determining-the-byte-size-of-variables","title":"Determining the Byte Size of Variables","text":"<p>We can get the byte size of any variable using the <code>sizeof</code> operator.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    double value = 145.32;\n\n    std::cout &lt;&lt; \"Byte size of double is: \" &lt;&lt; sizeof(value);\n}\n</code></pre> output<pre><code>Byte size of double is: 8\n</code></pre>"},{"location":"05%20Data%20Types/#compile-time-constructs","title":"Compile-Time Constructs","text":"<p>In the introduction chapter, we introduced the idea of constants\u2014variables that are meant to remain unchanged throughout a program's execution. However, we later saw that <code>const</code> can be bypassed with <code>const_cast</code>, which means it doesn't provide absolute immutability. This is generally a bad design choice, as it violates the principle that constants should truly be constant.</p> <p>To ensure a variable or function is genuinely immutable and can be evaluated at compile time, modern C++ provides the <code>constexpr</code> keyword. This is also a type-safe alternative to the old preprocessor macros like <code>#define</code> and offers a more reliable way to express intent in your code.</p>"},{"location":"05%20Data%20Types/#constexpr","title":"Constexpr","text":"<p>The <code>constexpr</code> keyword guarantees that a variable or function is evaluated at compile time. This is especially useful for constants, mathematical functions, and lookup tables that should not change during the program\u2019s lifetime.</p> <p>Unlike <code>const</code>, which merely promises not to modify a variable after initialization, <code>constexpr</code> enforces that the value is computed before runtime. It Allows the compiler to optimize your code by \"hard baking\" the result directly into the binary.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\n// Compile-time constant\nconstexpr int value = 20;\n\n// Compile-time function\nconstexpr int Add(int a, int b) {\n    return a + b + value;\n}\n\nint main() {\n    std::cout &lt;&lt; Add(5, 10) &lt;&lt; '\\n';\n\n    /*\n        After compilation, it becomes this:\n        std::cout &lt;&lt; 5 + 10 + 20 &lt;&lt; '\\n';\n    */\n}\n</code></pre> output<pre><code>35\n</code></pre>"},{"location":"05%20Data%20Types/#consteval-and-constinit","title":"Consteval and Constinit","text":"<p>Warning</p> <p>This is a feature of C++20, so make sure you are using a compatible compiler version to avoid build errors.</p> <p>Modern compilers have become quite good at determining which expressions can be evaluated at compile time, making <code>constexpr</code> slightly less explicit than it once was. However, if you need to guarantee that a function or variable is evaluated at compile time, you should use <code>consteval</code> for functions and <code>constinit</code> for variables.</p> <ul> <li><code>consteval</code> ensures a function is always evaluated at compile time. It cannot accept runtime values as arguments, making it ideal for functions that should never execute at runtime.</li> <li><code>constinit</code> guarantees that a variable is initialized at compile time. It can only be used with static or thread-local variables and requires a constant expression as its initializer, like a literal or a <code>consteval</code> function. It cannot be used in function scope, as it is specifically intended for variables with static storage duration.</li> </ul> <p>Keep in mind that <code>constinit</code> cannot be used with automatic (local) variables, and trying to initialize it with a runtime value will result in a compile error.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nconsteval int GetValue() {\n    return 42;\n}\n\nconstinit int global_value = GetValue();\n\nint main() {\n    std::cout &lt;&lt; global_value &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>42\n</code></pre>"},{"location":"05%20Data%20Types/#padding-and-alignment","title":"Padding and Alignment","text":"<p>Info</p> <p>This section covers advanced memory management concepts, including how data is organized in memory and how to optimize it. This knowledge is generally not required unless you are working in performance-critical or low-level systems.</p> <p>Padding and alignment refer to how data is organized in memory. Every data type has specific alignment requirements, meaning it must be stored at memory addresses divisible by its size to ensure efficient access. If these requirements are not met, the compiler adds padding to fill the gaps, potentially wasting memory.</p> <p>For example, an <code>int</code> typically requires 4-byte alignment, meaning it must start at a memory address divisible by 4.</p> <pre><code>byte: 00 -&gt; If an `int` is placed here, it will occupy 4 bytes\nbyte: 01\nbyte: 02\nbyte: 03\nbyte: 04 -&gt; The next `int` can start here\nbyte: 05\nbyte: 06\nbyte: 07\nbyte: 08 -&gt; Or here\n</code></pre> <p>We can retrieve the alignment requirement of any data type by including the <code>&lt;type_traits&gt;</code> header, which provides the <code>std::alignment_of_v&lt;T&gt;</code> operator. The <code>_v</code> suffix stands for \"value\" and is a shorthand that gives you the result directly, rather than as a type like <code>int</code>.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Alignment of integer: \"&lt;&lt; std::alignment_of_v&lt;int&gt; &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Alignment of integer: 4\n</code></pre> <p>This concept is especially important when creating structs. If the alignment is not correct, the compiler will automatically add padding to ensure proper alignment, potentially wasting otherwise usable memory.</p> <p>Tip</p> <p>To detect padding and alignment issues, you can use Clang's <code>-Wpadded</code> compile flag, which will emit warnings for potentially inefficient struct layouts. Additionally, clang-tidy offers checks like <code>clang-analyzer-optin.performance.Padding</code> for deeper analysis. Unfortunately, MSVC and GCC do not have direct equivalents, so manual inspection or static analysis tools may be necessary for those compilers.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Entity {              // Total: 19 bytes \n    char rank;               // 1 byte\n    int level;               // 4 bytes\n    char type;               // 1 byte\n    int health;              // 4 bytes\n    long long experience;    // 8 bytes\n    char status;             // 1 byte\n};\n\nint main() {\n    std::cout &lt;&lt; \"Size of entity: \" &lt;&lt; sizeof(Entity) &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Size of entity: 32\n</code></pre> <p>As we can see from this example, the original struct wastes 13 bytes of memory due to padding, resulting in approximately 75% overhead. This happens because each member must be aligned according to its alignment requirements, leaving gaps in memory.</p> <pre><code>byte: 00 -&gt; 'rank'       (1 byte)  \nbyte: 01 -&gt; padding  \nbyte: 02 -&gt; padding  \nbyte: 03 -&gt; padding  \nbyte: 04 -&gt; 'level'      (4 bytes) - 3 bytes lost  \n...  \nbyte: 08 -&gt; 'type'       (1 byte)  \nbyte: 09 -&gt; padding  \nbyte: 10 -&gt; padding  \nbyte: 11 -&gt; padding  \nbyte: 12 -&gt; 'health'     (4 bytes) - 3 bytes lost  \n...  \nbyte: 16 -&gt; 'experience' (8 bytes) - 4 bytes lost  \n...  \nbyte: 24 -&gt; 'status'     (1 byte)  - 3 bytes lost  \nbyte: 25 -&gt; padding  \nbyte: 26 -&gt; padding  \nbyte: 27 -&gt; padding\n</code></pre> <p>We can significantly reduce padding by reordering the struct members from largest to smallest data types. This approach minimizes internal fragmentation, though some padding may still remain at the end, as it is platform-dependent and cannot be completely eliminated.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct Entity {              // Total: 19 bytes \n    long long experience;    // 8 bytes\n    int level;               // 4 bytes\n    int health;              // 4 bytes\n    char rank;               // 1 byte\n    char status;             // 1 byte\n    char type;               // 1 byte\n};\n\nint main() {\n    std::cout &lt;&lt; \"Size of entity: \" &lt;&lt; sizeof(Entity) &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Size of entity: 20 or 24\n</code></pre>"},{"location":"05%20Data%20Types/#difference-between-alignment-and-size","title":"Difference Between Alignment and Size","text":"<p>While <code>sizeof</code> gives you the total memory size (in bytes) that a type occupies\u2014including any internal padding\u2014<code>std::alignment_of_v&lt;T&gt;</code> tells you the alignment requirement of the type T.</p> Expression Description <code>sizeof(T)</code> How much space an object of type <code>T</code> takes up <code>std::alignment_of_v&lt;T&gt;</code> How that object must be aligned in memory <p>Alignment ensures that variables are placed in memory in a way that\u2019s efficient for the CPU. On many systems, certain types must be aligned to memory addresses divisible by 4, 8, 16, etc. Misalignment can lead to performance penalties or even runtime errors on strict architectures.</p>"},{"location":"05%20Data%20Types/#type-punning","title":"Type Punning","text":"<p>Info</p> <p>This section covers advanced memory management concepts, including how data is organized in memory and how to optimize it. This knowledge is generally not required unless you are working in performance-critical or low-level systems.</p> <p>C++ is considered a strongly typed language, but it still allows for certain implicit conversions\u2014such as converting integers to floating-point numbers or pointers between compatible types. While variables in C++ have explicitly defined data types, the language also provides low-level memory access, giving us the ability to reinterpret data in ways that would typically be restricted in stricter languages. This flexibility comes from the ability to directly access and manipulate memory, allowing a block of memory to be treated as a different type when necessary.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 50;\n    double value = *(double*)&amp;a;\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; '\\n'; \n}\n</code></pre> output<pre><code>Value: 2.47033e-322\n</code></pre> <p>The reason why the output is so strange is that we pass the address of <code>a</code>, which is an integer (4 bytes), to an double pointer. The pointer tells the compiler that the value under this address is a <code>double</code> (8 bytes). Therefore, when we try to output it, the program reads 4 bytes past our value and accesses some unknown memory.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Entity {\n    int x;\n    int y;\n};\n\nint main() {\n    Entity e{5, 8};\n\n    int result = *(int*)((char*)&amp;e + 4);\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; result &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Value: 8\n</code></pre> <p>What is done in this example is called raw memory manipulation. This is also one of the reasons why C++ is such a powerful language: it can manipulate memory very easily and freely. While the code in this example should probably never exist in a real-world application, it demonstrates how data types are represented in memory and how they can be manipulated.</p> <p>However, what can be useful is the representation and access to memory. In the last example, we moved through the struct's values using raw memory manipulation, but it could also be easily interpreted as a C-style array, for example.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Entity {\n    int x, y;\n\n    int* CreateArrayFromEntity() {\n        return &amp;x;\n    }\n};\n\nint main() {\n    Entity e{5, 8};\n\n    int* array = e.CreateArrayFromEntity();\n\n    std::cout &lt;&lt; \"Second array value: \" &lt;&lt; array[1] &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Second array value: 8\n</code></pre> <p>Here, we just manipulate it using indices. This is possible because the <code>int</code> pointer is pointing to the address of <code>x</code>, and if it moves by four bytes (which is specified by the <code>[1]</code>), it will then point to the variable <code>y</code>. This works because structs are also organized in contiguous memory.</p>"},{"location":"05%20Data%20Types/#dynamic-typing","title":"Dynamic Typing","text":"<p>C++ is known as a statically-typed language; however, it also provides mechanisms that allow for a certain level of dynamic typing, meaning the data types of variables can be determined at runtime.</p>"},{"location":"05%20Data%20Types/#optional-data","title":"Optional Data","text":"<p>Warning</p> <p>This is a feature of C++17, so make sure you are using a compatible compiler version to avoid build errors.</p> <p>What often happens when reading from a file or another dynamic source is that the function responsible needs to return a value if it finds some text or not. The common approach is to return a signal that nothing was found \u2014 for example, returning an empty string if a file is empty or missing content. However, this isn't ideal, as it makes it hard to distinguish between missing data and intentionally empty data.</p> <p>This is where <code>std::optional</code> becomes useful; to use it, you must include the <code>&lt;optional&gt;</code> header. It is a type that holds a value that may or may not be present, stored on the stack. It provides a clear and type-safe way to represent optional data, making your code more expressive and reliable when handling uncertain results.</p> example<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nstd::string ReadFileToString(const std::string&amp; path) {\n    std::fstream stream(path);\n    if (stream) {\n        std::string result;\n\n        // Code for reading a file\n\n        stream.close();\n\n        return result;\n    }\n\n    return \"\";\n}\n\nint main() {\n    std::string data = ReadFileToString(\"data.txt\");\n    if (data != \"\") {\n        // code ...\n    }\n}\n</code></pre> <p>This approach isn\u2019t necessarily wrong, but it\u2019s not ideal either\u2014it\u2019s somewhat clunky and lacks clarity. It's similar to adding a separate flag variable to indicate whether the output was successful.</p> <p>These kinds of workarounds are unnecessary in modern C++. The cleaner solution is to use <code>std::optional</code>, which directly expresses the idea of a value that might not be present.</p> example<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;optional&gt;\n\nstd::optional&lt;std::string&gt; ReadFileToString(const std::string&amp; path) {\n    std::fstream stream(path);\n    if (stream) {\n        std::string result;\n\n        // Code for reading a file\n\n        stream.close();\n\n        return result;\n    }\n\n    return {};\n}\n\nint main() {\n    std::optional&lt;std::string&gt; data = ReadFileToString(\"data.txt\");\n    if (data) {\n        std::cout &lt;&lt; \"File was read successfully: \" &lt;&lt; *data &lt;&lt; '\\n';\n    } else {\n        std::cout &lt;&lt; \"File was not read successfully!\" &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>In this example, the use of <code>std::optional</code> explicitly indicates that the returned data may or may not be present.</p> <p>The check for the presence of data is clean and straightforward: we simply check if the <code>std::optional</code> contains a value. If it does, we dereference the optional variable to access the data. If the file reading process fails, the function returns an empty <code>std::optional</code> (i.e., the default constructor), indicating the absence of data.</p> <p>Using <code>std::optional</code> is often preferable to returning an empty string, as it avoids unnecessary string construction and copying, effectively representing a \"no value\" state without the overhead of a full string object.</p> <p>If the file could not be read and you want to set the data to a default value, you can use the <code>.value_or</code> method. This ensures that if <code>data</code> contains a value, it will be used; otherwise, the provided default value will be assigned.</p> example<pre><code>std::string value = data.value_or(\"default value\");\n</code></pre> <p>Beyond its primary use case of representing \"no value\" or a missing result, <code>std::optional</code> is also extremely useful when you need to delay initialization of a variable, especially in situations where immediate construction isn\u2019t possible or desirable.</p> <p>For example, in game development or GUI applications, you often have to wait until certain systems are initialized (like a rendering context or asset loader) before you can safely create certain objects. Instead of using raw pointers, manual flags, or heap allocation, you can wrap your object in a <code>std::optional</code> and initialize it later with the <code>.emplace()</code> method when the conditions are right.</p> example<pre><code>#include &lt;optional&gt;\n\nstruct Texture {\n    // code ... \n};\n\nstd::optional&lt;Texture&gt; player_texture;\n\nvoid LoadResources() {\n    player_texture.emplace(/* load texture here */);\n}\n</code></pre>"},{"location":"05%20Data%20Types/#multi-type-data-holder","title":"Multi-Type Data Holder","text":"<p>Warning</p> <p>This is a feature of C++17, so make sure you are using a compatible compiler version to avoid build errors.</p> <p>What often happens when handling inputs from external sources\u2014like files, command-line arguments, or network responses\u2014is that the data may come in different types. For example, a value might be a string in one case, a number in another, or something else entirely.</p> <p>This is where <code>std::variant</code> becomes useful. It allows you to store a value that could be one of several types, all in a single, type-safe variable. Think of it as a modern, type-safe union\u2014making your code more flexible without sacrificing safety or clarity.</p> <p>To use <code>std::variant</code>, you must include the <code>&lt;variant&gt;</code> header.</p> <p>Also the union is still useful for low-level optimization but does not offer type safety. When absolute optimization is not required, <code>std::variant</code> should be preferred.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;variant&gt;\n\nint main() {\n    std::variant&lt;std::string, int&gt; data;\n\n    data = \"Random\";\n    std::cout &lt;&lt; \"String variant: \" &lt;&lt; std::get&lt;std::string&gt;(data) &lt;&lt; '\\n';\n\n    data = 3;\n    std::cout &lt;&lt; \"Integer variant: \" &lt;&lt; std::get&lt;int&gt;(data) &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>String variant: Random\nInteger variant: 3\n</code></pre> <p>This is a simple example of using <code>std::variant</code> and how to retrieve its data using <code>std::get&lt;T&gt;()</code>. However, if the stored type doesn't match the requested type, it throws a bad variant access exception. To avoid this, you can use <code>std::get_if&lt;T&gt;()</code> to safely access the value only if it holds the correct type.</p> example<pre><code>// Initializer inside the statement is a C++17 feature\nif (auto value = std::get_if&lt;std::string&gt;(&amp;data)) {\n    std::cout &lt;&lt; \"String value: \" &lt;&lt; *value &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"Data does not hold a string.\" &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"05%20Data%20Types/#any-data-type","title":"Any Data Type","text":"<p>Warning</p> <p>This is a feature of C++17, so make sure you are using a compatible compiler version to avoid build errors.</p> <p>What often happens in flexible systems\u2014like plugin architectures, event dispatchers, or scripting layers\u2014is the need to store and pass around values of any type, without knowing in advance what that type will be.</p> <p>This is where <code>std::any</code> becomes useful. It is a type-safe alternative to <code>void*</code>, allowing you to store any value while preserving its type information.</p> <p>To use <code>std::any</code>, include the <code>&lt;any&gt;</code> header.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;any&gt;\n\nint main() {\n    std::any data;\n\n    data = 3;\n    std::cout &lt;&lt; \"Now holding integer: \" &lt;&lt; std::any_cast&lt;int&gt;(data) &lt;&lt; '\\n';\n\n    data = std::string(\"String\");\n    std::cout &lt;&lt; \"Now holding string: \" &lt;&lt; std::any_cast&lt;std::string&gt;(data) &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Now holding integer: 3\nNow holding string: String\n</code></pre> <p>At first glance, <code>std::any</code> may seem similar to <code>std::variant</code>, with the key difference being that <code>std::any</code> doesn't require you to specify possible types in advance. However, this flexibility is also its biggest drawback\u2014<code>std::variant</code> is often the better choice because its explicitly defined type list ensures type safety at compile time.</p> <p>For example, in the code above, we had to assign the string using <code>std::string(\"String\")</code>. If we had written just <code>\"String\"</code>, it would have been stored as a <code>const char*</code>, which could lead to a type mismatch when retrieving it with <code>std::any_cast&lt;std::string&gt;(data)</code>. With <code>std::variant</code>, this problem doesn't arise\u2014because the type must be one of the predefined options, <code>\"String\"</code> would be implicitly converted to <code>std::string</code> when matched against the allowed types.</p> <p>Additionally, <code>std::variant</code> can be more memory-efficient when working with large data types, especially if you're passing them by reference. <code>std::any</code>, on the other hand, always stores a copy of the value, which can introduce unnecessary overhead.</p> <p>In short, <code>std::any</code> should only be used when you truly need type-erased behavior and cannot determine the set of possible types in advance. Even then, the design should be reconsidered\u2014<code>std::variant</code> is in most cases the safer alternative.</p>"},{"location":"05%20Data%20Types/#rtti-run-time-type-identification","title":"RTTI (Run-Time Type Identification)","text":"<p>Run-Time Type Identification (RTTI) is a feature in C++ that allows you to determine the actual type of an object at runtime. This is useful in scenarios involving inheritance and polymorphism, particularly when working with base class pointers or references that may point to derived class objects.</p> <p>RTTI supports two key tools:</p> <ul> <li><code>typeid</code> operator</li> <li><code>dynamic_cast</code> operator</li> </ul>"},{"location":"05%20Data%20Types/#type-id","title":"Type Id","text":"<p>The <code>typeid</code> operator returns a reference to a <code>std::type_info</code> object, which contains information about the type of the expression passed to it. To use <code>typeid</code>, include the <code>&lt;typeinfo&gt;</code> header.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nclass Base { \n    virtual void dummy() {\n    }\n};\n\nclass Derived : public Base {\n};\n\nint main() {\n    Base* base_ptr = new Derived;\n\n    std::cout &lt;&lt; \"Type: \" &lt;&lt; typeid(*base_ptr).name(); // Output: Derived\n\n    delete base_ptr;\n}\n</code></pre> output<pre><code>Type: 7Derived\n</code></pre> <p>Although the output may look odd at first glance, <code>7Derived</code> is the mangled name of the <code>Derived</code> type. In many C++ compilers (like GCC or Clang), <code>typeid(...).name()</code> returns an encoded string where:</p> <ul> <li><code>7</code> indicates the number of characters in the class name (Derived has 7 letters).</li> <li>Derived is the actual class name.</li> </ul> <p>This process is called name mangling, and it's used by compilers to encode type information for linking and overloading support.</p>"},{"location":"05%20Data%20Types/#considerations-when-using-rtti","title":"Considerations When Using RTTI","text":"<ul> <li>RTTI increases memory overhead because types need to store additional information about themselves.</li> <li>Each time a <code>dynamic_cast</code> is performed, a runtime check is required to validate whether the cast is correct.</li> </ul> <p>It is possible to disable RTTI, but the process varies depending on the compiler. When RTTI is turned off, the compiler will typically generate a warning after building the project, indicating that RTTI is disabled. Additionally, <code>dynamic_cast</code> will exhibit unpredictable behavior, potentially leading to crashes or undefined results.</p>"},{"location":"05%20Data%20Types/#questions","title":"Questions","text":"question 1answer <p>What does it mean for C++ to be a statically typed language, and how does this differ from dynamic typing?</p> <p>C++ is statically typed, meaning the type of every variable must be known at compile time. In contrast, dynamically typed languages determine types at runtime.</p> question 2answer <p>Explain the difference between static typing and strong typing in C++. Why are these two concepts often confused?</p> <p>Static typing describes when types are known (at compile time), while strong typing describes how strictly the language enforces type rules.</p> question 3answer <p>Why are fixed-width integer types such as <code>int32_t</code> preferred in portable code over types like <code>int</code> or <code>long</code>?</p> <p>Fixed-width integer types such as int32_t guarantee their size across different systems and compilers. This makes them more predictable and portable than types like <code>int</code> or <code>long</code>, whose sizes depend on the platform.</p> question 4answer <p>In what situations is it more appropriate to use an unsigned integer instead of a signed one? Give two concrete examples.</p> <p>Unsigned integers should be used when negative values are unnecessary or nonsensical. Examples include color channels like RGBA values, which range from 0 to 255, and quantities such as array sizes or memory addresses, which are always non-negative.</p> question 5answer <p>What problem do bitfields solve, and why are they commonly used in low-level or memory-sensitive code?</p> <p>Bitfields allow multiple small values to be packed into a single integer by specifying how many bits each value occupies. They are useful when values only need a few bits, such as flags or small ranges, and using full bytes would waste memory.</p> question 6answer <p>What does the <code>auto</code> keyword do in C++, and what potential risks can arise if it is overused?</p> <p>The <code>auto</code> keyword lets the compiler deduce a variable\u2019s type based on its initializer or return value. Overusing <code>auto</code> can reduce clarity and make code fragile if the inferred type changes unexpectedly.</p> question 7answer <p>What guarantees does the <code>volatile</code> specifier provide?</p> <p>The volatile specifier tells the compiler not to cache a variable\u2019s value and to always read it directly from memory.</p> question 8answer <p>Why has the <code>register</code> keyword become obsolete in modern C++, and what limitation does it still impose on variables declared with it?</p> <p>The <code>register</code> keyword was originally a hint suggesting that a variable should be stored in a CPU register for performance. Modern compilers perform this optimization automatically, making the keyword obsolete and officially deprecated in C++17. Its only remaining effect is that you cannot take the address of a variable declared as register.</p> question 9answer <p>Explain the difference between <code>sizeof(T)</code> and <code>std::alignment_of_v&lt;T&gt;</code>. How do padding and alignment affect struct memory layout?</p> <p><code>sizeof(T)</code> returns the total number of bytes an object of type T occupies, including any padding. <code>std::alignment_of_v&lt;T&gt;</code> returns the alignment requirement for that type in memory. Padding is added by the compiler to satisfy alignment rules, which can increase the size of structs and affect memory.</p> question 10answer <p>Compare <code>std::optional</code>, <code>std::variant</code>, and <code>std::any</code>. In what situations should each be used, and why is <code>std::variant</code> often preferred over <code>std::any</code>?</p> <p><code>std::optional</code> represents a value that may or may not be present. <code>std::variant</code> stores one value from a predefined set of types in a type-safe way. <code>std::any</code> can store a value of any type, but at the cost of weaker compile-time guarantees and potential overhead. In most cases, <code>std::variant</code> is preferred over <code>std::any</code> because it enforces type safety at compile time.</p>"},{"location":"05%20Data%20Types/#exercises","title":"Exercises","text":""},{"location":"06%20Pointers%20and%20References/","title":"06 Pointers and References","text":"<p>Now, we arrive at one of the most feared topics in C/C++, pointers. Many people associate pointers with confusion, often because they tend to overthink them. In reality, pointers are quite simple once you understand the core concept.</p> <p>A pointer is essentially an integer that represents a memory address. Think of computer memory as a long, one-dimensional array of bytes, each with a unique address, like houses lined up along a street. Just as we wouldn\u2019t physically move a house to show someone what it looks like, but instead give them its address so they can go and take a look, a pointer stores the address of a specific block of memory. This approach allows programs to work directly with data without unnecessary duplication.</p> Address 1 2 3 4 ... Byte Byte 1 Byte 2 Byte 3 Byte 4 ... Value 0000 0101 0000 1001 0000 0010 0000 0000 ... <p>Pointers are extremely important because everything in computing involves reading and writing to memory. While you can write C/C++ code without directly using pointers, they offer a powerful way to manage memory.</p> <p>It is also important to note that pointers themselves aren\u2019t tied to specific data types. Whether you're dealing with characters, booleans, integers, or any other data type, a pointer is still just a number representing a memory address. The reason we specify a type for pointers is to indicate how much data should be read or written at that memory location.</p>"},{"location":"06%20Pointers%20and%20References/#memory-allocation","title":"Memory Allocation","text":"<p>Memory (RAM) is where our program is loaded and where it stores data. It is divided into two distinct regions: the stack and the heap. The stack is typically a fixed-size memory area, often around 2 MB (depending on the platform), while the heap grows dynamically as the application runs\u2014though it is still limited by the system and available memory.</p> <p>A common misconception is that the stack and heap are stored in the CPU cache, but they actually reside in RAM. These regions serve as the primary storage areas for variables and other essential data during program execution.</p> <p>While both stack and heap memory allow us to read and write data, they differ significantly in how memory is allocated and managed. For example, when storing an integer (typically 4 bytes), stack memory is automatically allocated and freed based on scope\u2014once the scope is exited, the memory is released. In contrast, heap memory must be explicitly allocated and deallocated by the programmer, and it persists until it is manually freed. This act of requesting memory is known as memory allocation.</p>"},{"location":"06%20Pointers%20and%20References/#object-lifetimes","title":"Object Lifetimes","text":"<p>The stack region in memory can be imagined as a stack of books, to access a book in the middle, you must first remove the ones on top. In a computers, instead of books, we push stack frames onto the stack.</p> <p>When a function is called, a stack frame is created to store local variables, function parameters, return address, and other necessary information like saved registers and the previous stack frame pointer. This structure allows the function to execute and return properly, maintaining the state of the program during its execution. Once the function ends, the stack frame is automatically removed, and all variables within it are cleared from memory.</p> <p>Scopes in C++ are not limited to functions; classes, statements, and loops also have their own scopes. Additionally, we can create an isolated scope by enclosing code within curly brackets inside the <code>main</code> function or any other part of the program. Variables declared inside such a block exist only within that scope and are destroyed once the block ends.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    {\n        int number = 16;\n        std::cout &lt;&lt; number &lt;&lt; '\\n';\n    }\n\n    std::cout &lt;&lt; number;\n}\n</code></pre> output<pre><code>Error: 'number' was already cleared from memory because the scope in which it was declared has ended.\n</code></pre> <p>On the other hand, objects allocated on the heap persist until they are manually deallocated or handled by automatic mechanisms like smart pointers. Failing to free heap memory can lead to memory leaks, where allocated memory is never reclaimed, or heap exhaustion, where excessive allocations exceed the available heap space, potentially causing a crash.</p> example<pre><code>int* CreateArray() {\n    int array[50];  // Local array on the stack\n    return array;   // Returning a pointer to stack memory (dangerous!)\n}\n\nint main() {\n    int* array = CreateArray(); // Dangling pointer!\n}\n</code></pre> <p>This is a very common mistake, returning a pointer to a local stack-allocated array\u2014or variables in general. Since the array is created inside the function, it only exists within that function's scope. Once the function returns, the stack frame is destroyed, and the array no longer exists, leaving us with a dangling pointer that points to invalid (or corrupted) memory.</p>"},{"location":"06%20Pointers%20and%20References/#raw-pointers","title":"Raw Pointers","text":"<p>We will start by introducing <code>void*</code> (void pointer), a generic pointer that is not associated with any specific data type. It can store the address of any variable, but since it lacks type information, we cannot directly read from or write to the memory it points to\u2014we don't know how many bytes belong to it without first converting it to a specific pointer type. This reinforces the idea that pointers are simply memory addresses, independent of data types.</p>"},{"location":"06%20Pointers%20and%20References/#declaring-pointers","title":"Declaring Pointers","text":"<p>Pointers are declared by appending an asterisk to a data type, followed by the variable name. The <code>*</code> symbol is known as the dereference operator, which allows us to access the value stored at the memory address the pointer holds.</p> example<pre><code>int main() {\n    void* ptr1 = 0;\n\n    void* ptr2 = NULL;\n\n    void* ptr3 = nullptr;\n}\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#null-pointers","title":"Null Pointers","text":"<p>In the example above, we assigned <code>0</code> to a pointer. Since memory addresses do not start at zero, <code>0</code> is an invalid memory address. However, having an invalid address is a perfectly acceptable state for a pointer, as it indicates that the pointer is not currently pointing to valid memory.</p> <p>We also used <code>NULL</code>, which is simply a macro-defined constant representing <code>0</code>. While it functions the same as writing <code>0</code> directly, it improves readability.</p> <p>Additionally, we introduced <code>nullptr</code>, a C++ keyword specifically designed to represent an invalid pointer. Unlike <code>NULL</code>, <code>nullptr</code> has stronger type safety, making it the preferred choice in modern C++.</p>"},{"location":"06%20Pointers%20and%20References/#accessing-the-memory-address-of-a-variable","title":"Accessing the Memory Address of a Variable","text":"<p>Earlier, we mentioned that everything created in a program has a memory address that points to where the data is stored. This applies even to simple integer variables, each variable resides at a unique location in memory.</p> <p>We can access a variable's address by prefixing it with <code>&amp;</code>, which is called the address-of operator (sometimes referred to as the reference operator). This operator returns the memory address of the variable, allowing us to work with its location directly.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value = 8;\n    void* ptr = &amp;value; // Storing the memory address of 'value'\n\n    std::cout &lt;&lt; &amp;value;\n}\n</code></pre> output<pre><code>0x7ffceeb396ac\n</code></pre> <p>Note</p> <p>The actual address printed will vary every time you run the program. This is due to Address Space Layout Randomization (ASLR) \u2014 a security feature used by modern operating systems to randomize memory addresses, making certain types of attacks harder to perform.</p> <p>In this example, we assign a valid memory address to the pointer by using the address-of operator on a variable. This ensures that the pointer correctly stores the location of <code>value</code> in memory.</p>"},{"location":"06%20Pointers%20and%20References/#dereferencing-a-pointer","title":"Dereferencing a Pointer","text":"<p>We have now reached the point where we may want to retrieve the data stored at the memory address held by a pointer. To do this, we use the dereference operator as a prefix to the pointer variable. This allows us to access and manipulate the value stored at that memory location, just as we would with a regular variables.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value = 8;\n    void* ptr = &amp;value;\n\n    std::cout &lt;&lt; *ptr;\n}\n</code></pre> output<pre><code>Error: cannot dereference a void pointer\n</code></pre> <p>This will produce an error because <code>void*</code> represents a generic memory address without a specific type. While it can store the address of any data type, it cannot be dereferenced because the compiler does not know how many bytes belong to the variable at that address.</p> <p>To fix this, we need to create an <code>int*</code> pointer for an integer value, or cast it to the correct pointer type before using it.  This way, the compiler knows that 4 bytes (on most modern systems) after the address belong to the integer, allowing proper reading and writing of the data.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value = 8;\n    int* int_ptr = &amp;value;\n    void* void_ptr = &amp;value;\n\n    std::cout &lt;&lt; \"Value of pointer trough int*: \" &lt;&lt; *int_ptr &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Value of pointer trough cast to int*: \" &lt;&lt; *(int*)void_ptr;\n}\n</code></pre> output<pre><code>Value of pointer trough int*: 8\nValue of pointer trough cast to int*: 8\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#dynamic-memory-allocation","title":"Dynamic Memory Allocation","text":"<p>Up to this point, all variables have been allocated on the stack, meaning their lifetime is tied to their current scope. This is generally safe, but it also means they are automatically deleted once the scope ends, limiting their lifespan.</p> <p>To preserve the existence of important values beyond their original scope, we can use pointers in combination with the <code>new</code> keyword. This reserves memory on the heap and returns a pointer to the allocated memory.</p> <p>Using <code>new</code>, we can create variables on the heap, ensuring they remain accessible even after their original scope ends\u2014provided we manage them correctly.</p> example<pre><code>int main() {\n    char* buffer = new char[8]; // Allocate 8 bytes on the heap\n}\n</code></pre> <p>In the example above:</p> <ul> <li>We create a pointer of type <code>char*</code>.</li> <li>We use the <code>new</code> keyword to allocate 8 bytes of memory on the heap.</li> <li>Since a <code>char</code> is 1 byte in size, allocating an array of 8 chars reserves 8 contiguous bytes in memory.</li> <li>The pointer <code>buffer</code> stores the address of the first element in this allocated memory block.</li> </ul>"},{"location":"06%20Pointers%20and%20References/#initializing-heap-memory","title":"Initializing Heap Memory","text":"<p>Heap memory is not automatically initialized, meaning it can contain garbage values. To initialize memory, we can use the <code>memset</code> function from the <code>&lt;cstring&gt;</code> header file.</p> example<pre><code>#include &lt;cstring&gt;\n\nint main() {\n    char* buffer = new char[8]; // Allocate 8 bytes on the heap\n    memset(buffer, '\\0', 8);    // Set all bytes to the ASCII null character\n}\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#heap-memory-management","title":"Heap Memory Management","text":"<p>Memory allocated on the heap is not automatically freed when a variable goes out of scope. Unlike stack memory, which is managed by the compiler, heap memory must be manually deallocated to prevent memory leaks. A situation where memory is allocated but never freed, causing a program to consume increasing amounts of memory over time and potential heap overflow, which occurs when the program exhausts all available heap memory and can no longer allocate new data.</p> <p>To properly free heap memory, we use the <code>delete</code> keyword followed by the pointer holding the allocated address.</p> example<pre><code>#include &lt;cstring&gt;\n\nint main() {\n    // Allocate a single integer on the heap\n    int* ptr = new int(10);\n\n    // Allocate an array of 8 characters on the heap\n    char* buffer = new char[8];\n    memset(buffer, 0, 8);\n\n    delete ptr;       // Deallocate memory for the single integer\n    delete[] buffer;  // Deallocate memory for the character array\n}\n</code></pre> <p>When deallocating a dynamically allocated single object, we use <code>delete</code>. However, when deallocating a dynamically allocated array, we must use <code>delete[]</code> to ensure the entire block of memory is freed correctly.</p>"},{"location":"06%20Pointers%20and%20References/#constant-pointers","title":"Constant Pointers","text":"<p>By now, we understand how pointers work, how to create, manipulate, and delete them. However, there are cases where we need to enforce restrictions on either the pointer itself or the data it points to.</p> <p>A constant pointer applies specific constraints, ensuring that either the pointer\u2019s address remains unchanged, the pointed-to value cannot be modified, or both.</p>"},{"location":"06%20Pointers%20and%20References/#pointer-to-constant","title":"Pointer to Constant","text":"<p>This type of pointer cannot modify the value it points to, but it can be reassigned to another address.</p> <p>Use case: When you want to protect the data from being modified but allow the pointer to point elsewhere.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10;\n    int b = 20;\n\n    const int* ptr = &amp;a; // Pointer to a constant value\n\n    // *ptr = 15; // Error: Cannot modify the value through the pointer\n    ptr = &amp;b;     // Allowed: Pointer can be reassigned\n\n    std::cout &lt;&lt; \"Reassigned pointer to B: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Reassigned pointer to B: 20\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#constant-pointer","title":"Constant Pointer","text":"<p>This type of pointer cannot be reassigned, but it can modify the value it points to.</p> <p>Use case: When you want a pointer to always point to the same object but still allow modifications to the object.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10;\n    int b = 20;\n\n    int* const ptr = &amp;a; // Constant pointer to an integer\n\n    *ptr = 15;   // Allowed: Can modify the value through the pointer\n    // ptr = &amp;b; // Error: Cannot reassign a constant pointer\n\n    std::cout &lt;&lt; \"Modified variable A: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Modified variable A: 15\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#constant-pointer-to-constant","title":"Constant Pointer to Constant","text":"<p>This type of pointer cannot be reassigned and cannot modify the value it points to.</p> <p>Use case: When you want a pointer to always point to the same object and ensure that the object cannot be modified through the pointer.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10;\n    int b = 20;\n\n    const int* const ptr = &amp;a; // Constant pointer to a constant value\n\n    // *ptr = 15; // Error: Cannot modify value\n    // ptr = &amp;b; // Error: Cannot reassign pointer\n\n    std::cout &lt;&lt; \"Unchanged pointer value: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Unchanged pointer value: 10\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#pointer-to-pointer","title":"Pointer to Pointer","text":"<p>Since pointers are just variables that store memory addresses, it is possible to create a pointer that points to the location of another pointer. This is known as a pointer to a pointer. While it is theoretically possible to create multiple levels of pointers, doing so is impractical and rarely useful in real-world applications.</p> <p>A pointer to a pointer is created by adding an additional asterisk to a regular pointer variable. This means the first pointer stores the address of the second pointer, and the second pointer stores the address of the actual data.</p> main.cpp<pre><code>#include &lt;cstring&gt;\n\nint main() {\n    char* buffer = new char[8];\n    memset(buffer, 0, 8);\n\n    char pointer_to_buffer = &amp;buffer; // A pointer to the pointer 'buffer'\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>In this example:</p> <ul> <li><code>buffer</code> is a pointer to a block of memory on the heap.</li> <li><code>pointer_to_buffer</code> is a pointer to a pointer that holds the address of <code>buffer</code>.</li> </ul> <p>While pointers to pointers can exist, they are rarely needed and should be used only when there is a valid use case. For most applications, a single pointer is sufficient.</p>"},{"location":"06%20Pointers%20and%20References/#pointer-safety","title":"Pointer Safety","text":"<p>Working directly with addresses and heap memory comes with risks. If not handled correctly, it can lead to serious memory management errors, such as dangling pointers, memory leaks, buffer overflows, and undefined behavior.</p> <p>In this section, we will cover common pitfalls when working with pointers and best practices to write safer and more reliable C++ code.</p>"},{"location":"06%20Pointers%20and%20References/#dangling-pointers","title":"Dangling Pointers","text":"<p>A dangling pointer is a pointer that references memory that has already been freed or is no longer valid. Accessing such memory leads to undefined behavior, which can result in crashes, corrupted data, or security vulnerabilities.</p> <p>How Dangling Pointers Occur:</p> <ol> <li>Deleted Memory Access - A pointer still holds an address to memory that has already been deallocated.</li> <li>Returning Pointers to Local Variables - A pointer to a local variable is returned from a function, but the variable is destroyed when the function exits.</li> <li>Uninitialized Pointers - A pointer is used without being properly initialized, leading it to point to an arbitrary or invalid location.</li> </ol>"},{"location":"06%20Pointers%20and%20References/#memory-leaks","title":"Memory Leaks","text":"<p>A memory leak occurs when dynamically allocated memory is not properly deallocated, causing the program to consume more memory over time without releasing it. If a program continuously leaks memory, it may slow down, crash, or exhaust system resources.</p> <p>Memory leaks are particularly dangerous in long-running applications, such as servers or embedded systems, where unmanaged memory growth can lead to performance degradation or failure.</p>"},{"location":"06%20Pointers%20and%20References/#buffer-overflows","title":"Buffer Overflows","text":"<p>A buffer overflow occurs when a program writes more data into a buffer (such as an array) than it was allocated to hold. This results in overwriting adjacent memory, potentially causing program crashes, security vulnerabilities, or unpredictable behavior.</p> <p>Buffer overflows are particularly dangerous because they can corrupt data, cause segmentation faults, or be exploited by attackers to execute malicious code.</p>"},{"location":"06%20Pointers%20and%20References/#pointer-aliasing-and-ownership","title":"Pointer Aliasing and Ownership","text":"<p>Pointer aliasing occurs when multiple pointers reference the same memory location. While this can be useful, it can also lead to unintended side effects, such as modifying a value unexpectedly or causing performance issues due to compiler optimizations being invalidated.</p>"},{"location":"06%20Pointers%20and%20References/#preventions","title":"Preventions","text":"<p>Most pointer-related safety issues stem from raw pointer management and manual memory handling, which are prone to errors like memory leaks, dangling pointers, and undefined behavior.</p> <p>To avoid these risks, modern C++ provides:</p> <ul> <li>Smart Pointers (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>) - Automatically manage memory and prevent leaks.</li> <li>STL Containers (<code>std::vector</code>, <code>std::array</code>, etc.) - Provide automatic memory management and prevent buffer overflows.</li> </ul>"},{"location":"06%20Pointers%20and%20References/#pointer-arithmetic","title":"Pointer Arithmetic","text":"<p>After becoming familiar with raw pointers, one of the next important aspects to understand is how to use them in practical scenarios. This is where pointer arithmetic becomes extremely useful. Pointer arithmetic allows us to perform mathematical operations on pointers to navigate through memory locations, particularly when working with arrays or structs.</p> <p>Pointer arithmetic works by adding or subtracting integer values to pointers, which effectively adjusts the memory address they point to. The pointer itself does not store the data but holds the address of the data in memory. By performing arithmetic on pointers, we can access different elements in arrays or traverse contiguous blocks of memory.</p> <p>In the example below, pointer arithmetic is used to iterate through an array of structures.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Person {\n    char name[64];\n    int age;\n};\n\nint main() {\n    Person people[5];\n\n    Person* p_person = people; // Pointer to the first element of the array\n\n    for (int i = 0; i &lt; 5; ++i) {\n        p_person-&gt;age = 53;      // Access and modify the age of the person\n        p_person-&gt;name[0] = 'R'; // Access and modify the name of the person\n\n        p_person++; // Move the pointer to the next Person object in memory\n    }\n\n    for (int i = 0; i &lt; 5; ++i)\n      std::cout &lt;&lt; people[i].name[0] &lt;&lt; '\\t' &lt;&lt; people[i].age &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>R   53\nR   53\nR   53\nR   53\nR   53\n</code></pre> <p>Pointer arithmetic takes into account the size of the object the pointer is pointing to. In this case, when we increment <code>p_person</code>, it doesn\u2019t just move by 1 byte. It moves by the size of a <code>Person</code> object, which is 68 bytes (64 bytes for <code>name</code> and 4 bytes for <code>age</code>). This is why the pointer moves to the next <code>Person</code> in the array, not just the next byte in memory.</p> <p>This topic is further built upon in the section [[07 Data Types#Type Punning|Type Punning]].</p>"},{"location":"06%20Pointers%20and%20References/#references","title":"References","text":"<p>Pointers and references in C++ are fundamentally similar in terms of what the computer actually does. However, semantically, they have subtle differences. A reference is essentially a syntax shortcut for a pointer, making the code more readable and easier to follow.</p> <p>As the name suggests, a reference is used to refer to an existing variable. Unlike pointers, a reference cannot be null and must always be bound to a valid variable. This means you cannot set a reference to <code>nullptr</code>, and it must always refer to an existing object.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int a = 10;\n    int&amp; b = a;  // b is a reference to a\n\n    std::cout &lt;&lt; \"Reference to A: \" &lt;&lt; b &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Reference to A: 10\n</code></pre> <p>In this example, <code>b</code> is a reference to <code>a</code>, meaning it acts as an alias for <code>a</code>. Any modifications to <code>b</code> will directly affect <code>a</code>, and vice versa.</p>"},{"location":"06%20Pointers%20and%20References/#reference-vs-address-of-operator","title":"Reference vs. Address-of Operator","text":"<p>In C++, the reference operator (<code>&amp;</code>) and the address-of operator (<code>&amp;</code>) can sometimes be confusing, but they serve distinct purposes depending on their usage.</p> <ul> <li>When <code>&amp;</code> is appended to the data type, it signifies a reference. A reference is simply an alias for an existing variable, meaning it acts as another name for that variable.</li> <li>When <code>&amp;</code> is used as a prefix before a variable name, it means the address-of operator, which returns the memory address of the variable. </li> </ul>"},{"location":"06%20Pointers%20and%20References/#pass-by-value-vs-pass-by-reference","title":"Pass by Value vs. Pass by Reference","text":"<p>In C++, there are two common ways to pass data into a function: pass-by-value and pass-by-reference. Each method has its own behavior and implications.</p> <p>In pass-by-value, when we pass a variable to a function, a copy of the variable is created. The function then works with this copy, and any changes made to the parameter within the function do not affect the original variable.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid Increment(int number) {\n    number++;\n}\n\nint main() {\n    int number = 5;\n\n    Increment(number);\n\n    std::cout &lt;&lt; \"Number: \" &lt;&lt; number &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Number: 5\n</code></pre> <p>In this case, the <code>Increment()</code> function receives a copy of the <code>number</code> from <code>main()</code>. Inside the function, the copy of <code>number</code> is incremented, but the original <code>number</code> in <code>main()</code> remains unchanged. As a result, the value of <code>number</code> in <code>main()</code> stays at <code>5</code>.</p> <p>In pass-by-reference, instead of passing a copy of the variable, we pass the actual variable itself. This allows the function to modify the original variable directly, and any changes made to the parameter within the function will affect the original variable outside of the function as well.</p> <p>To pass a variable by reference, we use the reference operator in the function parameter list. </p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid Increment(int&amp; number) {\n    number++;\n}\n\nint main() {\n    int number = 5;\n\n    Increment(number);\n\n    std::cout &lt;&lt; \"Number: \" &lt;&lt; number &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Number: 6\n</code></pre> <p>In this case, the <code>Increment()</code> function receives a reference to <code>number</code>, meaning it works directly with the original <code>number</code> in <code>main()</code>. As a result, after the function call, the value of <code>number</code> in <code>main()</code> is updated to <code>6</code>.</p>"},{"location":"06%20Pointers%20and%20References/#when-to-pass-by-reference","title":"When to Pass by Reference","text":"<p>There are four main scenarios where pass-by-reference is preferred over pass-by-value:</p> <ol> <li>Modifying Arguments<ul> <li>If a function needs to modify its arguments, you should use pass-by-reference or pass-by-pointer.</li> </ul> </li> <li>Avoiding Unnecessary Copies (Efficiency)<ul> <li>When a function accepts a large object as a parameter, it's better to use pass-by-const-reference.</li> </ul> </li> <li>Copy &amp; Move Constructors<ul> <li>Copy and move constructors must always take a reference to avoid unnecessary object creation and to ensure proper copying or moving of objects.</li> </ul> </li> <li>Working with Polymorphism (Avoiding Object Slicing)<ul> <li>When working with polymorphic classes, it's essential to pass objects by reference or pointer rather than by value.</li> <li>Passing by value may lead to object slicing, where the derived class data is lost when copied into a base class object.</li> </ul> </li> </ol>"},{"location":"06%20Pointers%20and%20References/#function-pointer","title":"Function Pointer","text":"<p>So far, we have only called functions directly to execute logic. A function serves as a symbol that we invoke whenever we want to perform a specific action. We can also pass arguments to a function and retrieve values from it, which allows us to write more dynamic code.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid HelloWorld() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n\nint main() {\n    HelloWorld();\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>In this example, we have a regular function declaration with a simple definition. However, since functions are stored in memory, we can assign them to pointers.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid HelloWorld() {\n  std::cout &lt;&lt; \"Hello World!\";\n}\n\nint main() {\n\n    // Declare a function pointer 'function' and assign it the address of the 'HelloWorld' function \n    void(*function)() = HelloWorld;\n\n    function();\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>In the code above, we use function pointer. The syntax may seem a bit complex at first, so let's break it down:</p> <ol> <li>The return type of the function comes first (<code>void</code>).</li> <li>Inside the first set of parentheses, we declare the pointer (<code>*function</code>).</li> <li>The second set of parentheses defines the function parameters (which are empty in this case).</li> </ol> <p>This declaration can be simplified using the <code>auto</code> keyword, which automatically deduces the correct type.</p> <p>Another way to simplify this syntax is by creating a type alias using <code>using</code>, especially when the same type is used repeatedly.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid HelloWorld() {\n  std::cout &lt;&lt; \"Hello World!\";\n}\n\nint main() {\n    using HelloWorldFunction = void(*)();\n\n    HelloWorldFunction function = HelloWorld;\n\n    function();\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#where-to-use-function-pointers","title":"Where to Use Function Pointers","text":"<p>In this example, we define a function pointer and pass it to another function for use, showcasing how function pointers can add flexibility to code.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvoid PrintValue(const int value) {\n    std::cout &lt;&lt; value &lt;&lt; std::endl;\n}\n\nvoid ForEach(const std::vector&lt;int&gt;&amp; values, void(*func)(const int)) {\n    for (const int&amp; value : values)\n        func(value);\n}\n\nint main() {\n    std::vector&lt;int&gt; values = {1, 2, 3, 4, 5};\n\n    ForEach(values, PrintValue);\n}\n</code></pre> output<pre><code>1\n2\n3\n4\n5\n</code></pre> <p>In the example above, we pass the <code>PrintValue</code> function as a pointer to the <code>ForEach</code> function, which then uses the pointer to invoke <code>PrintValue</code> for each element in the vector.</p> <p>While function pointers can still be useful in specific cases, such as when interacting with C libraries, modern C++ prefers lambda expressions and <code>std::function</code> for more flexible, type-safe, and readable code.</p>"},{"location":"06%20Pointers%20and%20References/#lvalues-and-rvalues","title":"Lvalues and Rvalues","text":"<p>In C++, understanding lvalues and rvalues is crucial because they are fundamental concepts that appear frequently in compiler warnings, error messages, and in modern C++ features like move semantics and temporary values.</p> <p>An lvalue refers to a location value, something that has a persistent memory address. You can think of it as an object or a variable that you can modify or access.</p> <p>In contrast, an rvalue represents a temporary value, usually something that does not have a lasting memory address. These can be literals or the results of function calls that return a temporary value.</p> main.cpp<pre><code>int main() {\n    int a = 10;\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>In the example above, <code>a</code> is an lvalue because it is a variable with a specific memory location where the rvalue <code>10</code> is stored.</p> <ul> <li>An lvalue typically appears on the left side of the <code>=</code> (assignment) operator.</li> <li>You can assign values to lvalues because they have a defined memory location.</li> </ul> <p>An rvalue, however, can be more than just a literal. For example, it can be the result of a function call that returns a value. Rvalues do not refer to objects with persistent memory addresses and are typically used to represent temporary values.</p> main.cpp<pre><code>int GetValue() {\n    return 10;\n}\n\nint main() {\n    int a = GetValue();\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>In this example, the function <code>GetValue()</code> returns an rvalue because the value <code>10</code> is a temporary result. The rvalue cannot be assigned directly to another rvalue but can be assigned to an lvalue like <code>a</code>.</p>"},{"location":"06%20Pointers%20and%20References/#lvalue-reference","title":"Lvalue Reference","text":"<p>We explained that an rvalue is not limited to just literals; it can also be the result of a function call that returns a value. Additionally, we can assign a value to the result of a function call.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint PrintValue() {\n    std::cout &lt;&lt; 10 &lt;&lt; std::endl;\n}\n\nint main() {\n    PrintValue() = 5;\n}\n</code></pre> output<pre><code>Error: expression must be a modifiable lvalue\n</code></pre> <p>The error happens because a function typically returns an rvalue, meaning a temporary value that cannot be assigned to. However, this is not always true, when a function contains a static variable, that variable persists across function calls and can be modified. By returning a reference to a static variable, we allow the function to return an lvalue, making it possible to modify the value directly.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint&amp; GetValue() {\n    static int value = 1;\n    return value;\n}\n\nint main() {\n    GetValue() = 5; // Reassing PrintValue() static variable to 5\n\n    std::cout &lt;&lt; \"Function value: \" &lt;&lt; GetValue() &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Function value: 5\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#rvalue-reference","title":"Rvalue Reference","text":"<p>We have learned that when passing variables as function arguments, they are copied into a new variable created inside the function. While passing them as lvalue references can improve performance, it also prevents passing literal values because an lvalue reference cannot bind to an rvalue (a temporary value). To work around this, we can declare the parameter as <code>const</code>, which allows temporary values (rvalues) to be assigned to a temporary variable behind the scenes. The compiler creates a temporary variable, assigns the literal value to it, and then binds it to the lvalue reference.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid PrintFunction(const int&amp; value) {\n    std::cout &lt;&lt; value &lt;&lt; std::endl;\n}\n\nint main() {\n    int a = 10;\n\n    PrintFunction(a); // Normal pass by reference\n    PrintFunction(5); // Pass rvalue by reference\n}\n</code></pre> <p>That is why most C++ functions declare parameters as <code>const</code> lvalue references (<code>const type&amp;</code>), allowing them to efficiently accept both lvalues and rvalues. However, it is also possible to create a function parameter that accepts only temporary values (rvalues) by appending the type with <code>&amp;&amp;</code>, which is known as an rvalue reference.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nvoid AcceptLvalueAndRvalue(const int&amp; value) {} // Accepts both\nvoid AcceptOnlyRvalue(int&amp;&amp; value) {}           // Accepts only rvalues\n\nint main() {\n    int x = 5;\n\n    AcceptLvalueAndRvalue(x);  \n    AcceptLvalueAndRvalue(10);\n\n    AcceptOnlyRvalue(10);\n}\n</code></pre> <p>It is considered good practice to overload a function in modern medium-to-large projects if we want to support both lvalues and rvalues while maximizing performance. By having an overload for <code>const lvalue reference</code> (which can accept both lvalues and rvalues) and another for <code>rvalue reference</code>, the compiler will always prefer the more specific overload when an rvalue is passed. The key difference is that an rvalue reference (<code>&amp;&amp;</code>) allows moving resources from the source, as it indicates that the variable is temporary and will not persist for long. On the other hand, a <code>const lvalue reference</code> (<code>const int&amp;</code>) signals that the variable is important, cannot be modified, and is passed by reference to avoid unnecessary copying.</p>"},{"location":"06%20Pointers%20and%20References/#move-semantics","title":"Move Semantics","text":"<p>To fully understand this chapter, it is recommended to first reviewing and familiarizing yourself with [[08 Data Structures#Strings|Strings]] and [[09 User-Defined Types]].</p> <p>So far, we have been introduced to lvalues and rvalues, but this is where their true purpose becomes clear. Move semantics allows us to transfer ownership of resources from one object to another, rather than copying or referencing them. This is particularly useful when we want to avoid the overhead of creating a duplicate and instead reuse existing resources, transferring ownership to a new scope.</p> <p>Note</p> <p>The original object is typically left in a moved-from state, meaning it is still valid but its contents are unspecified.</p> <p>For example, when passing an object into a function that takes ownership, we would normally copy it. The same applies when returning an object from a function, we first create the object in the current stack frame and then copy it into the caller's scope. This is not ideal, as we must construct it in one place and copy it to another, leading to unnecessary overhead.</p> <p>For simple types like numbers or small structs, this overhead is minimal. However, for complex classes, such as <code>std::string</code>, copying becomes expensive due to heap allocations. Move semantics solves this problem by transferring ownership instead of copying the object, significantly reducing memory operations and improving performance.</p> main.cpp<pre><code>#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n\n#include &lt;iostream&gt;\n\nclass String {\npublic:\n    String() : data_(nullptr), size_(0) {\n        // remains empty\n    }\n\n    // Constructor that creates a new string from a C-string\n    String(const char* string) {\n        printf(\"Created!\\n\");\n        size_ = strlen(string);\n        data_ = new char[size_ + 1];\n        memcpy(data_, string, size_);\n        data_[size_] = '\\0';\n    }\n\n    // Copy constructor\n    String(const String&amp; other) {\n        printf(\"Copied!\\n\");\n        size_ = other.size_;\n        data_ = new char[size_ + 1];\n        memcpy(data_, other.data_, size_);\n        data_[size_] = '\\0';\n    }\n\n    // Move constructor\n    String(String&amp;&amp; other) noexcept\n        : data_(other.data_), size_(other.size_) {\n        printf(\"Moved!\\n\");\n        other.data_ = nullptr;  // Reset the other object\u2019s data pointer\n        other.size_ = 0;        // Reset the other object\u2019s size\n    }\n\n    ~String() {\n        printf(\"Destroyed!\\n\");\n        delete[] data_;\n    }\n\n    void Print() const {\n        printf(\"%s\\n\", data_);\n    }\n\n    const char* GetData() const {\n        return data_;\n    }\n\nprivate:\n    char* data_;\n    uint32_t size_;\n};\n\nclass Entity {\npublic:\n    // Copy constructor\n    Entity(const String&amp; name)\n        : name_(name) {\n    }\n\n    // Move constructor\n    Entity(String&amp;&amp; name)\n        : name_(std::move(name)) {\n    }\n\n    void PrintName() const {\n        printf(\"%s\\n\", name_.GetData());\n    }\n\nprivate:\n    String name_;\n};\n\nint main() {\n    // Creating an entity with an rvalue (temporary String object)\n    Entity entity(String(\"Random String\"));\n    entity.PrintName();\n}\n</code></pre> output<pre><code>Created!\nMoved!\nDestroyed!\nRandom String\nDestroyed!\n</code></pre> <p>This is a large example of implementing a custom string class. However, it should not be considered a proper way to build a string class for real-world applications. It uses a lot of C-style memory management, which is not ideal for production code. The purpose of this example is purely to demonstrate how copying and moving work in C++.</p> <p>By adding logs inside the copy constructor and move constructor, we can clearly observe the difference between copying and moving an object:</p> <ul> <li>The copy constructor (<code>String(const String&amp; other)</code>) duplicates the resource by allocating new memory and copying the data from the source object.</li> <li>The move constructor (<code>String(String&amp;&amp; other) noexcept</code>) steals the resource from the temporary object (<code>other</code>) by transferring the pointer to the new object, rather than copying the data. After the transfer, the original object is detached by setting its pointer to <code>nullptr</code> and its size to <code>0</code>.</li> </ul> <p>This behavior makes moving much more efficient than copying, especially for large objects that allocate memory on the heap, such as strings or vectors. By moving rather than copying, we avoid unnecessary memory allocations and reduce performance overhead.</p>"},{"location":"06%20Pointers%20and%20References/#standard-move-function","title":"Standard Move Function","text":"<p>After understanding rvalue references, move constructors, and their benefits, it\u2019s time to introduce <code>std::move</code>, a function that allows us to explicitly move objects instead of copying them.</p> <p>We\u2019ll refer back to the <code>String</code> example from the section [[#Move Semantics|Move Semantics]], where we used <code>std::move</code> to transfer ownership of a temporary string into <code>m_Name</code> inside the <code>Entity</code> class. To simplify the explanation, we\u2019ll now demonstrate <code>std::move</code> using just variables of our custom <code>String</code> class.</p> main.cpp<pre><code>int main() {\n    String string1 = \"Random\";\n    String string2 = string1; // string1 is copied into string2\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>In this example, <code>string1</code> is copied into <code>string2</code> because it is an lvalue (a named variable). However, if we want to move its resources to <code>string2</code> instead of copying them, we need to treat <code>string1</code> as a temporary value (rvalue), because the move constructor requires an rvalue reference.</p> <p>One way to do this is by casting <code>string1</code> to an rvalue reference using <code>(String&amp;&amp;)</code>. However, this approach is not ideal and does not work with variables deduced using <code>auto</code>.</p> <p>To solve this, we use <code>std::move</code>, which efficiently converts an lvalue into an rvalue, allowing us to move the resource without unnecessary copies. It also makes the intention clear in the code, signaling that we are intentionally transferring ownership rather than copying.</p> main.cpp<pre><code>int main() {\n    // Not recommended: Casting to rvalue reference\n    // String string1 = \"Random\";\n    // String string2((String&amp;&amp;)string1);\n\n    String string1 = \"Random\";\n    String string2(std::move(string1)); // Proper way to move\n}\n</code></pre> output<pre><code>None\n</code></pre>"},{"location":"06%20Pointers%20and%20References/#move-assignment-operator","title":"Move Assignment Operator","text":"<p>Using <code>std::move</code> inside a constructor is not the same as using it after an assignment operator. Constructors are responsible for creating objects, while the assignment operator replaces an existing object's contents. Since operators behave like regular functions, we need to explicitly define a move assignment operator to enable move semantics during assignment.</p> main.cpp<pre><code>class String {\n    // Implementation of Regular, Copy, and Move Constructor from before\n\n    String&amp; operator=(String&amp;&amp; other) {\n        printf(\"Moved!\\n\");\n\n        if (this != &amp;other) {\n            delete[] data_;\n\n            data_ = other.data_;\n            size_ = other.size_;\n\n            other.data_ = nullptr;\n            other.size_ = 0;\n        }\n\n        return *this;\n    }\n};\n</code></pre> <p>The self-assignment check (<code>if (this != &amp;other)</code>) is crucial. If we mistakenly attempt to move an object into itself.</p> <pre><code>str = std::move(str); // Dangerous\n</code></pre> <p>Without this check, the move logic would detach the object\u2019s own data, leaving it in an invalid state. This could lead to double deletion when the destructor runs, causing undefined behavior. By verifying that <code>this</code> and <code>other</code> are different objects, we prevent accidental self-moves.</p> <p>A move constructor is used when creating a new object from an existing one, while a move assignment operator is used when an existing object is reassigned.</p> <p>A general rule in C++ is that if you implement a move constructor, you should also provide a move assignment operator, as both serve distinct but complementary purposes.</p>"},{"location":"06%20Pointers%20and%20References/#smart-pointers","title":"Smart Pointers","text":"<p>So far, we have relied on C-style raw pointers with <code>new</code> and <code>delete</code>, requiring manual memory management. However, this approach is error-prone, as forgetting to call <code>delete</code> can lead to memory leaks, while deleting memory incorrectly can cause undefined behavior.</p> <p>To address these issues, C++ introduced smart pointers, which automate memory allocation and deallocation. Smart pointers wrap around raw pointers and, depending on their type, automatically free memory when it is no longer needed.</p> <p>Instead of using <code>new</code> directly, smart pointers provide factory functions (e.g., <code>std::make_unique</code>, <code>std::make_shared</code>), which should be preferred as they:</p> <ul> <li>Improve exception safety by ensuring memory is allocated and assigned in one step.</li> <li>Simplify code by eliminating explicit calls to <code>new</code> and <code>delete</code>.</li> </ul> <p>To use smart pointers, include the <code>&lt;memory&gt;</code> header from the C++ Standard Library.</p>"},{"location":"06%20Pointers%20and%20References/#unique-pointer","title":"Unique Pointer","text":"<p>A unique pointer is a scoped smart pointer, meaning it automatically deallocates the allocated memory when it goes out of scope. This eliminates the need for manual <code>delete</code> calls and helps prevent memory leaks.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass Entity {\npublic:\n    Entity() {\n        std::cout &lt;&lt; \"Entity Created!\" &lt;&lt; std::endl;\n    }\n\n    ~Entity() {\n        std::cout &lt;&lt; \"Entity Destroyed!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    /*\n        Not recommended: manual allocation with new is valid but incorrect\n        std::unique_ptr&lt;Entity&gt; entity(new Entity());\n    */\n\n    // Preferred approach: using std::make_unique\n    std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;();\n\n    std::cout &lt;&lt; \"End of main scope\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Entity Created!\nEnd of main scope\nEntity Destroyed!\n</code></pre> <p>Here, the <code>Entity</code> class logs its creation and destruction, allowing us to observe when the unique pointer automatically deallocates the object at the end of <code>main</code>.</p> <p>A <code>std::unique_ptr</code> cannot be copied, ensuring exclusive ownership of the resource. Attempting to copy it will result in a compilation error. However, ownership can be transferred using <code>std::move()</code>.</p> <p>If multiple parts of a program need access to the same resource, consider using <code>std::shared_ptr</code> instead.</p>"},{"location":"06%20Pointers%20and%20References/#shared-pointer","title":"Shared Pointer","text":"<p>A <code>std::shared_ptr</code> works differently from a <code>std::unique_ptr</code> and has more complexity under the hood. It relies on reference counting, which keeps track of how many <code>shared_ptr</code> instances are pointing to the same resource. When the reference count reaches zero, meaning no more <code>shared_ptr</code> instances are using the resource, the allocated memory is automatically freed.</p> <p>Instances of <code>std::shared_ptr</code> are also destroyed at the end of their scope, but only the pointer itself, not the actual object it manages, unless the reference count reaches zero. If there are other <code>shared_ptr</code> instances still referencing the same object, the object will remain alive until the last <code>shared_ptr</code> is destroyed or reset. Therefore, they are also called strong references because they prevent the object from being destroyed.</p> <p>Additionally, you should not use <code>new</code> to create a <code>shared_ptr</code>. Instead, it's recommended to use <code>std::make_shared()</code>. This is because <code>std::make_shared()</code> performs a single allocation for both the object and the control block (which stores the reference count), leading to better performance and exception safety compared to manually calling <code>new</code>.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass Entity {\npublic:\n    Entity() {\n        std::cout &lt;&lt; \"Entity Created!\" &lt;&lt; std::endl;\n    }\n\n    ~Entity() {\n        std::cout &lt;&lt; \"Entity Destroyed!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::shared_ptr&lt;Entity&gt; e;\n\n    {\n        std::shared_ptr&lt;Entity&gt; shared_entity = std::make_shared&lt;Entity&gt;();\n\n        e = shared_entity;\n\n        std::cout &lt;&lt; \"End of isoleted scope\" &lt;&lt; std::endl;\n    }\n\n    /* \n        The inner scope ends here, and `shared_entity` goes out of scope\n        and is destroyed, but the object is not deleted because `e`\n        still holds a reference to it.\n\n        The object will only be deleted when `e` goes out of scope and \n        the reference count reaches zero, i.e., when the last `std::shared_ptr`\n        is destroyed.\n\n        The `Entity Destroyed!` message will be printed\n        when `e` goes out of `main()` scope.\n    */\n\n    std::cout &lt;&lt; \"End of main scope\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Entity Created!\nEnd of isoleted scope\nEnd of main scope\nEntity Destroyed!\n</code></pre> <p>In this example, there are two instances of <code>std::shared_ptr&lt;Entity&gt;</code>, one in the main scope (<code>e</code>) and one inside the inner scope (<code>sharedEntity</code>).</p> <p>Even though the inner scope ends and <code>sharedEntity</code> is destroyed, the object is not deleted because <code>e</code> still holds a reference to it. The object will only be destroyed when the last shared pointer managing it is destroyed or reset, which in this case happens when <code>e</code> goes out of scope at the end of <code>main()</code>.</p>"},{"location":"06%20Pointers%20and%20References/#weak-pointer","title":"Weak Pointer","text":"<p>Weak pointers are used in combination with shared pointers. They also allow sharing access to a resource, but they do not keep the resource alive because they do not increase the reference count.</p> <p>This can be useful when you need to observe or manipulate a shared resource (e.g., sorting a list of objects) without taking ownership of it.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass Entity {\npublic:\n    Entity() {\n        std::cout &lt;&lt; \"Entity Created!\" &lt;&lt; std::endl;\n    }\n\n    ~Entity() {\n        std::cout &lt;&lt; \"Entity Destroyed!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::weak_ptr&lt;Entity&gt; e;\n\n    {\n        std::shared_ptr&lt;Entity&gt; shared_entity = std::make_shared&lt;Entity&gt;();\n\n        e = shared_entity;\n\n        std::cout &lt;&lt; \"End of isoleted scope\" &lt;&lt; std::endl;\n    }\n\n    /*\n        The inner scope ends here, and `sharedEntity` goes out of scope,\n        is destroyed and the object is deleted immediately because `e`\n        is a weak pointer and does not increase the reference count.\n\n        Since no other `shared_ptr` exists after the inner scope ends,\n        the resource is freed immediately, and the `Entity Destroyed!`\n        message will be printed at the end of the isolated scope.\n    */\n\n    std::cout &lt;&lt; \"End of main scope\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Entity Created!\nEnd of isoleted scope\nEntity Destroyed!\nEnd of main scope\n</code></pre> <p>In this example, the Entity instance will be destroyed at the end of the inner scope, not at the end of <code>main()</code>. This happens because we assigned it to a weak pointer, which does not increase the reference count.</p> <p>Since no other <code>shared_ptr</code> exists after the inner scope ends, the resource is freed immediately.</p>"},{"location":"06%20Pointers%20and%20References/#when-to-use-smart-pointers","title":"When to use Smart Pointers","text":"<p>Smart pointers should be preferred over raw pointers as they provide better memory safety and help prevent memory leaks. Use <code>std::unique_ptr</code> when a heap allocation is necessary. <code>std::shared_ptr</code> should only be used when multiple owners are required, as it comes with additional overhead due to reference counting and internal management.</p> <p>However, there may be low-level cases where smart pointers are not sufficient, but these are uncommon in most high-level applications.</p>"},{"location":"06%20Pointers%20and%20References/#questions","title":"Questions","text":"question 1answer <p>What is a pointer, and how does it conceptually differ from the value it points to?</p> <p>A pointer is a variable that stores a memory address. Instead of holding a value directly, it points to the location in memory where that value is stored.</p> question 2answer <p>Why do pointers in C++ have an associated data type if they ultimately store only a memory address?</p> <p>Pointers have an associated data type so the compiler knows how many bytes to read or write when the pointer is dereferenced. The type does not change the address itself, only how the memory at that address is interpreted.</p> question 3answer <p>What is the difference between stack memory and heap memory in terms of allocation, lifetime, and management?</p> <p>Stack memory is automatically allocated and freed based on scope and has a limited, fixed size. Heap memory is manually allocated and deallocated by the programmer and persists until it is explicitly freed.</p> question 4answer <p>What is a dangling pointer, and name two common ways dangling pointers can occur.</p> <p>A dangling pointer is a pointer that refers to memory that is no longer valid. Common causes include accessing memory after it has been deleted and returning pointers to local stack variables that go out of scope.</p> question 5answer <p>Why is returning a pointer to a local stack variable from a function considered undefined behavior?</p> <p>Local stack variables are destroyed when a function exits. Returning a pointer to such a variable leaves the pointer referencing memory that no longer exists, resulting in undefined behavior.</p> question 6answer <p>Explain the difference between <code>const int*</code>, <code>int* const</code>, and <code>const int* const</code>.</p> <p><code>const int*</code>       -&gt; is a pointer to a constant value, meaning the value cannot be modified through the pointer. <code>int* const</code>       -&gt; is a constant pointer, meaning the pointer cannot be reassigned. <code>const int* const</code> -&gt; is a constant pointer to a constant value, meaning neither the pointer nor the value can be modified.</p> question 7answer <p>How does pointer arithmetic work, and why does incrementing a pointer move by more than one byte?</p> <p>Pointer arithmetic moves the pointer by multiples of the size of the type it points to. Incrementing a pointer advances it to the next element in memory, not the next byte.</p> question 8answer <p>What are the key semantic differences between pointers and references in C++?</p> <p>A pointer can be null, reassigned, and explicitly dereferenced. A reference must always be bound to a valid object, cannot be null, and cannot be reassigned after initialization.</p> question 9answer <p>Explain the difference between pass-by-value, pass-by-reference, and pass-by-const-reference, and when each should be used.</p> <p>Pass-by-value copies the argument and does not affect the original. Pass-by-reference allows the function to modify the original argument. Pass-by-const-reference avoids copying while preventing modification, making it ideal for large or read-only objects.</p> question 10answer <p>What problem do move semantics solve, and how do rvalue references and <code>std::move</code> enable this behavior?</p> <p>Move semantics avoid unnecessary copying by transferring ownership of resources instead of duplicating them. Rvalue references identify temporary objects, and <code>std::move</code> enables the compiler to invoke move operations rather than copy operations.</p>"},{"location":"06%20Pointers%20and%20References/#exercises","title":"Exercises","text":"exercise 1answer <p>Write a program that declares an <code>int</code> variable, creates a pointer that points to it. Print the variable\u2019s value and memory address by dereferencing and using the pointer.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int value = 10;\n    int* value_ptr = &amp;value;\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; *value_ptr &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Pointer: \" &lt;&lt; value_ptr;\n}\n</code></pre> exercise 2answer <p>Write a program that dynamically allocates an <code>int</code> on the heap and assigns it a value. Print the value and memory address of the variable, and then correctly frees the memory.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int* dynamic_value = new int(5);\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; *dynamic_value &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Pointer: \" &lt;&lt; dynamic_value;\n\n    delete dynamic_value;\n}\n</code></pre> exercise 3answer <p>Write a function that takes an int by reference and doubles its value. Call the function from main and show that the original variable is modified.</p> <pre><code>#include &lt;iostream&gt;\n\nvoid DoubleValue(int&amp; value) {\n    value *= 2;\n}\n\nint main() {\n    int value = 10;\n\n    DoubleValue(value);\n\n    std::cout &lt;&lt; \"Modified value: \" &lt;&lt; value;\n}\n</code></pre> exercise 4hintanswer <p>Write a program that intentionally creates a dangling pointer.</p> <p>There is more than one way to do this, such as returning the address of a local variable or deleting dynamically allocated memory and keeping the pointer.</p> <pre><code>#include &lt;iostream&gt;\n\nint* CreateDanglingPointer() {\n    int value;\n    return &amp;value;\n}\n\nint main() {\n    int* dangling_pointer = CreateDanglingPointer();\n}\n</code></pre> exercise 5answer <p>Write a function that swaps two integers using pointers instead of references.</p> <pre><code>#include &lt;iostream&gt;\n\nvoid SwapValues(int* value1, int* value2) {\n    int temp = *value1;\n    *value1 = *value2;\n    *value2 = temp;\n}\n\nint main() {\n    int a = 10;\n    int b = 20;\n\n    SwapValues(&amp;a, &amp;b);\n\n    std::cout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"b: \" &lt;&lt; b;\n}\n</code></pre> exercise 6answer <p>Create a function pointer that points to a function performing a simple arithmetic operation. Call the function through the function pointer.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nint Addition(int augend, int addend) {\n    return augend + addend; \n}\n\nint main() {\n    std::function&lt;int(int, int)&gt; function_ptr = &amp;Addition;\n\n    int sum = function_ptr(10, 20);\n\n    std::cout &lt;&lt; \"Sum: \" &lt;&lt; sum;\n}\n</code></pre> exercise 7answer <p>Create a unique smart pointer for <code>int</code> and assign it a value. Then write a function that takes this smart pointer as a parameter and prints the value. Move the pointer into the function, and observe what happens to the original pointer after the move.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nvoid TakeOwnershipAndPrint(std::unique_ptr&lt;int&gt; ptr) {\n    std::cout &lt;&lt; \"Pointer value: \" &lt;&lt; *ptr &lt;&lt; '\\n';\n}\n\nint main() {\n    std::unique_ptr&lt;int&gt; smart_ptr = std::make_unique&lt;int&gt;(10);\n\n    TakeOwnershipAndPrint(std::move(smart_ptr));\n\n    if (smart_ptr == nullptr) {\n        std::cout &lt;&lt; \"Moved Successfully!\";\n    }\n}\n</code></pre>"},{"location":"07%20Collections%20of%20Data/","title":"07 Collections of Data","text":"<p>Info</p> <p>To understand how collections work in C++\u2014called containers\u2014it\u2019s essential to be comfortable with pointers and references, as these underpin how elements are stored and accessed in memory.</p> <p>As programs grow in complexity, working with individual variables quickly becomes impractical. Often, we need to sort data, search through or loop over it in different ways depending on the situation\u2014and that simply isn\u2019t feasible with standalone variables.</p> <p>That\u2019s exactly what data collections are for. They allow us to group and manage related values, following predefined rules based on our needs.</p> <p>In C++, collections come in the form of STL containers\u2014data structures designed to hold multiple elements of the same or related type. These structures make it possible to organize, access, and manipulate data in flexible and scalable ways. Whether you\u2019re storing a list of names, a grid of game tiles, or a queue of tasks to process, these containers provide the right tool for the job.</p> <p>We've already seen them pop up a few times\u2014C++ containers are templated, which means they use a special syntax with angle brackets to fix the type they store. This makes them usable with any type. For example, <code>std::variant</code> was one of them\u2014it even took more than one type at once.</p> <p>Now we\u2019ll explore practical, built-in solutions\u2014like arrays, strings, and powerful containers from the C++ Standard Template Library (STL)\u2014along with the logic behind how they work and how to optimize them. These implementations are fast, reliable, and used in real-world software every day\u2014so you don\u2019t have to reinvent the wheel. That said, it\u2019s not uncommon for large companies to use or develop their own versions of the STL, such as EA STL, Qt\u2019s container classes, or Unreal Engine\u2019s custom collections.</p>"},{"location":"07%20Collections%20of%20Data/#c-style-arrays","title":"C-Style Arrays","text":"<p>First, we'll look at C-style arrays\u2014one of the most basic, yet surprisingly powerful, data structures in C++. They originate from the C language (hence the name) and are often referred to as static arrays.</p> <p>A C-style array is a fixed-size collection of elements stored in contiguous memory, where every element must be of the same data type. This layout allows for fast access using indexing and straightforward traversal, as shown in the diagram below.</p> <p>Because all elements are of the same type and placed in continuous memory, they are simply offset by a fixed number of bytes\u2014the size of the data type. This makes it easy to move from one element to the next just by stepping through memory.</p> Index 0 1 2 4 5 Value <code>10</code> <code>20</code> <code>30</code> <code>40</code> <code>50</code> Address <code>0x1000</code> <code>0x1004</code> <code>0x1008</code> <code>0x100C</code> <code>0x1010</code> <p>That\u2019s why arrays are incredibly useful when working with multiple related values. Instead of declaring dozens of individual variables, we can group them together into a single structure\u2014simplifying both storage and access. For example, initializing 50 elements to zero would be tedious if done manually, but with an array, it\u2019s just a simple loop.</p> <p>That said, C-style arrays have important limitations. Their size is fixed at compile time, and they don\u2019t provide built-in bounds checking. This means it\u2019s easy to accidentally access memory outside the array\u2019s limits, which can lead to bugs or crashes if not handled carefully.</p> example<pre><code>int main() {\n    /*\n        Declaring multiple separate variables\n        is inefficient and repetitive.\n\n        int num1 = 0;\n        int num2 = 0;\n        int num3 = 0;\n        ...\n    */\n\n    // Use an array to store multiple values efficiently.\n    int arr[5];\n\n    /*\n        This syntax also initializes the array\n        immediately after declaration:\n\n        int arr[5] = {0, 0, 0, 0, 0};\n    */\n}\n</code></pre> <p>Note</p> <p>The syntax <code>int arr[5];</code> declares an array and reserves space for five integers, but it does not automatically initialize the elements\u2014they will contain garbage (random) values.</p> <p>Also remember that if you initialize the array with values (e.g., <code>int arr[] = {1, 2, 3};</code>), you can omit the size. In such cases, the compiler determines the size based on the number of elements provided.</p>"},{"location":"07%20Collections%20of%20Data/#accessing-and-modifying-elements","title":"Accessing and Modifying Elements","text":"<p>In the example above, we only allocated memory for five integers. To change individual elements after declaration, we use an index, which specifies the position of the element in the sequence. Because of how pointer arithmetic works, the first element is at index 0 not 1\u2014this corresponds to the memory address held by the array variable. This is because <code>int arr[]</code> is treated like a pointer by default.</p> <p>The syntax for accessing an element is simple: append square brackets to the array name and place the index inside.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int arr[5];\n\n    arr[0] = 10; // Assigns 10 to the first element\n    arr[2] = 30; // Assigns 30 to the third element\n\n    // Access third element for output\n    std::cout &lt;&lt; \"Third element: \" &lt;&lt; arr[2] &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Third element: 30\n</code></pre> <p>Danger</p> <p>Writing to memory you don't own\u2014beyond the array\u2019s allocated size\u2014leads to undefined behavior, which means your program could do anything from crashing immediately to silently corrupting memory.</p> <p>In debug mode, many compilers and runtime environments will catch this and stop the program with a memory access violation. But in release mode, it might appear to work fine\u2014until it suddenly doesn't. These kinds of bugs are notoriously difficult to track down, so always stay within the bounds of your array and always write index-to-size checks.</p>"},{"location":"07%20Collections%20of%20Data/#iterating-over-arrays","title":"Iterating Over Arrays","text":"<p>Arrays naturally bring us back to loops\u2014because when you have a collection of data, loops are the perfect tool for efficiently stepping through and working with each element. For example, if we\u2019ve declared an array for five integers, a for loop lets us visit every element and do something with it\u2014like assigning controlled pseudo-random values, since computers can\u2019t really produce truly random numbers.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // for std::srand and std::rand\n#include &lt;ctime&gt;   // for std::time\n\nint main() {\n    int array[5];\n\n    /* \n        Seed the random number generator with the current time\n        to ensure different sequences of numbers each run\n    */\n    std::srand(std::time(nullptr));\n\n    for (int i = 0; i &lt; sizeof(array) / sizeof(array[0]); ++i)\n        // Generate a pseudo-random number between 0 and 100 (inclusive)\n        array[i] = std::rand() % 101;\n\n    for (int i = 0; i &lt; sizeof(array) / sizeof(array[0]); ++i)\n        std::cout &lt;&lt; array[i] &lt;&lt; '\\t';\n}\n</code></pre> output<pre><code>65  30  83  46  92\n</code></pre> <p>In this example, we utilized the <code>sizeof</code> operator in the loop condition to determine the number of elements in the array. This ensures the loop runs exactly once per element, keeping our code safe and adaptable if the array size changes.</p> <p>Tip</p> <p>This example uses the C-style <code>std::rand()</code> function to generate pseudo-random numbers. While it\u2019s simple and widely supported, it\u2019s considered outdated in modern C++. For better randomness, control, and features, check out the C++ <code>&lt;random&gt;</code> header introduced in C++11. It provides more powerful and flexible tools to generate random numbers\u2014including floating-point values and more\u2014in a safer and more efficient way.</p> <p>More on that topic can be found here: https://cplusplus.com/reference/random/</p>"},{"location":"07%20Collections%20of%20Data/#pointers-arithmetic-on-arrays","title":"Pointers Arithmetic on Arrays","text":"<p>It\u2019s important to understand that arrays are tightly related to pointers. In fact, the array variable itself acts as a pointer to the first element of the array. So when you print just the array\u2019s name, what you\u2019re really seeing is the memory address of the first element.</p> <p>If we increment that pointer by one, it doesn\u2019t move forward by one byte\u2014it moves forward by the size of the type it points to. For an <code>int</code> array, this usually means 4 bytes per step (on most systems).</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int array[3] = {1, 2, 3};\n\n    int* ptr = array; // Points to the first element\n\n    std::cout &lt;&lt; \"First element: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n\n    ++ptr;            // Advances the pointer by 4 bytes\n\n    std::cout &lt;&lt; \"Second element: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>First element: 1\nSecond element: 2\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#array-heap-allocation","title":"Array Heap Allocation","text":"<p>Until now, we've declared arrays on the stack, meaning they're automatically managed and cleaned up when they go out of scope. However, we can use the <code>new</code> keyword to allocate an array on the heap, which gives us full control over its lifetime.</p> example<pre><code>int main() {\n    int* array = new int[5];\n    delete[] array;\n}\n</code></pre> <p>Since this array was allocated on the heap, it won't be automatically deallocated when the function ends. It will persist until we manually free it using <code>delete[]</code>, or until the program terminates.</p> <p>Danger</p> <p>If we allocate an array on the heap inside a function and forget to free it before the function ends, we lose access to that memory address\u2014resulting in a memory leak. Once it's out of scope with no pointer referencing it, there's no way to clean it up anymore.</p>"},{"location":"07%20Collections%20of%20Data/#multidimensional-arrays","title":"Multidimensional Arrays","text":"<p>The term multidimensional refers to arrays with more than one level of indexing. Whether it\u2019s 2D, 3D, or more, the underlying concept stays the same: a multidimensional array is simply an array of arrays and so on. This structure allows us to represent its elements like grids, matrices, or tables.</p> <p></p> <p>Since arrays are essentially pointers, a multidimensional array can be viewed as a pointer to a pointer\u2014each pointer in the top-level array refers to another block of memory that holds the actual data. This hierarchical structure lets us organize data in rows, columns, and beyond.</p>"},{"location":"07%20Collections%20of%20Data/#dynamically-allocating-a-2d-array","title":"Dynamically Allocating a 2D Array","text":"<p>To properly create a 2D array on the heap:</p> <ul> <li>Allocate memory for an array of pointers (the rows).</li> <li>Loop through each pointer and allocate a separate array for that row.</li> </ul> example<pre><code>int main() {\n    /*\n        Allocate a 2D array on the heap using a pointer-to-pointer\n        This helps illustrate how 2D arrays work under the hood\n    */\n    int** array2d = new int*[50];  // 50 rows\n\n    for (int i = 0; i &lt; 50; ++i)\n        array2d[i] = new int[10]; // Each row has 10 columns\n\n    /*\n        However, it's better to use a stack-allocated 2D array if possible\n        int array2d[2][3] = {{1, 2, 3},\n                             {4, 5, 6}};\n    */\n}\n</code></pre> <p>Each <code>array2d[i]</code> now points to a 1D array of integers, giving us a full 50\u00d710 grid of values.</p>"},{"location":"07%20Collections%20of%20Data/#deallocating-a-2d-array","title":"Deallocating a 2D Array","text":"<p>Each row is dynamically allocated separately, allowing for flexible memory management. However, since we are manually allocating memory, we must also free it later to prevent memory leaks.</p> <p>Danger</p> <p>When deallocating a multidimensional array, we cannot simply use <code>delete[] array2d</code> because that would only free the top-level pointer, leaving the allocated rows still in memory and causing a memory leak.</p> <p>To properly free a dynamically allocated 2D array, we must:</p> <ol> <li>Iterate through the first dimension and delete each row.</li> <li>Once all rows are freed, delete the main array pointer.</li> </ol> example<pre><code>int main() {\n    int** array2d = new int*[50];\n\n    for (int i = 0; i &lt; 50; ++i)\n        array2d[i] = new int[10];\n\n    for (int i = 0; i &lt; 50; ++i)\n        delete[] array2d[i];\n\n    delete[] array2d;\n}\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#access-multidimensional-arrays","title":"Access multidimensional arrays","text":"<p>To access elements in a multidimensional array, we extend our understanding of indexing. The first <code>[]</code> selects a row (an array), and the second <code>[]</code> selects a column (element within that row).</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int array2d[3][3] = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    std::cout &lt;&lt; \"Second row, third column: \" &lt;&lt; array2d[1][2] &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Second row, third column: 6\n</code></pre> <p>In this example, we demonstrated how to allocate a multidimensional array on the stack. This approach is much simpler, but it doesn\u2019t reveal how multidimensional arrays actually work under the hood. That\u2019s why we only introduced it at this point\u2014once the fundamentals were already in place.</p>"},{"location":"07%20Collections%20of%20Data/#optimizing-memory-access-for-multidimensional-arrays","title":"Optimizing Memory Access for Multidimensional Arrays","text":"<p>Multidimensional arrays do not store their data in a single contiguous memory block by default. Instead, they typically allocate multiple smaller buffers scattered across memory, leading to memory fragmentation, where data is no longer stored sequentially. This fragmentation causes inefficient memory access, as the CPU must jump between different memory locations\u2014resulting in increased overhead and slower performance.</p> <p>One way to optimize this is by improving cache locality, which minimizes costly memory jumps by keeping related data close together in memory.</p> <p>It might seem like there's no easy fix for this, but there actually is. If we know the dimensions of the array ahead of time, we can allocate a single contiguous block of memory (i.e., a one-dimensional array) and manually compute row and column indices to simulate multidimensional access.</p> <p>This approach avoids the overhead of multiple <code>new</code> allocations and takes better advantage of the CPU cache. Additionally, allocating the array on the stack (when size is known and small enough) instead of dynamically on the heap further improves performance and memory safety.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int rows = 50, cols = 10;\n    int* array = new int[rows * cols];\n\n    // Accessing elements using index calculations\n    int row = 2, col = 3;\n    array[row * cols + col] = 42;\n\n    std::cout &lt;&lt; \"Value at [\" &lt;&lt; row &lt;&lt; \"][\" &lt;&lt; col &lt;&lt; \"]: \" \n              &lt;&lt; array[row * cols + col] &lt;&lt; std::endl;\n\n    delete[] array;\n}\n</code></pre> output<pre><code>Value at [2][3]: 42\n</code></pre> <p>This method ensures that all elements are stored in a single contiguous memory block, reducing fragmentation and significantly improving performance. Whenever possible, prefer this approach to optimize memory access and cache efficiency.</p> <p>Even when you imagine an image as a multidimensional array of pixels, it isn't, it is just a single-dimensional array stored in memory. The concept of rows and columns is simply an abstraction used for easier indexing and manipulation.</p>"},{"location":"07%20Collections%20of%20Data/#strings","title":"Strings","text":"<p>Strings\u2014or text in general\u2014are a surprisingly complex topic in computing, largely due to character encoding and how characters are represented in memory. By default, C++ uses the <code>char</code> type to represent individual characters, typically assuming an ASCII-compatible encoding, such as UTF-8.</p> <p>However, ASCII has a major limitation: it uses only 1 byte per character, giving just 256 possible values. That\u2019s nowhere near enough to represent the thousands of characters used across different languages and symbol sets.</p> <p>To solve this, modern encodings like Unicode and especially UTF-8 were introduced. These allow much broader and more flexible character representation, supporting virtually all human languages.</p> <p>From a structural point of view, strings are closely related to arrays, because they both act as buffers of a specific type. In fact, a basic string in C and C++ is just an array or pointer of <code>char</code> values stored contiguously in memory.</p>"},{"location":"07%20Collections%20of%20Data/#c-style-string","title":"C-Style String","text":"<p>We briefly encountered this style of string in the earlier chapters\u2014for example, when using <code>std::cout</code>\u2014but we didn\u2019t stop to examine how it actually works. Now that we have the necessary background on arrays, pointers, and memory, we can finally explore it in more detail.</p> main.cpp<pre><code>int main() {\n    const char* string = \"Hello World!\";\n\n    std::cout &lt;&lt; string &lt;&lt; std::endl;\n}\n</code></pre> <p>In the example above, a few important things are happening:</p> <ul> <li>The string is written using double quotes, which tells the compiler to create a string literal\u2014a fixed, read-only block of characters.</li> <li>The variable is declared as <code>const char*</code>, meaning it\u2019s a pointer to a constant character buffer.   This pointer points to the beginning of the string literal, which is stored in read-only memory.</li> <li>The <code>const</code> is important\u2014it prevents accidental modification of the string.   If you try to change a string literal, you\u2019ll get undefined behavior, and many compilers will crash the program to protect memory.</li> </ul> <p>One key detail about string literals is that they are null-terminated. Behind the scenes, the compiler automatically adds a special character, <code>\\0</code>, to the end of the string. This marks where the string ends in memory.</p> Index 0 1 2 3 4 5 Value H e l l o \\0 <p>Without that null character, functions like <code>std::cout</code> wouldn\u2019t know when to stop reading characters, and you'd likely end up printing garbage data\u2014or crashing your program.</p>"},{"location":"07%20Collections%20of%20Data/#modifying-c-style-strings","title":"Modifying C-Style Strings","text":"<p>If you want a string that you can modify, you need to create it differently. Rather than pointing to a read-only literal, you allocate a character array that lives in stack memory.</p> main.cpp<pre><code>int main() {\n    char string[] = \"Hello World!\";\n\n    string[1] = 'a';\n}\n</code></pre> <p>This creates a mutable copy of the string. Each character is stored in stack memory, and you can safely modify it. The null terminator is still added at the end automatically.</p>"},{"location":"07%20Collections%20of%20Data/#c-string","title":"C++ String","text":"<p>Info</p> <p>The <code>std::string</code> API provides solutions for nearly all string-related problems. Covering every possible edge case and method here would be unnecessary. If you need a specific solution, you can refer to the C++ documentation available here: https://cplusplus.com/reference/string/string/</p> <p>Now that we\u2019ve explored C-style strings and how they work under the hood, it\u2019s time to introduce the more modern and user-friendly C++ alternative: <code>std::string</code>.</p> <p>C++ provides a powerful templated class called <code>std::string</code> for handling and manipulating text. Internally, it still uses a <code>char</code> array as its underlying data structure, but it wraps that low-level complexity in a much more intuitive and safer interface.</p> <p>To use <code>std::string</code>, we include the <code>&lt;string&gt;</code> header, which defines the class and its methods. While <code>std::string</code> can technically be used with just <code>&lt;iostream&gt;</code>, doing so doesn\u2019t give you full access to all of its functionality\u2014so it\u2019s best practice to explicitly include <code>&lt;string&gt;</code>.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string string = \"Hello World!\";\n\n    std::cout &lt;&lt; string &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>This example shows a simple way to declare and print a string in C++. Behind the scenes, <code>std::string</code> automatically handles memory allocation, resizing, copying, and null-termination for you.</p>"},{"location":"07%20Collections%20of%20Data/#string-concatenation","title":"String Concatenation","text":"<p>With <code>std::string</code>, concatenating text is simple. We can use the <code>+=</code> operator to append new content, or use the <code>.append()</code> method for a more explicit and readable approach. Both options do the same thing\u2014it\u2019s just a matter of preference.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string string = \"Hello World!\";\n\n    string += \" Another string!\";\n    string.append(\" Yet another string!\");\n\n    std::cout &lt;&lt; string &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hello World! Another string! Yet another string!\n</code></pre> <p>The problem arises when we try to concatenate two string literals, as they are both raw C-style <code>const char*</code> values. Since these are pointers to character arrays, there's no built-in + operator to add two <code>const char*</code> values together. In other words, C++ doesn\u2019t know how to \"add\" two pointers and produce a combined string.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string string = \"Hello \" + \"World!\";\n}\n</code></pre> output<pre><code>error: invalid operands\n</code></pre> <p>To fix this, you need to convert at least one of them to <code>std::string</code>, type which knows how to handle dynamic memory and concatenation.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string message = std::string(\"Hello \") + \"World!\";\n\n    std::cout &lt;&lt; message &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hello World!\n</code></pre> <p>There's also a shortcut: if you're just trying to break a long string across multiple lines or connect with a definition, C-style string literals placed next to each other automatically merge at compile time. This works without any concatenation operator.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#define RESOURCES_PATH \"assets/\"\n\nint main() {\n    const char* path = RESOURCES_PATH\n                       \"textures/\"\n                       \"player.png\";\n\n    std::cout &lt;&lt; path &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>assets/textures/player.png\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#string-literals","title":"String Literals","text":"<p>Danger</p> <p>Modifying a string literal like leads to undefined behavior, because literals are stored in read-only memory.</p> <p>Now that we've learned how to store and manipulate text, it's time to cement our understanding of what string literals actually are.</p> <p>A string literal is a sequence of characters enclosed in double quotes. In C++, these are stored as pointers to arrays of <code>char</code> values, and they are automatically null-terminated\u2014meaning a special character is placed at the end to signal where the string stops.</p> <p>In contrast, a character literal is written inside single quotes and represents a single char value.</p> main.cpp<pre><code>int main() {\n    char character = 'A';      // Single character\n    const char* string = \"A\";  // Null-terminated C-string {'A', '\\0'}\n}\n</code></pre> <p>Although both contain single character <code>A</code>, the first is a single character stored in a single byte, while the second is a pointer to a two-character array: <code>'A'</code> followed by <code>'\\0'</code>. This distinction matters, especially when performance or memory layout is important. If you only need one character, avoid using a full string literal\u2014it's less efficient and potentially misleading.</p>"},{"location":"07%20Collections%20of%20Data/#raw-string-literals","title":"Raw String Literals","text":"<p>Sometimes, escape sequences like <code>\\n</code>, <code>\\t</code>, or <code>\\\\</code> get in the way\u2014especially when working with file paths, regular expressions, or JSON. To help with this, C++ offers raw string literals, written using <code>R\"(...)\"</code>. Inside the parentheses, everything is treated as plain text without interpreting escape sequences. This removes the need for double backslashes and other annoying escapes.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string raw_string = R\"(C:\\Users\\UserName\\Documents\\file.txt)\";\n\n    std::cout &lt;&lt; raw_string &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>C:\\Users\\UserName\\Documents\\file.txt\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#unicode-string-literals","title":"Unicode String Literals","text":"<p>Warning</p> <p>As mentioned earlier, non-ASCII characters can cause compatibility issues across different system architectures. Unless you're working on a graphical user interface (GUI) or an application that explicitly requires Unicode, it's often better to avoid using non-ASCII characters in general-purpose or console-based programs.</p> <p>C++ also supports Unicode and wide character string literals, which are essential for representing characters outside of ASCII (like emoji, accented letters, or non-Latin scripts). These literals use prefixes to indicate encodings.</p> Prefix Type Encoding Notes <code>L\"\"</code> <code>wchar_t</code> Platform-defined (UTF-16/32) <code>u\"\"</code> <code>char16_t</code> UTF-16 Fixed 2 bytes per char <code>U\"\"</code> <code>char32_t</code> UTF-32 Fixed 4 bytes per char <code>u8\"\"</code> <code>char</code> UTF-8 Same type as <code>std::string</code>"},{"location":"07%20Collections%20of%20Data/#small-strings","title":"Small Strings","text":"<p>Strings are a foundational part of programming, and while they\u2019re often convenient to use, they carry a reputation for being slow. This is mostly due to frequent memory allocations on the heap, which are slower than stack allocations.</p> <p>To address this, modern implementations of <code>std::string</code> include an optimization called Small String Optimization (SSO). This technique avoids heap allocation for small strings by storing them directly on the stack.</p> <p>Note</p> <p>The exact size limit for SSO varies between implementations. For instance, Microsoft\u2019s Visual C++ (MSVC) stores strings up to 15 characters on the stack. Longer strings are allocated on the heap.</p> <p>This optimization is transparent to the user and one of the main reasons <code>std::string</code> is preferred over C-style strings in modern C++.</p>"},{"location":"07%20Collections%20of%20Data/#optimize-strings-in-c","title":"Optimize Strings in C++","text":"<p>As noted, frequent heap allocations are the main source of performance overhead. While not inherently bad, heap allocations are relatively expensive, especially inside performance-critical loops.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstatic unsigned int s_alloc_count = 0;\n\nvoid* operator new(size_t size) {\n    s_alloc_count++;\n    std::cout &lt;&lt; \"Allocating: \" &lt;&lt; size &lt;&lt; \" bytes\" &lt;&lt; std::endl;\n    return malloc(size);\n}\n\nvoid operator delete(void* memory, size_t size) {\n    std::cout &lt;&lt; \"Deallocating: \" &lt;&lt; size &lt;&lt; \" bytes\" &lt;&lt; std::endl;\n    free(memory);\n}\n\nvoid PrintNameReference(const std::string&amp; name) {\n    std::cout &lt;&lt; name &lt;&lt; std::endl;\n}\n\nint main() {\n    std::string small_string = \"Unknown Name\";        // Stack allocation\n    std::string large_string = \"Unknown Name Longer\"; // Heap allocation\n    PrintNameReference(large_string);\n\n    std::cout &lt;&lt; \"Total Allocations: \" &lt;&lt; s_alloc_count &lt;&lt; std::endl;\n}\n</code></pre> output msvc debug<pre><code>Allocating: 16 bytes -&gt; small_string\nAllocating: 16 bytes -&gt; large_string metadata\nAllocating: 32 bytes -&gt; large_string content\n\nRandom Jordan Second\nTotal Allocations: 3\n\nDeallocating: 32 bytes -&gt; large_string content\nDeallocating: 16 bytes -&gt; large_string metadata\nDeallocating: 16 bytes -&gt; small_string\n</code></pre> output msvc release<pre><code>Allocating: 32 bytes\n\nRandom Jordan Second\nTotal Allocations: 1\n\nDeallocating: 32 bytes\n</code></pre> <p>The Small String Optimization typically applies in release mode with the Microsoft Visual C++ compiler. In Debug mode, MSVC disables many optimizations and adds extra bookkeeping (like iterator debugging and guard buffers), which often prevents SSO from activating.</p> <p>Interestingly, the same allocation behavior occurs even if we don\u2019t explicitly create a <code>std::string</code> variable, and instead pass a string literal directly to a function. That\u2019s because a temporary <code>std::string</code> is still constructed behind the scenes from the literal.</p> <pre><code>PrintNameReference(\"Random Jordan Second\");\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#substring-operations-overhead","title":"Substring Operations Overhead","text":"<p>Problems can arise when manipulating strings\u2014such as extracting substrings\u2014because each operation typically results in a new string which needs another heap allocation. This can introduce performance overhead, especially when used inside loops or performance-critical code.</p> main.cpp<pre><code>/*\n    Operator overloads for memory tracking from example before\n    PrintName function implementation \n*/\n\nint main() {\n    std::string name = \"Unknown Name Longer\";\n\n    std::string firstName = name.substr(0, 6);\n    std::string lastName = name.substr(8, 17);\n\n    std::cout &lt;&lt; \"Total Allocations: \" &lt;&lt; s_alloc_count &lt;&lt; std::endl;\n}\n</code></pre> output msvc debug<pre><code>Allocating: 16 bytes\nAllocating: 16 bytes\nAllocating: 16 bytes\n\nTotal Allocations: 3\n\nDeallocating: 16 bytes\nDeallocating: 16 bytes\nDeallocating: 16 bytes\n</code></pre> <p>When we extract portions of an existing string using substr, each call results in a new <code>std::string</code> being constructed. This means a fresh heap allocation is performed, and the relevant characters are copied from the original string into the new one. While this might seem harmless in small, isolated cases, it introduces unnecessary overhead.</p> <p>The root of the issue is how <code>std::string::substr</code> behaves: it always returns a new string, rather than referencing a slice of the original. Even if we pass that substring directly to a function, a temporary string is still created behind the scenes, leading to the same allocation cost.</p>"},{"location":"07%20Collections%20of%20Data/#string-views","title":"String Views","text":"<p>To avoid these allocations, we need a way to reference a substring without copying it. This is exactly what the C++ Standard Library offers with <code>std::string_view</code>. Unlike <code>std::string</code>, a <code>string_view</code> is a non-owning view into an existing character sequence. It performs no allocations and provides a lightweight, efficient way to work with substrings.</p> main.cpp<pre><code>// Operator overloads for memory tracking from example before\n\nvoid PrintNameView(std::string_view name) {\n    std::cout &lt;&lt; name &lt;&lt; std::endl;\n}\n\nint main() {\n    std::string name = \"Unknown Name\";\n\n    std::string_view first_name(name.c_str(), 6);\n    std::string_view last_name(name.c_str() + 8, 4);\n\n    PrintNameView(first_name);\n    PrintNameView(last_name);\n\n    std::cout &lt;&lt; \"Total Allocations: \" &lt;&lt; s_alloc_count &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Allocating: 16 bytes\nUnknow\nName\nTotal Allocations: 1\nDeallocating: 16 bytes\n</code></pre> <p>By switching to <code>std::string_view</code>, we\u2019ve reduced the number of heap allocations down to just one\u2014the one used to create the original <code>std::string</code>. Since view doesn\u2019t copy data, it allows us to reference parts of the string without triggering additional allocations.</p> <p>Instead of calling substring, we now construct <code>std::string_view</code> objects directly. The constructor takes two arguments:</p> <ol> <li>A starting pointer position \u2013 typically provided by <code>name.c_str()</code>, which gives access to the underlying character data.</li> <li>A length \u2013 indicating how many characters to include starting from the pointer you provided.</li> </ol> <p>Since <code>c_str()</code> returns a <code>const char*</code>, we can use pointer arithmetic (like name.c_str() + 7) to adjust the starting point of the view dynamically.</p> <p>To support this approach, we also have to create new function to accept a <code>std::string_view</code> instead of a full <code>std::string</code>, ensuring that no temporary allocations occur when passing substrings around.</p> <p>But we can go even further\u2014down to zero allocations\u2014by skipping <code>std::string</code> entirely. If we declare the original string as a plain <code>const char*</code>, we avoid heap usage altogether. These literals are stored in static memory (often embedded directly in the binary), and don't trigger any heap allocations which are tracked by <code>s_alloc_count</code>.</p> main.cpp<pre><code>// Operator overloads for memory tracking from example before\n// PrintNameView function\n\nint main() {\n    const char* name = \"Unknown Name Longer\";\n\n    std::string_view first_name(name, 6);\n    std::string_view last_name(name + 8, 4);\n\n    PrintNameView(first_name);\n    PrintNameView(last_name);\n\n    std::cout &lt;&lt; \"Total Allocations: \" &lt;&lt; s_alloc_count;\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>Since it's already a <code>char*</code> pointer, we can simply pass the variable <code>name</code> instead of using <code>c_str()</code>.</p> <p>Note</p> <p>If we need to mutate the string, <code>char*</code> is no longer an option, as <code>char*</code> is non-modifiable strings in this context.</p>"},{"location":"07%20Collections%20of%20Data/#c-static-array","title":"C++ Static Array","text":"<p>Earlier in this chapter, we referred to the C-style array\u2014also known as a static array\u2014and mentioned how it has a fixed size that cannot be changed after its declaration. Now, let\u2019s focus on the C++ Standard Library's static array: <code>std::array</code>. While it shares the fixed-size nature of C-style arrays, it offers several advantages that make it more practical and safer to use in modern C++. To use <code>std::array</code>, simply include the <code>&lt;array&gt;</code> header.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nint main() {\n    std::array&lt;int, 5&gt; array;\n    array[0] = 1;\n    array[4] = 5;\n\n    // Easily access array size as count of elements\n    std::cout &lt;&lt; array.size();\n}\n</code></pre> output<pre><code>5\n</code></pre> <p>This example shows how to declare a static array using <code>std::array</code> and access its elements. The interface is quite similar to C-style arrays, but with additional functionality.</p> <p><code>std::array</code> takes two template parameters:</p> <ol> <li>The type of elements it stores</li> <li>The size (number of elements)</li> </ol> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nvoid PrintArray(const std::array&lt;int, 5&gt;&amp; array) {\n    for (int i = 0; i &lt; 5; ++i)\n        std::cout &lt;&lt; array[i] &lt;&lt; '\\t';\n}\n\nint main() {\n    std::array&lt;int, 5&gt; array = {}; // Zero-initialize all elements\n    array[0] = 1;\n    array[4] = 5;\n\n    PrintArray(array);\n}\n</code></pre> output<pre><code>1   0   0   0   5\n</code></pre> <p>One limitation is clear in this example: the size of the array (5) must be part of the function's type signature, which reduces flexibility and modularity. Later with templates, we\u2019ll learn how to solve this by templating the function itself.</p> <p>Alternatively, if you need a resizable container, you may want to use a dynamic array such as <code>std::vector</code> instead.</p> <p>Despite this constraint, <code>std::array</code> introduces no performance overhead compared to raw arrays. In return, you get stronger type safety and better integration with the STL. For these reasons, it should be preferred over C-style arrays in modern C++ code.</p>"},{"location":"07%20Collections%20of%20Data/#dynamic-array","title":"Dynamic Array","text":"<p>Info</p> <p>We won\u2019t go into every feature of <code>std::vector</code> here, as it\u2019s a large and powerful tool. For more tailored usage, refer to the documentation: cplusplus.com/reference/vector/vector</p> <p>When we need a C++ container that can resize by adding or removing elements during runtime, the Standard Library provides a dynamic array implementation called <code>std::vector</code>. Its key feature is exactly what we\u2019d expect from a dynamic container: automatic resizing, making it ideal when the number of elements isn\u2019t known in advance or is expected to change over time.</p> <p>Under the hood, a vector manages memory dynamically. The actual element data is stored on the heap, while the vector object itself\u2014along with its pointer to the data, current size, and capacity\u2014is stored on the stack.</p> <p>As you add elements, the vector will automatically expand its internal storage when needed. For example, if a vector initially reserves space for 10 elements and you push more, it will:</p> <ol> <li>Allocate a new, larger block of memory (usually doubling the capacity)</li> <li>Copy the existing elements into the new memory</li> <li>Release the old memory</li> <li>Update its internal pointer to point to the new block</li> </ol> <p>Just like <code>std::array</code>, vectors support indexing, range-based loops, and all the common STL algorithms like sorting and searching. The big difference is that you don\u2019t need to define the size ahead of time.</p> <p>To use vectors in your project, include the <code>&lt;vector&gt;</code> header from the Standard Library.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; dynamicArray = {58, 11, 94, 36, 77};\n    dynamicArray.push_back(63);\n\n    std::cout &lt;&lt; dynamicArray[5] &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>63\n</code></pre> <p>By default, <code>std::vector</code> stores its elements in a contiguous block of memory on the heap, not as separate pointers. The vector object itself\u2014including its size, capacity, and a pointer to its data\u2014is kept on the stack when the vector is declared as a local variable.</p> <p>For complex types like structures, the objects themselves are still stored directly within the vector's memory block, not just pointers to them. This means that whenever the vector resizes, each object is moved into the new memory block, which can introduce performance overhead depending on how expensive those moves are.</p> example<pre><code>int main() {\n    int* static_array1 = new int[500000];\n    std::array&lt;int, 500000&gt; static_array2;\n}\n</code></pre> <p>In this example, we allocate a large array both heap and stack. While pre-allocating a large array might seem like a way to avoid future resizing, it introduces some serious risks.</p> Issue Description Stack Overflow <code>std::array&lt;int, 500000&gt;</code> is allocated on the stack, which has limited space (typically around 2 MB). Exceeding this causes an immediate crash. Heap Exhaustion <code>new int[500000]</code> allocates memory on the heap, which has more space than the stack, but can still run out if memory is low or overused. <p>While vectors offer a safe and flexible way to manage dynamic arrays, they aren\u2019t magic\u2014they still rely on memory allocations and must be used wisely.</p>"},{"location":"07%20Collections%20of%20Data/#vector-optimization","title":"Vector Optimization","text":"<p>Now that we understand how <code>std::vector</code> works internally\u2014especially its dynamic resizing behavior\u2014we can take it a step further and discuss how to use it more efficiently.</p> <p>Optimizing performance in C++ often means understanding what\u2019s happening under the hood. In the case of vectors, that includes how memory is managed, how elements are copied or moved, and how frequently reallocation occurs.</p> <p>Whenever you add elements to a vector that has reached its capacity, it must allocate a larger memory block to accommodate the new data. It then copies all existing elements into the new block, deallocates the old memory, and updates its internal pointer. This reallocation process happens automatically as needed, but if triggered too often, it can introduce significant performance costs.</p> <p>By default, a vector typically grows its capacity by around 50% of the previous one when resizing. While this amortizes the cost across many insertions, frequent resizes can still slow things down\u2014especially when dealing with large amounts of data or non-trivial object types.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass Vertex {\npublic:\n    float x;\n    float y;\n    float z;\n\n    Vertex() = default;\n\n    Vertex(float x, float y, float z)\n        : x(x), y(y), z(z) {\n    }\n\n    Vertex(const Vertex&amp; vertex)\n        : x(vertex.x), y(vertex.y), z(vertex.z) {\n        std::cout &lt;&lt; \"Copied!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::vector&lt;Vertex&gt; vertices;\n\n    vertices.push_back(Vertex(1, 2, 3));\n    vertices.push_back(Vertex(4, 5, 6));\n    vertices.push_back(Vertex(7, 8, 9));\n}\n</code></pre> output<pre><code>Copied!\nCopied!\nCopied!\nCopied!\nCopied!\nCopied!\n</code></pre> <p>Let\u2019s break down what\u2019s happening in the example above. When running this code, you'll see six copy operations\u2014even though we're only adding three elements. This might seem surprising at first, but it reveals two important areas where we can optimize our use of <code>std::vector</code>.</p> <p>The first issue is how we're adding elements. When we write it as is we're creating a temporary <code>Vertex</code> object and then copying it into the vector. Even though the construction happens inside the <code>push_back</code> call, it's still a two-step process: first, the object is constructed, then it\u2019s copied into the vector. This accounts for three copies\u2014one for each object we add.</p> <p>The second problem stems from how <code>std::vector</code> handles its memory. When we don\u2019t specify a capacity ahead of time, the vector starts with a small default capacity (often 2, depending on the implementation). As we add more elements, the vector must resize itself. Each time this happens, it allocates new memory, copies all existing elements into the new block, and deallocates the old one. Since we\u2019re adding three elements and the initial capacity isn't sufficient, we trigger at least one reallocation, which causes the existing elements to be copied again. That\u2019s another three copies, bringing the total to six.</p> <p>To prevent these unnecessary copies, there are two simple optimizations we can apply:</p> <ol> <li>Reserve memory ahead of time: If we know how many elements we'll add, we can call <code>.reserve()</code> on the vector before inserting data.    This ensures enough space is allocated up front, so no reallocations are needed during insertion.</li> <li>Construct in-place: Instead of using <code>push_back</code>, use <code>emplace_back</code>, which constructs the object directly inside the vector, avoiding the temporary copy.</li> </ol> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass Vertex {\npublic:\n    float x;\n    float y;\n    float z;\n\n    Vertex() = default;\n\n    Vertex(float x, float y, float z)\n        : x(x), y(y), z(z) {\n    }\n\n    Vertex(const Vertex&amp; vertex)\n        : x(vertex.x), y(vertex.y), z(vertex.z) {\n        std::cout &lt;&lt; \"Copied!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::vector&lt;Vertex&gt; vertices;\n    vertices.reserve(3);\n\n    vertices.emplace_back(1, 2, 3);\n    vertices.emplace_back(4, 5, 6);\n    vertices.emplace_back(7, 8, 9);\n}\n</code></pre> output<pre><code>None\n</code></pre> <p>It's also worth noting that there is another way to initialize a vector with a default size, but it is not as efficient. While the <code>reserve</code> method is more explicit and better, it can be substituted with syntax where we specify the vector's size directly in the constructor. This not only reserves memory but also defaultly initializes the elements (e.g., filling an integer vector with zeros or a string vector with empty strings).</p> example<pre><code>std::vector&lt;Vertex&gt; vertices(3);\n</code></pre> <p>However, this method should be used with caution because, although it avoids reallocations, it still results in unnecessary copies. Specifically, using this approach would create 3 copies in this context, as we are assigning values after initialization. Instead, using <code>emplace_back</code> is the more efficient way to handle this situation.</p>"},{"location":"07%20Collections%20of%20Data/#hashmap","title":"HashMap","text":"<p>Info</p> <p>As always, we won\u2019t cover every single operation available for C++ maps here\u2014our focus is on understanding how they work logically. For a complete list of functionalities, refer to the documentation:</p> <ul> <li>https://cplusplus.com/reference/map/map/</li> <li>https://cplusplus.com/reference/unordered_map/unordered_map/</li> </ul> <p>Sometimes, we need more than just a list of values. We want to associate one piece of data with another\u2014like a name with a phone number, or a username with a score. This is for what associative containers, also known as maps, are for.</p> <p>Unlike arrays or vectors, which use numeric indices to access elements, maps store key\u2013value pairs. You provide a unique key, and the map returns the corresponding value. This means maps are ideal when you need fast access to specific elements, especially when you don\u2019t care about the order of the data.</p> <p>In C++, the Standard Library provides two main types of maps.</p> Type Description <code>std::map</code> A sorted map implemented using a self-balancing red-black tree. <code>std::unordered_map</code> A hash table that offers faster lookups by using a hashing algorithm. <p>A <code>std::map</code> keeps its keys in sorted order using a red-black tree under the hood. Each time you insert or search for a key, it traverses the tree by comparing keys until it finds the correct spot. The tradeoffs are lookups and insertions have a time complexity of O(log n)\u2014which is still fast, but not as fast as a hash map for most use cases.</p> <p></p> <p>Because of the guaranteed order, <code>std::map</code> is useful when you want to iterate through the keys in sorted order or need range-based queries.</p> <p>If you don\u2019t care about key order and just want the fastest possible lookups, <code>std::unordered_map</code> is usually the better choice. It uses a hash function to compute an index for each key, giving it average-case constant-time access\u2014O(1). This is ideal when you're doing lots of lookups and inserts based on unique keys.</p> <p></p> <p>However, this speed comes with tradeoffs. <code>std::unordered_map</code> uses more memory, and hash collisions (when two keys hash to the same index) can slow things down slightly. But in most real-world scenarios, the performance gain is worth it. So prefer <code>std::unordered_map</code> for its speed\u2014unless you need the keys to stay sorted or require ordered traversal.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n\nstruct City {\n    unsigned int area_km;\n    unsigned int population;\n};\n\nint main() {\n    std::map&lt;std::string, City&gt; city_records1;\n    std::unordered_map&lt;std::string, City&gt; city_records2;\n\n    city_records1[\"London\"] = City{\n        .area_km = 1'572,\n        .population = 8'945'309\n    };\n    city_records1[\"Madrid\"] = City{\n        .area_km = 604,\n        .population = 3'345'894\n    };\n\n    city_records2[\"Berlin\"] = City{\n        .area_km = 891,\n        .population = 3'596'999\n    };\n    city_records2[\"Sydney\"] = City{\n        .area_km = 12'367,\n        .population = 3'596'999\n    };\n\n    std::cout &lt;&lt; \"London population: \" &lt;&lt; city_records1[\"London\"].population &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"London area: \" &lt;&lt; city_records1[\"London\"].area_km &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"Berlin population: \" &lt;&lt; city_records2[\"Berlin\"].population &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Berlin area: \" &lt;&lt; city_records2[\"Berlin\"].area_km &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>London population: 8945309\nLondon area: 1572\nBerlin population: 3596999\nBerlin area: 891\n</code></pre> <p>Both <code>std::map</code> and <code>std::unordered_map</code> store data as key-value pairs and take two template parameters: the key type and the value type. You can access and modify values using the same square bracket syntax you're used to with arrays: <code>map[key]</code>.</p> <p>One important behavior to be aware of is this: if you access a key that doesn\u2019t exist yet, the map will automatically create a new entry with a default-constructed value. This can be convenient in many cases, but it can also introduce bugs if you're not careful\u2014especially if you accidentally use a key that was never meant to be inserted.</p> <p>There\u2019s also a key difference between <code>std::map</code> and <code>std::unordered_map</code> in terms of how they manage keys:</p> Container Type Key Requirement Reason <code>std::map</code> Must support the less-than operator (<code>&lt;</code>) Keys are stored in sorted order using a tree structure <code>std::unordered_map</code> Must be hashable Keys are stored in a hash table, which uses a hash function for lookup <p>If you try to use a custom type as a key without implementing the appropriate comparison or hashing support, the compiler will produce an error.</p>"},{"location":"07%20Collections%20of%20Data/#hashing-function","title":"Hashing Function","text":""},{"location":"07%20Collections%20of%20Data/#index-operator","title":"Index Operator","text":"<p>When working with constant maps (such as <code>const std::unordered_map</code>), the index operator cannot be used. This is because it will insert a default-constructed value if the key doesn\u2019t exist\u2014an action that would modify the map, which isn\u2019t allowed on a constant object. This behavior was mentioned earlier and is exactly why using index operator on constant maps causes a compilation error.</p> <p>To safely access elements in a constant map without risking modification, we use the <code>.at()</code> method. Unlike index operator, it performs bounds checking and throws an out of range exception if the key doesn\u2019t exist\u2014so we must first ensure the key is present.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nstruct City {\n    unsigned int area_km;\n    unsigned int population;\n};\n\nint main() {\n    std::unordered_map&lt;std::string, City&gt; city_records = {\n        {\"Berlin\", City{\n            .area_km = 891,\n            .population = 3'596'999\n        }}\n    };\n\n    if (city_records.find(\"Berlin\") != city_records.end())\n        std::cout &lt;&lt; \"Berlin population: \" &lt;&lt; city_records.at(\"Berlin\").population &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Berlin population: 3596999\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#linked-list","title":"Linked List","text":"<p>We\u2019ve now covered the most commonly used containers in C++. However, there are still some data structures worth knowing\u2014even if they\u2019re not as commonly used in modern code. One such structure is the linked list, which is available in the C++ Standard Library as <code>std::list</code>.</p> <p>While many of its use cases can be mimicked using the containers we\u2019ve already introduced, a linked list is unique in its structure and behavior. The C++ STL implementation specifically provides a doubly linked list, which, like <code>std::vector</code>, supports dynamic resizing, but with a completely different internal mechanism.</p> <p>Unlike arrays and vectors that store elements in contiguous memory blocks, a linked list is composed of nodes. Each node holds:</p> <ol> <li>a value</li> <li>a pointer to the previous node</li> <li>a pointer to the next node</li> </ol> <p></p> <p>This layout enables fast insertions and deletions from anywhere in the list without shifting elements, making it useful in specific scenarios. However, it also brings increased memory usage and no support for random access, making it less performant for frequent lookups compared to vectors.</p> <p>To use a linked list in C++, just include the <code>&lt;list&gt;</code> header.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nint main() {\n    std::list&lt;int&gt; list = {73, 19, 86, 42, 5};\n    list.push_back(67);\n\n    for (const auto&amp; element : list)\n        std::cout &lt;&lt; element &lt;&lt; '\\t';\n}\n</code></pre> output<pre><code>73  19  86  42  5\n</code></pre> <p>The <code>std::list</code> class offers a familiar interface\u2014its API is very similar to that of <code>std::array</code> and <code>std::vector</code>. The real difference lies in how it stores and manages its data.</p> <p>You should consider using <code>std::list</code> when your program involves frequent insertions or deletions at arbitrary positions in the sequence. Unlike std<code>::vector</code>, a linked list doesn\u2019t need to shift elements when inserting or removing them in the middle. This can significantly improve performance in certain scenarios.</p> <p>Another major benefit of <code>std::list</code> is iterator stability\u2014modifying the container (such as inserting or removing elements) does not invalidate existing iterators, which is not the case with <code>std::vector</code>.</p> <p>That said, in the majority of situations, <code>std::vector</code> remains the better default choice. It provides better memory efficiency, faster random access, and superior cache performance due to its use of contiguous memory.</p> <p>In short: use <code>std::list</code> for frequent insertions/removals in the middle; stick with <code>std::vector</code> when you care about access speed and memory locality.</p>"},{"location":"07%20Collections%20of%20Data/#stack-and-queue","title":"Stack and Queue","text":"<p>Continuing with container-like data structures in the STL, let\u2019s talk about stacks and queues\u2014two foundational tools that help structure the way we handle data.</p> <p>These structures differ from arrays, vectors, or linked lists in one key way: you don\u2019t control where data goes\u2014you only interact with the ends, based on the specific rules of the structure.</p> <p>A stack operates on a Last In, First Out (LIFO) principle. That means the last element you push in is the first one that comes out. You can think of it like stacking plates\u2014if you want the one at the bottom, you\u2019ll have to take the top ones off first.</p> <p>Stacks do not allow random access or iteration\u2014you can only interact with the top element.</p> <p>Common operations include:</p> Operation Description <code>push()</code> Adds an element to the top <code>pop()</code> Removes the top element <code>top()</code> Returns a reference to the top element <code>empty()</code> Checks if the stack is empty <code>size()</code> Returns the number of elements <p>To use a stack in C++, just include the <code>&lt;stack&gt;</code> header.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nint main() {\n    std::stack&lt;int&gt; stack;\n    stack.push(10);\n    stack.push(20);\n    stack.push(30);\n\n    std::cout &lt;&lt; \"Top element: \" &lt;&lt; stack.top() &lt;&lt; std::endl;\n    stack.pop();\n    std::cout &lt;&lt; \"New top element: \" &lt;&lt; stack.top() &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Top element: 30\nNew top element: 20\n</code></pre> <p>A queue works the opposite way: it follows a First In, First Out (FIFO) rule. That means the first element you insert is the first to be removed\u2014just like people lining up at a ticket counter.</p> <p>A queue gives you access to the front and back elements only\u2014there\u2019s no way to randomly access or iterate through its contents directly.</p> <p>Common operations include:</p> Operation Description <code>push()</code> Adds an element to the back <code>pop()</code> Removes the front element <code>front()</code> Returns a reference to the front element <code>back()</code> Returns a reference to the last element <code>empty()</code> Checks if the queue is empty <code>size()</code> Returns the number of elements <p>To use a queue in C++, include the <code>&lt;queue&gt;</code> header:</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n\nint main() {\n    std::queue&lt;int&gt; queue;\n    queue.push(1);\n    queue.push(2);\n    queue.push(3);\n\n    std::cout &lt;&lt; \"Front element: \" &lt;&lt; queue.front() &lt;&lt; std::endl;\n    queue.pop();\n    std::cout &lt;&lt; \"New front element: \" &lt;&lt; queue.front() &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Front element: 1\nNew front element: 2\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#iterators","title":"Iterators","text":"<p>Now that we\u2019ve covered several STL containers, it's time to explore a powerful mechanism that underpins how we work with these collections: iterators.</p> <p>At a high level, iterators in C++ behave much like pointers\u2014they allow us to step through a container, one element at a time. This makes them useful not only for traversal, but also for performing operations like insertion, deletion, or modification during iteration.</p> <p>All standard C++ containers\u2014such as <code>std::array</code>, <code>std::vector</code>, <code>std::list</code>, and <code>std::map</code>\u2014are designed to support iteration. Some, like <code>std::array</code> and <code>std::vector</code>, store their elements in contiguous memory, so you can often get by using index-based access. But others, like <code>std::list</code>, <code>std::set</code>, or <code>std::map</code>/<code>std::unordered_map</code>, don't support random indexing at all. For these, iterators are essential.</p> <p>That\u2019s why each STL container comes with built-in iterator support. Iterators are objects that act like generalized pointers. You can dereference them to access a value, increment them to move to the next element, and use them to drive algorithms that operate over sequences of data.</p> <p>They\u2019re especially valuable when working with containers that lack direct index access or when you need fine-grained control over iteration. Some examples where iterators really shine:</p> <ul> <li>Removing elements while iterating through a container.</li> <li>Inserting new elements during traversal.</li> <li>Working with containers like std::set or std::map that don't support operator[].</li> <li>Writing generic code that works with any iterable container.</li> </ul> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nint main() {\n    std::list&lt;int&gt; list = {58, 6, 91, 27, 44};\n\n    /*\n        This won\u2019t work because `std::list` doesn\u2019t\n        support the regular indexing operator `[]`\n\n        for (int i = 0; i &lt; list.size(); ++i)\n            std::cout &lt;&lt; list[i] &lt;&lt; '\\t';\n    */\n\n    for (std::list&lt;int&gt;::iterator it = list.begin(); it != list.end(); ++it)\n        std::cout &lt;&lt; *it &lt;&lt; '\\t';\n\n    /*\n        This is exactly where `auto` shines,\n        replacing the clunky long iterator type\n        without risk of losing clarity:\n\n        for (auto it = list.begin(); it != list.end(); ++it)\n            std::cout &lt;&lt; *it &lt;&lt; '\\t';\n    */\n}\n</code></pre> output<pre><code>58  6   91  27  44\n</code></pre> <p>As shown in the example, an iterator is essentially a pointer to an element within a data structure. That\u2019s why we can use pointer-like operations on iterators, such as increment operator to move to the next element.</p> Method What it points to Purpose / Notes <code>.begin()</code> The first element of the container Marks the start of iteration <code>.end()</code> One past the last element (not valid) Acts as a sentinel to mark the end; used to indicate \u201cnot found\u201d in functions like <code>find()</code> <p>This iterator-based approach works consistently across all STL containers.</p>"},{"location":"07%20Collections%20of%20Data/#range-based-for-loops","title":"Range-Based For Loops","text":"<p>Since every STL container provides iterators via its <code>.begin()</code> and <code>.end()</code> methods, we can use those iterators directly for traversal and modification.</p> <p>However, writing explicit iterator loops can be verbose and less readable. This is where range-based for loops come in \u2014 they provide a cleaner, more concise syntax for iterating over any iterable container.</p> <p>Under the hood, the range-based for loop uses the container\u2019s iterators automatically. You don\u2019t need to write the iterator variables or increment expressions yourself. This makes the code easier to write and read, while still leveraging the power of iterators.</p> <p>Any container that implements <code>.begin()</code> and <code>.end()</code> \u2014 including common STL containers like <code>std::array</code>, <code>std::vector</code>, <code>std::list</code>, <code>std::map</code>, and others \u2014 can be used directly in a range-based for loop.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nint main() {\n    std::array&lt;int, 5&gt; array = {73, 12, 89, 47, 31};\n\n    for (int element : array)\n        std::cout &lt;&lt; element &lt;&lt; '\\t';\n\n    /*\n        It's better to use `auto` for long or complex types.\n        Also, if you're only reading the data, use a `const` reference\n        to avoid unnecessary copies and save resources.\n\n        for (const auto&amp; element : array)\n            std::cout &lt;&lt; element &lt;&lt; '\\t';\n    */\n}\n</code></pre> output<pre><code>73  12  89  47  31\n</code></pre>"},{"location":"07%20Collections%20of%20Data/#questions","title":"Questions","text":"question 1answer <p>What is the main difference between a C-style array and a <code>std::array</code>?</p> <p>A C-style array has a fixed size and provides no bounds checking. A <code>std::array</code> also has a fixed size, but it is a safer wrapper around a C-style array that integrates with the C++ standard library.</p> question 2answer <p>What happens to a C-style array when it is passed to a function?</p> <p>When passed to a function, a C-style array decays into a pointer to its first element, losing information about its size.</p> question 3answer <p>How does pointer arithmetic behave when applied to an array?</p> <p>Pointer arithmetic advances the pointer by multiples of the element size, not by raw bytes.</p> question 4answer <p>How are multidimensional arrays stored in memory in C/C++?</p> <p>Multidimensional arrays allocated on the stack are stored in a single contiguous block of memory. They use row-major order, where each row is laid out directly after the previous one.</p> <p>Multidimensional arrays dynamically allocated on the heap using pointers are typically implemented as an array of pointers. In this case, each row is stored separately and is not guaranteed to be contiguous with the others leading to memory fragmentation.</p> question 5answer <p>Why must dynamically allocated arrays be deallocated using <code>delete[]</code> instead of <code>delete</code>?</p> <p><code>delete[]</code> ensures that all elements in the array are properly destroyed, while <code>delete</code> only destroys a single object.</p> question 6answer <p>What character marks the end of a C-style string?</p> <p>A C-style string is terminated by the null character <code>'\\0'</code>.</p> question 7answer <p>What advantages does <code>std::string</code> have over C-style strings?</p> <p><code>std::string</code> manages memory automatically, prevents buffer overflows, and provides rich functionality for string manipulation.</p> question 8answer <p>What is <code>std::string_view</code>, and does it own the string data it refers to?</p> <p><code>std::string_view</code> is a non-owning view into a string; it does not manage or extend the lifetime of the referenced data.</p> question 9answer <p>Why are range-based for loops considered safer and more expressive than manual iterator loops?</p> <p>Range-based for loops use iterators internally and reduce errors by avoiding manual index or iterator management.</p> question 10answer <p>How does a hash map determine where to store a value, and what role does the hash function play?</p> <p>A hash map uses a hash function to turn a key into an index, which tells it where to store the value. The function tries to spread keys evenly so things don\u2019t get clumped together, making lookups faster.</p>"},{"location":"07%20Collections%20of%20Data/#exercises","title":"Exercises","text":""},{"location":"08%20User%20Defined%20Types/","title":"08 User Defined Types","text":"<p>In the previous chapter, we explored how to organize data using C-style arrays, strings and STL containers. These are great when you\u2019re working with a list of similar things\u2014like numbers, coordinates, or game items. But they only work when all the elements are of the same type.</p> <p>In real-world programs, you often need to combine different kinds of values into one thing. Think of a game character: you might need to track their name, score, and health\u2014all of which are different types of data. Handling each one separately quickly becomes awkward and error-prone.</p> <p>That\u2019s why programming languages like C++ let us create our own complex data types\u2014custom structures that bundle different kinds of information together under a single name. Instead of juggling multiple variables for one concept, you can wrap them into a single, unified object that better reflects what you\u2019re actually working with.</p> <p>In this chapter, we\u2019ll explore how to build and use these custom structures to keep your programs clean, organized, and scalable. We\u2019ll start with the simplest and most practical form: grouping variables into one meaningful unit.</p>"},{"location":"08%20User%20Defined%20Types/#structs","title":"Structs","text":"<p>A struct lets you group related data under a single name. Its members can be of different types, and you access them using the dot operator. Structs are great for organizing simple, related pieces of information\u2014like integers, floating-point numbers, or strings\u2014into a single unit. Like arrays, the members of a struct are stored in contiguous memory. If you remember why this matters, it\u2019s the reason we can perform type punning with structs.</p> <p>When a struct contains only simple data types without extra behavior, it\u2019s often called a Plain Old Data (POD) type.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Player {\n    std::string username;\n    unsigned int score;\n    double health;\n};\n\nint main() {\n    Player player;\n    player.username = \"Unknown\";\n    player.score = 45.0;\n\n    std::cout &lt;&lt; \"Player username: \" &lt;&lt;  player.username &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Player username: Unknown\n</code></pre> <p>In this example, the <code>struct</code> name <code>Player</code> defines a custom data type, allowing us to create variables of that type.</p> <p>Notice that the <code>struct</code> like other structure we will be covering is defined outside the main function, which gives it global scope. This isn\u2019t strictly necessary\u2014if you only need to use it within a single function or other scope, you can define it there. However, in most cases, the entire translation unit needs access to it, so defining it globally is the usual approach.</p> <p>Also, the <code>struct</code> definition must end with a semicolon, forgetting this will cause a compilation error.</p> <p>Beyond just holding data, a struct can also include functions that can manipulate that data. These are called member functions or methods, and they can operate on the struct\u2019s members because they\u2019re defined inside the structs scope.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Player {\n    std::string username;\n    unsigned int score;\n    double health;\n\n    void ReduceHealth() {\n        health -= 10;\n    }\n};\n\nint main() {\n    // Initialize all members with an initializer list\n    Player player{\"Random\", 0, 100};\n\n    player.ReduceHealth();\n\n    std::cout &lt;&lt; \"Player health: \" &lt;&lt; player.health &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Player health: 90\n</code></pre> <p>Note</p> <p>Adding methods to structs is a feature unique to C++. This is important to note because structs originate from C, where attaching methods is not possible.</p> <p>We can also initialize all member variables at once using curly braces with values \u2014 this is known as aggregate initialization. However, the values must be provided in the same order as the member variables are declared in the <code>struct</code>, since they are assigned from top to bottom.</p> <p>C++ again offers a clearer alternative called designated initializers, where you explicitly specify which value corresponds to each member by name. This improves readability, especially when the <code>struct</code> definition is far from its usage or when dealing with many members.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Player {\n    std::string username;\n    unsigned int score;\n    double health;\n\n    void ReduceHealth() {\n        health -= 10;\n    }\n};\n\nint main() {\n    // Designated initializers\n    Player player{\n        .username = \"Random\",\n        .score = 0,\n        .health = 100\n    };\n\n    player.ReduceHealth();\n\n    std::cout &lt;&lt; \"Player health: \" &lt;&lt; player.health &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Player health: 90\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#bitfields","title":"Bitfields","text":"<p>So far, every struct member we\u2019ve used has occupied at least one full byte of memory. That\u2019s usually fine\u2014but sometimes, especially in low-level or memory-sensitive code, we want tighter control over how data is laid out.</p> <p>In many real-world cases, a value only needs a few bits. A flag might only represent on or off, a status code might fit in a small range, or a set of options might be stored as individual switches. Using a full int or even a full char for these cases wastes space.</p> <p>Bitfields let you specify exactly how many bits a struct member should occupy. They are declared inside a struct by placing a colon and a bit width after the member name.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Flags {\n    unsigned is_visible : 1;\n    unsigned is_active  : 1;\n    unsigned has_error  : 1;\n};\n\nint main() {\n    Flags flags{1, 0, 1};\n\n    std::cout &lt;&lt; \"Visible: \" &lt;&lt; flags.is_visible &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Active: \" &lt;&lt; flags.is_active &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Error: \" &lt;&lt; flags.has_error;\n}\n</code></pre> output<pre><code>Visible: 1\nActive: 0\nError: 1\n</code></pre> <p>Each field here occupies only one bit, yet behaves like a normal integer when accessed. Internally, the compiler packs these values together into a single storage unit.</p> <p>Bitfields can also store small integer ranges, not just booleans.</p> example<pre><code>struct Color {\n    unsigned red   : 8;\n    unsigned green : 8;\n    unsigned blue  : 8;\n};\n</code></pre> <p>Each color channel is limited to 8 bits, giving it a range of 0\u2013255\u2014exactly what we want for RGB values. This representation is both compact and expressive.</p>"},{"location":"08%20User%20Defined%20Types/#unions","title":"Unions","text":"<p>A <code>union</code> is similar to a <code>struct</code> in that it groups related variables under a single name. However, unlike a <code>struct</code>, a <code>union</code> shares the same memory space among all its members. This means a <code>union</code> can only store one value at a time, and its total size is determined by the largest member it contains.</p> <p>For example, if a union holds four <code>float</code> members named <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code>, it will only occupy the size of one float\u20144 bytes\u2014instead of the combined size of all four, which would total 16 bytes. Since all members share the same memory location, changing one member will affect the others.</p> <p>Unions are useful for type punning, which means interpreting the same chunk of memory in different ways. They also enable aliasing, where the same data can be accessed under different names. For instance, a <code>union</code> might let you treat a 3D vector (x, y, z) as an RGB color (r, g, b) without duplicating memory.</p> <p>Also unions can be declared on their own or embedded anonymously inside other structures for convenience. Unlike structs, unions do not support member functions, except for constructors and destructors.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nunion Vector3 {\n    struct {\n        double x;\n        double y;\n        double z;\n    };\n\n    struct {\n        double r;\n        double g;\n        double b;\n    };\n};\n\nint main() {\n    Vector3 vec3{14.3, 22.78, 237.4};\n\n    // Accessed as coordinates\n    std::cout &lt;&lt; \" x: \" &lt;&lt; vec3.x;\n    std::cout &lt;&lt; \" y: \" &lt;&lt; vec3.y;\n    std::cout &lt;&lt; \" z: \" &lt;&lt; vec3.z &lt;&lt; std::endl;\n\n    // Accessed as color components\n    std::cout &lt;&lt; \" r: \" &lt;&lt; vec3.r;\n    std::cout &lt;&lt; \" g: \" &lt;&lt; vec3.g;\n    std::cout &lt;&lt; \" b: \" &lt;&lt; vec3.b &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code> x: 14.3 y: 22.78 z: 237.4\n r: 14.3 g: 22.78 b: 237.4\n</code></pre> <p>In this example, we define a union called <code>Vector3</code> that allows accessing its data in two different ways:</p> <ul> <li>As coordinates (x, y, z) when used as a 3D vector.</li> <li>As color components (r, g, b) when used in a color palette.</li> </ul> <p>Notice that these variables are grouped inside anonymous structs within the union. Without the structs, the union would only allow one active variable at a time, so you couldn\u2019t store all three values simultaneously.</p> <p>Anonymous structs act like regular structs but inherit their member names directly into the union. This lets us write <code>vec3.x</code> instead of something longer like <code>vec3.color.r</code>, keeping the code clean.</p>"},{"location":"08%20User%20Defined%20Types/#enums","title":"Enums","text":"<p>Enums, short for enumerations, allow us to define a set of named constants that are represented by integer values. They\u2019re useful for giving meaningful names to integer values, making the code easier to read and less prone to errors.</p> <p>One big advantage of enums is that they limit the possible values a variable can hold. Instead of using plain integers to represent different states, enums ensure only predefined values are allowed.</p> <p>For example, say we want to represent different screen states in a program, like a Start Screen and an End Screen. Without enums, we might use integers like <code>1</code> for the start screen and <code>2</code> for the end screen\u2014but this can cause bugs if invalid numbers are used accidentally. Enums prevent that by defining a fixed set of allowed values.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nenum Screen {\n    StartScreen,\n    EndScreen\n};\n\nint main() {\n    Screen screen = StartScreen;\n\n    std::cout &lt;&lt; \"Screen state: \" &lt;&lt; screen &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Enum byte size: \" &lt;&lt; sizeof(screen) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Screen state: 0\nEnum byte size: 4\n</code></pre> <p>In this example, the enum members start at <code>0</code>, which is the default behavior in C++, and each subsequent member increases by <code>1</code>. However, you can specify a custom starting value, and any subsequent members without an explicit value will continue incrementing from the last assigned number. This continues until another manually assigned value appears, which resets the counting from that new number.</p> <p>By default, an enum uses int (typically 4 bytes) as the underlying type to store its values. But if that's more memory than necessary, you can choose a smaller integer type by using a colon after the enum name, followed by the type you want.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nenum Screen : char {\n    StartScreen = 1,\n    EndScreen,       // Becomes 2\n    SomeScreen = 10,\n    AnotherScreen    // Becomes 11\n};\n\nint main() {\n    Screen screen = AnotherScreen;\n\n    std::cout &lt;&lt; \"Screen state: \" &lt;&lt; static_cast&lt;int&gt;(screen) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Enum byte size: \" &lt;&lt; sizeof(screen) &lt;&lt; \" byte\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Screen state: 11\nEnum byte size: 1 byte\n</code></pre> <p>Warning</p> <p>C++ allows you to print regular enums and use them in arithmetic expressions because they implicitly convert to integers.</p> <p>But this doesn't apply to all enums. If you use <code>enum class</code> (scoped enum), or if you manually specify an underlying type (like <code>char</code>, <code>short</code>, or <code>unsigned int</code>), you lose automatic conversion in many contexts \u2014 especially with <code>enum class</code>.</p> <p>This means you'll need to explicitly cast the value to an integer type before printing it or doing math with it.</p> <p>As you\u2019ve seen, regular enums in C++ are a handy way to assign names to integer or other numeric values. They make code easier to read and help avoid using magic numbers \u2014 literal numbers in code without clear meaning.</p> <p>But traditional enums have some downsides that become more noticeable as your code grows in size and complexity. One of the main issues is that all the <code>enum</code> values share the same global scope, which can easily lead to naming conflicts. Also, regular enums implicitly convert to integers, which can result in unexpected behavior if you're not careful. To address these problems, C++ introduced scoped enums using <code>enum class</code>.</p> <p>Scoped enums behave more strictly \u2014 and that's a good thing. Here's what makes them different:</p> <ul> <li>No global clutter: Enum members no longer leak into the global scope.</li> <li>Type safety: You can\u2019t accidentally treat them like integers without a cast.</li> <li>Explicit usage: You must qualify enum members with their enum name, which makes the code easier to follow.</li> </ul> main.cpp<pre><code>#include &lt;iostream&gt;\n\n\n/*\n    This approach cluters global scope\n\n    enum GameState {\n        Start,\n        Playing,\n        End\n    };\n*/\n\nenum class MenuOption : char {\n    Start = 1,\n    Settings,\n    Exit = 10,\n    Credits\n};\n\nint main() {\n    /*\n        OK \u2014 enum members are globally visible\n\n        GameState game = Start;\n    */\n\n    // Must use the prefix\n    MenuOption menu = MenuOption::Settings; \n\n    /*\n        OK \u2014 Implicit conversion works\n\n        std::cout &lt;&lt; \"GameState (Start) as int: \" &lt;&lt; game &lt;&lt; std::endl;\n    */\n\n    // Must cast \u2014 scoped enums don't convert automatically\n    std::cout &lt;&lt; \"Screen state: \" &lt;&lt; static_cast&lt;int&gt;(menu) &lt;&lt; std::endl;\n\n    // std::cout &lt;&lt; \"Size of GameState: \" &lt;&lt; sizeof(game) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Enum byte size: \" &lt;&lt; sizeof(menu) &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Screen state: 2\nEnum byte size: 1\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#classes","title":"Classes","text":"<p>By now, we've looked at different ways to group related pieces of data \u2014 using structs, unions, and even basic enums. These approaches all come from the C side of things. While they don't behave identically in C++, they still follow the same procedural mindset.</p> <p>But as your programs begin to model real-world entities \u2014 for instance, in medical software where you might represent a patient, track their medical history, and perform operations like scheduling appointments or updating test results \u2014 a more powerful abstraction becomes useful. That\u2019s where classes come in.</p> <p>This isn\u2019t to say that classes are mandatory. Many developers stick with procedural programming, which avoids classes and sticks to functions and data structures. It's perfectly valid and often simpler for smaller or tightly focused programs.</p> <p>However, another widely used approach is Object-Oriented Programming (OOP) \u2014 and classes are at the heart of it.</p> <p>A class is a blueprint for building objects that combine data and behavior. Classes form the foundation of OOP, a style of programming that models things as self-contained units called objects. Each object holds both state (data) and functionality (methods).</p> <p>Unlike Java or C#, C++ doesn\u2019t force you into OOP. It leaves the choice to you. But when your project calls for organizing logic around real-world concepts, classes give you the right tools.</p> <p>Just like a struct, a class lets you group related member variables under a single name. But with classes, you also get access control, encapsulation, and structured member functions \u2014 also known as methods \u2014 that act on the internal state of the object.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Patient {\npublic:\n    std::string name;\n    int age;\n\n    void PrintInfo() {\n        std::cout &lt;&lt; \"Patient: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Patient patient;\n    patient.name = \"Unknown Patient\";\n    patient.age = 42;\n\n    patient.PrintInfo();\n}\n</code></pre> output<pre><code>Patient: Unknown Patient, Age: 42\n</code></pre> <p>With the class implementation, we can see some key differences compared to structs. The most notable one is access control, made possible through access specifiers. In C++, classes support three kinds of access.</p> Access Specifier Description <code>public</code> Members can be accessed from anywhere in the program. <code>private</code> Members can only be accessed from within the class. This is the default access level in classes. They cannot be accessed directly from outside the class, but can be accessed indirectly through public methods. <code>protected</code> Like <code>private</code>, but members are also accessible by derived classes (i.e., subclasses in inheritance). <p>Note</p> <p>In C++, the only difference between a <code>struct</code> and a <code>class</code> is their default access level: members of a <code>struct</code> are public by default, while members of a <code>class</code> are private by default.</p> <p>In C, <code>structs</code> cannot contain methods, but in C++, they can. However, it\u2019s generally best to use structs for simple data grouping\u2014types that hold multiple variables without associated functionality\u2014to keep design intentions clear and maintain a clean separation between plain data and more complex behavior.</p> <p>In the example above, the <code>name</code> and <code>age</code> members were declared as public, which allows us to set and access them directly in <code>main()</code> using the dot operator. If they had been marked private, we wouldn\u2019t be able to access them directly from outside the class. Instead, we\u2019d need to use getter and setter methods (or another kind of public interface) to interact with those values \u2014 something we\u2019ll cover a bit later.</p> <p>Another common convention is to prefix private member variables with <code>m_</code> or suffix them with <code>_</code> (e.g., <code>m_name</code> or <code>age_</code>). Here, we\u2019ll use the underscore suffix style as it tends to be cleaner and easier to read. This naming convention helps clearly distinguish member variables from local variables or function parameters, especially in larger codebases. It also improves readability, reduces naming conflicts, and eliminates the need to use the this pointer explicitly in most cases \u2014 something we\u2019ll explore a bit later as well.</p>"},{"location":"08%20User%20Defined%20Types/#static-inside-class","title":"Static Inside Class","text":"<p>So far, we\u2019ve seen how classes let each object maintain its own set of member variables with data unique to that particular object, created from the blueprint of a class like <code>Patient</code>. But sometimes, you want a variable or function to belong to the class itself, rather than to any single object.</p> <p>This can be achived by placing <code>static</code> keyword before a member variable or method\u2019s data type, you make it shared across all instances of the class. Instead of belonging to one object, the member belongs to the class as a whole.</p> <p>For example, a static variable can count how many objects have been created \u2014 like tracking how many patients have been registered. This shared state is useful for managing common data or resources that all objects of the class need to access.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Counter {\npublic:\n    static int value;\n\n    static void Increment() {\n        ++value;\n    }\n};\n\n// Static variables have to be defined outside the class\nint Counter::value = 0;\n\nint main() {\n    Counter::Increment();\n    Counter::Increment();\n\n    std::cout &lt;&lt; \"Counter value: \" &lt;&lt; Counter::value &lt;&lt; std::endl;\n\n    /*\n        You can also access static members\n        via an object (though it's not preferred)\n    */\n    Counter c;\n    c.Increment();\n\n    std::cout &lt;&lt; \"Counter value after object call: \" &lt;&lt; c.value &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Counter value: 2\nCounter value after object call: 3\n</code></pre> <p>We can see that the <code>value</code> is shared across all instances of the class. However, since it's a static member, it must be defined outside the class\u2014this step is required to allocate memory for it. If you forget to do this, you'll get a linker error.</p>"},{"location":"08%20User%20Defined%20Types/#static-outside-class","title":"Static Outside Class","text":"<p>The <code>static</code> keyword in C++ has two distinct meanings depending on where it's used. One use, as we saw in the previous section, is inside a class\u2014where it makes a member variable or method shared across all instances. But <code>static</code> can also be used outside of a class, and in that context, it means something different.</p> <p>When applied at file scope, <code>static</code> makes a variable or function local to the current translation unit\u2014in other words, visible only within the file in which it's declared. This limits external access, prevents unintended usage from other files, and helps avoid name conflicts across a project.</p> <p>If a variable is declared as <code>static</code> at the top level of a file (not inside any function or class), it exists for the lifetime of the program but remains completely invisible to other source files. This allows the same variable name to safely exist in multiple translation units without clashing.</p> static.cpp<pre><code>int value = 20;\n</code></pre> main.cpp<pre><code>#include &lt;iostream&gt;\n\nint value = 10;\n\nint main() {\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>error: one or more multiply defined symbols found\n</code></pre> <p>If we declare a global variable like <code>value</code> in <code>static.cpp</code> and then declare another global <code>value</code> in <code>main.cpp</code>, the compiler produces a linker error due to multiple definitions of the same symbol. Global variables without the static keyword have external linkage by default, meaning their names are visible across translation units. That\u2019s what causes the conflict here.</p> <p>To avoid this problem, we can mark the variable in <code>main.cpp</code> as <code>static</code>. This limits its visibility to just that file, preventing it from colliding with value in <code>static.cpp</code>.</p> static.cpp<pre><code>int value = 20;\n</code></pre> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstatic int value = 10;\n\nint main() {\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Value: 10\n</code></pre> <p>Now both files can define a variable named <code>value</code> without conflict, because <code>value</code> in <code>main.cpp</code> is local to that translation unit thanks to the <code>static</code> keyword.</p> <p>If we actually want to share the variable from <code>static.cpp</code> with <code>main.cpp</code>, we need to remove <code>static</code> and use the extern keyword to declare the variable in <code>main.cpp</code>. This way, <code>main.cpp</code> refers to the definition from <code>static.cpp</code>, and there's no redefinition.</p> static.cpp<pre><code>int value = 20;\n</code></pre> main.cpp<pre><code>#include &lt;iostream&gt;\n\nextern int value;\n\nint main() {\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Value: 20\n</code></pre> <p>By using <code>extern</code>, we give <code>main.cpp</code> access to the variable defined in another file. This is known as external linkage, and it allows multiple files to share global variables while keeping a single definition in one place.</p>"},{"location":"08%20User%20Defined%20Types/#getters-and-setters","title":"Getters and Setters","text":"<p>In general, member variables should not be exposed directly outside of a class. This encapsulation helps prevent unintended modification or misuse. Instead, we provide getter and setter functions\u2014public member functions designed specifically for reading or writing private data.</p> <p>This approach allows us to maintain control over how internal state is accessed or changed. For example, setters can enforce validation rules before assigning values, adding a layer of protection and integrity to our data.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Person {\npublic:\n    std::string GetName() const {\n        return name_;\n    }\n\n    /*\n        Example of how a controlled assignment with validation might look:\n        if the name is too long, it gets truncated before being stored.\n    */\n    void SetName(const std::string&amp; name) {\n        if (name.length() &gt; 10) {\n            name_ = name.substr(0, 9);\n        } else {\n            name_ = name;\n        }\n    }\n\nprivate:\n    std::string name_;\n};\n\nint main() {\n    Person person;\n    person.SetName(\"Random Name\");\n\n    std::cout &lt;&lt; \"Person name: \" &lt;&lt; person.GetName() &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Person name: Random Na\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#constant-member-functions","title":"Constant Member Functions","text":"<p>In the previous section, we can see a <code>const</code> qualifier behind the class method declaration. When designing a class, it\u2019s important to distinguish between member functions that modify the object\u2019s internal state and those that don\u2019t. Functions that do not change the object should be explicitly marked as <code>const</code>.</p> <p>That is because doing so allows those functions to be safely called on constant instances of your class\u2014objects that have been declared immutable and are not supposed to be changed.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Player {\npublic:\n    Player(std::string name) \n        : name_(name) {\n    }\n\n    /*\n        Notice that it is marked with const at the end.\n        This tells the compiler that calling this method won\u2019t\n        change the internal state of the object. Because of that,\n        we can safely call it even when the player object is const.\n\n        Now, if we forget to add const to a method that doesn\u2019t actually\n        modify anything, we\u2019ll run into problems\u2014because the method can\u2019t\n        be called on const objects, even though it logically should be.\n    */\n\n    std::string GetName() const {\n        return name_;\n    }\n\n    void SetName(std::string name) {\n        name_ = name;\n    }\n\nprivate:\n    std::string name_;\n};\n\nint main() {\n    const Player player(\"Alex\");\n\n    std::cout &lt;&lt; player.GetName() &lt;&lt; std::endl;\n\n    // player.SetName(\"Chris\"); Error: can't call non-const method on const object\n}\n</code></pre> output<pre><code>Alex\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#constructors","title":"Constructors","text":"<p>A constructor is a special kind of method that runs automatically when an object of a class is created. Unlike regular methods, a constructor has no return type\u2014not even void\u2014and its name must match the class exactly.</p> <p>They are typically declared public so that objects can be created from outside the class. However, this isn\u2019t always the case\u2014when inheritance is involved, constructors might be protected or private, allowing them to be called only by derived classes or within the class itself. This is often used to enforce controlled object creation or to support specific inheritance patterns, which we\u2019ll explore later.</p> <p>The primary purpose of a constructor is to initialize member variables and set up the object so it\u2019s ready to use immediately. This makes code cleaner and more expressive by reducing the need for separate assignment statements after object creation.</p> <p>Constructors also play a critical role in how C++ manages memory and resources. They are involved not only in basic initialization but also in how objects are copied or moved, which can have performance implications.</p> <p>If you don\u2019t explicitly define a constructor, compiler will automatically generate a default one\u2014a no-argument constructor that initializes the object with default values. However, these defaults may not be meaningful unless you define them yourself. By writing your own constructors, you gain control over how your objects are initialized and what their initial state is. It\u2019s also important to note that the default constructor is only implicitly generated if no other constructors are defined. If you define any constructor, such as one that takes parameters, the compiler will not automatically generate a default constructor unless you explicitly tell it to.</p> <p>Note</p> <p>In these examples, we\u2019ll use <code>struct</code> instead of <code>class</code>. As mentioned earlier, in C++, the only difference between a <code>struct</code> and a <code>class</code> is that <code>struct</code> members are public by default, whereas <code>class</code> members are private.</p> <p>Using <code>struct</code> helps us keep the examples simple and avoids cluttering the code with access modifiers, getters and setters.</p> <p>However, in real-world programs, use <code>class</code> for better clarity, encapsulation, and adherence to object-oriented design practices.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Human {\n    std::string name_;\n\n    // Explicitly declare the default constructor\n    Human() = default;\n\n    // Constructor with parameters\n    Human(std::string name) {\n        name_ = name;\n    }\n\n    std::string GetName() {\n        return name_;\n    }\n};\n\nint main() {\n    Human default_human;   // Calls default constructor\n    Human human(\"Random\"); // Calls constructor with parameter\n\n    std::cout &lt;&lt; \"Default human name: \" &lt;&lt; default_human.GetName() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Named human: \" &lt;&lt; human.GetName() &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Default human name: empty string \nNamed human: Random\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#member-initializer-list","title":"Member Initializer List","text":"<p>In addition C++ provides a efficient way to write parameterized constructors using member initializer lists. This isn\u2019t just a stylistic choice\u2014it can significantly improve performance by initializing members in place, rather than first default-initializing them and then reassigning values inside the constructor body. In other words, member initializer lists construct the members directly with the given values, similar to how <code>emplace_back</code> works with vectors by constructing objects directly where they belong.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Vector2 {\npublic:\n    float x;\n    float y;\n\n    // Custom default constructor using member initializer list\n    Vector2()\n        : x(0.0f), y(0.0f) {\n    }\n\n    // Parameterized constructor using member initializer list\n    Vector2(float x, float y)\n        : x(x), y(y) {\n    }\n};\n\nint main() {\n    Vector2 vec2(10.5f, 20.8f);\n\n    std::cout &lt;&lt; \"x: \" &lt;&lt; vec2.x &lt;&lt; \" y: \" &lt;&lt; vec2.y &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>x: 10.5 y: 20.8\n</code></pre> <p>Using a member initializer list initializes members directly with the provided values. In contrast, assigning values inside the constructor body causes members to be default-initialized first and then assigned new values, which can be less efficient\u2014especially for complex types.</p> <p>Moreover, member initializer lists are required to initialize const members, reference members, and base classes, since these cannot be assigned inside the constructor body.</p> <p>Beyond the performance benefits, member initializer lists make the constructor\u2019s intent clearer and the code more concise by eliminating unnecessary syntax. For these reasons, using member initializer lists should be preferred whenever possible.</p>"},{"location":"08%20User%20Defined%20Types/#copy-constructor","title":"Copy Constructor","text":"<p>Data copying in programming is a lot like copying a chunk of text\u2014it duplicates the contents of one instance into another. For primitive types, copying is straightforward and typically has little impact on performance. But when it comes to user-defined types or containers like <code>std::vector</code> or <code>std::map</code>, copying can involve a lot more behind the scenes.</p> <p>These complex types may hold large amounts of data or even manage resources like memory or file handles. Copying such objects isn't just a matter of duplicating values\u2014it can be expensive in terms of performance and memory usage.</p> <p>That's why it's important to understand how copying works in C++, and what mechanisms are involved\u2014especially when your types grow in complexity.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double x;\n    double y;\n};\n\nint main() {\n    Vector2 a{\n        .x = 22.33,\n        .y = 55.66\n    };\n\n    // Value of 'a' was copied into 'b'\n    Vector2 b = a;\n\n    b.x = 10;\n\n    std::cout &lt;&lt; \"Coordinate x of object a: \" &lt;&lt; a.x &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Coordinate x of object a: 22.33\n</code></pre> <p>In the example above, <code>b</code> is a copy of <code>a</code>. It holds its own separate memory, so changes to <code>b.x</code> have no effect on <code>a.x</code>. This is value-based copying, and it's the default behavior in C++ for objects that aren\u2019t using pointers.</p> <p>However, when pointers are involved, copying behaves differently. Instead of copying the data being pointed to, only the address to the data is copied. That means both variables will point to the same memory location.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double x;\n    double y;\n};\n\nint main() {\n    Vector2* a = new Vector2{\n        .x = 22.33,\n        .y = 55.66\n    };\n\n    Vector2* b = a;\n\n    b-&gt;x = 10;\n\n    std::cout &lt;&lt; a-&gt;x;\n}\n</code></pre> <p>This kind of copying is handled by a special constructor called the copy constructor. C++ compiler automatically provides one for your class if you don\u2019t explicitly define it. The default copy constructor performs a member-wise copy\u2014copying each member field from one object to another.</p> <p>If you want to customize what happens when an object is copied (for example, to deeply copy a pointer or to log when copying happens), you can define your own.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double x;\n    double y;\n\n    Vector2() = default;\n\n    Vector2(float x, float y) \n        : x(x), y(y) {\n        std::cout &lt;&lt; \"Parameterized init constructor called!\" &lt;&lt; std::endl;\n    }\n\n    // Custom copy constructor signiture\n    Vector2(const Vector2&amp; other)\n        : x(other.x), y(other.y) {\n        std::cout &lt;&lt; \"Copy constructor called!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Vector2 a(22.33, 55.66); // This line will trigger the init constructor \n\n    Vector2 b = a;           // This line will trigger our copy constructor\n\n    b.x = 10.0;\n\n    std::cout &lt;&lt; \"a.x = \" &lt;&lt; a.x &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"b.x = \" &lt;&lt; b.x &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Parameterized init constructor called!\nCopy constructor called!\na.x = 22.33\nb.x = 10\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#copy-assignment-operator","title":"Copy Assignment Operator","text":"<p>The copy assignment operator is closely related to the copy constructor, but it comes into play after an object has already been constructed.</p> <p>Whereas the copy constructor creates a new object from an existing one, the copy assignment operator replaces the contents of an already existing object with those from another.</p> <p>C++ provides a default version of this operator if you don't write your own. Like the default copy constructor, it performs a member-wise copy of each field.</p> <p>But if your type manages resources manually, or you just want to log or tweak the behavior, you can define your own.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double x;\n    double y;\n\n    Vector2() = default;\n\n    Vector2(double x, double y)\n        : x(x), y(y) {\n        std::cout &lt;&lt; \"Init constructor called!\" &lt;&lt; std::endl;\n    }\n\n    Vector2(const Vector2&amp; other)\n        : x(other.x), y(other.y) {\n        std::cout &lt;&lt; \"Copy constructor called!\" &lt;&lt; std::endl;\n    }\n\n    // Custom copy assignment operator\n    Vector2&amp; operator=(const Vector2&amp; other) {\n        std::cout &lt;&lt; \"Copy assignment operator called!\" &lt;&lt; std::endl;\n\n        /*\n            Self-assignment check\n\n            Without this check, you might accidentally overwrite\n            your own data unnecessarily\u2014or worse, in more complex types,\n            cause memory corruption.\n        */\n        if (this == &amp;other)\n            return *this;\n\n        x = other.x;\n        y = other.y;\n\n        return *this;\n    }\n};\n\nint main() {\n    Vector2 a(22.33, 55.66);\n    Vector2 b;\n\n    b = a; // This triggers the copy assignment operator\n    b.x = 10.0;\n\n    std::cout &lt;&lt; \"a.x = \" &lt;&lt; a.x &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"b.x = \" &lt;&lt; b.x &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Init constructor called!\nCopy assignment operator called!\na.x = 22.33\nb.x = 10\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#move-constructor","title":"Move Constructor","text":"<p>Info</p> <p>We\u2019ve already covered move semantics in detail in earlier chapters. Here, we focus on how to implement a move constructor for your custom types, enabling them to support move semantics properly.</p> <p>Earlier in the book, we introduced move semantics\u2014a technique where an object\u2019s resources are transferred instead of copied. Now, let's see how this idea applies when working with classes and structs, especially when you're managing resources like heap-allocated memory.</p> <p>Moving in programming is like reusing an object\u2019s existing resources instead of duplicating them. While copying creates a new version of the data, moving transfers ownership from one object to another. This is especially useful when working with large objects, heap-allocated data, or temporary values, where performance matters.</p> <p>Warning</p> <p>After moving from an object, that object remains in a valid but unspecified state. In practice, this usually means its internal pointers are null or empty, but you shouldn't make assumptions beyond that unless you reset or reassign the object yourself.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string a = \"Hello World!\";\n\n    std::string b = std::move(a);\n\n    std::cout &lt;&lt; b &lt;&lt; std::endl;\n\n    if (a.empty())\n        std::cout &lt;&lt; \"a has been moved from\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Hello World!\na has been moved from\n</code></pre> <p>In this example, <code>b</code> takes over the internal resources that were originally held by <code>a</code>. After the move, <code>a</code> is left in a valid but unspecified state. While many implementations leave moved-from strings empty, the C++ standard only guarantees that the object can still be safely destroyed or assigned to. You shouldn't rely on its contents unless you explicitly assign a new value.</p> <p>This is one of the main reasons move constructors are so useful\u2014they allow efficient transfer of ownership without unnecessary copying, while keeping resource management safe. But they're not really needed in classes that don't manage resources manually, such as those that only contain primitive types or rely entirely on STL containers like <code>std::vector</code> or <code>std::string</code>.</p> <p>In those cases, the default move constructor generated by the compiler is usually sufficient, because all the member types already know how to move themselves efficiently. You only need to define a custom move constructor when your class holds raw resources\u2014like heap memory, file handles, or pointers\u2014that require careful cleanup and transfer logic.</p> <p>When your class manages raw resources\u2014like heap memory\u2014you'll often want to take control of how those resources are transferred between objects. In such cases, defining a custom move constructor lets you explicitly steal ownership and prevent expensive deep copies.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double* data;\n\n    Vector2(double x, double y) {\n        data = new double[2]{x, y};\n    }\n\n    // Move constructor signiture\n    Vector2(Vector2&amp;&amp; other) {\n        std::cout &lt;&lt; \"Move constructor called!\" &lt;&lt; std::endl;\n        data = other.data;\n        other.data = nullptr; // Mark the source as \"moved-from\"\n    }\n\n    void print() const {\n        if (data)\n            std::cout &lt;&lt; \"x: \" &lt;&lt; data[0] &lt;&lt; \" y: \" &lt;&lt; data[1] &lt;&lt; std::endl;\n        else\n            std::cout &lt;&lt; \"Vector2 is in moved-from state\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Vector2 a(22.33f, 55.66f);\n\n    Vector2 b = std::move(a);\n\n    a.print();\n    b.print();\n}\n</code></pre> output<pre><code>Move constructor called!\nVector2 is in moved-from state\nx: 22.33 y: 55.66\n</code></pre> <p>This pattern is essential whenever your class directly manages memory or other system resources. It gives you precise control over how resources are moved, helping ensure both correctness and performance.</p>"},{"location":"08%20User%20Defined%20Types/#move-assignment-operator","title":"Move Assignment Operator","text":"<p>Just like how the copy assignment operator complements the copy constructor, the move assignment operator is the companion to the move constructor.</p> <p>Where the move constructor initializes a new object by stealing resources, the move assignment operator replaces the contents of an already existing object by taking ownership of another object\u2019s resources.</p> <p>This is especially important when working with resource-owning types, like classes that manage dynamic memory or handles.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Vector2 {\n    double* data;\n\n    Vector2(double x, double y) {\n        data = new double[2]{x, y};\n    }\n\n    Vector2(Vector2&amp;&amp; other) {\n        std::cout &lt;&lt; \"Move constructor called!\" &lt;&lt; std::endl;\n        data = other.data;\n        other.data = nullptr;\n    }\n\n    // Move assignment operator\n    Vector2&amp; operator=(Vector2&amp;&amp; other) {\n        std::cout &lt;&lt; \"Move assignment operator called!\" &lt;&lt; std::endl;\n\n        // Self-assignment check\n        if (this == &amp;other)\n            return *this;\n\n        // Clean up existing resource\n        delete[] data;\n\n        // Steal the resource\n        data = other.data;\n        other.data = nullptr;\n\n        return *this;\n    }\n\n    void print() const {\n        if (data)\n            std::cout &lt;&lt; \"x: \" &lt;&lt; data[0] &lt;&lt; \" y: \" &lt;&lt; data[1] &lt;&lt; std::endl;\n        else\n            std::cout &lt;&lt; \"Vector2 is in moved-from state\" &lt;&lt; std::endl;\n    }\n\n    ~Vector2() {\n        delete[] data;\n    }\n};\n\nint main() {\n    Vector2 a(11.11f, 22.22f);\n    Vector2 b(0.0f, 0.0f);\n\n    b = std::move(a); // Triggers move assignment\n\n    a.print();\n    b.print();\n}\n</code></pre> <p>Tip</p> <p>Just like with the move constructor, if your type doesn't manage raw resources manually, you probably don\u2019t need to write a custom move assignment operator. The compiler-generated one is often sufficient.</p> <p>Together, the move constructor and move assignment operator complete your class's ability to participate in move semantics safely and efficiently.</p>"},{"location":"08%20User%20Defined%20Types/#explicit-constructor","title":"Explicit\u00a0Constructor","text":"<p>By default, if a constructor takes a single argument (or a set of arguments that could be matched in a single call), C++ allows implicit conversions from those argument types to the class type. This means the compiler might automatically create an object\u2014even if you didn\u2019t explicitly write a constructor call\u2014which can sometimes lead to unintended or surprising behavior.</p> <p>To prevent this, you can use the <code>explicit</code> keyword to disable automatic conversions. This makes your code safer and more predictable, especially when conversions shouldn\u2019t happen silently.</p> <p>An explicit constructor can only be called when written directly in code. The compiler won\u2019t use it for implicit type conversions.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Point {\n    int x;\n    int y;\n\n    Point(int x, int y)\n        : x(x), y(y) {    \n    }\n};\n\nvoid PrintPoint(Point p) {\n    std::cout &lt;&lt; \"x: \" &lt;&lt; p.x &lt;&lt; \" y: \" &lt;&lt; p.y &lt;&lt; std::endl;\n}\n\nint main() {\n    /*\n        Implicit conversion: allowed because\n        the constructor is not marked explicit\n    */\n    PrintPoint({5, 10});\n}\n</code></pre> output<pre><code>x: 5 y: 10\n</code></pre> <p>In this example, the compiler automatically creates a temporary <code>Point</code> from the <code>{5, 10}</code> initializer. That\u2019s possible because the constructor accepts two <code>int</code> values, and it isn\u2019t marked <code>explicit</code>.</p> <p>However, this might not always be desirable\u2014especially if you want to avoid accidental conversions. To make construction explicit-only, mark the constructor with the <code>explicit</code> keyword.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Point {\n    int x;\n    int y;\n\n    explicit Point(int x, int y)\n        : x(x), y(y) {\n    }\n};\n\nvoid PrintPoint(Point p) {\n    std::cout &lt;&lt; \"x: \" &lt;&lt; p.x &lt;&lt; \" y: \" &lt;&lt; p.y &lt;&lt; std::endl;\n}\n\nint main() {\n    /*\n        Error! Cannot implicitly convert {5, 10} to a Point\n\n        printPoint({5, 10});\n    */\n\n    Point p(5, 10); // Explicit construction\n    PrintPoint(p);  // Passing the object explicitly\n}\n</code></pre> output<pre><code>x: 5 y: 10\n</code></pre> <p>With explicit, the compiler no longer allows the conversion from <code>{5, 10}</code> to a <code>Point</code> automatically. You must create the object yourself before passing it into the function\u2014making your intention clear and preventing accidental misuse.</p>"},{"location":"08%20User%20Defined%20Types/#rule-of-zero-and-five","title":"Rule of Zero and Five","text":"<p>In C++, the Rule of Five is an important guideline when you're working with classes that manage resources manually\u2014like dynamic memory, file handles, or network sockets. If you define any one of the following special member functions, you should usually define all five to ensure consistent, predictable behavior. This is the Rule of Five.</p> Special Member Function When You Might Need It Destructor When your class manages resources like heap memory, file handles, or network sockets that must be manually released. Copy Constructor When you need to define how your object is copied (deep vs. shallow copy). Copy Assignment Operator When your object needs proper behavior during copy assignment (e.g., <code>a = b</code>). Move Constructor When you want to efficiently transfer resources from temporaries (e.g., <code>MyClass a = std::move(b)</code>). Move Assignment Operator When your object should efficiently take over resources during assignment from an rvalue (e.g., <code>a = std::move(b)</code>). <p>However, if your class doesn't manage resources directly\u2014and instead relies only on built-in types or STL containers like <code>std::vector</code> or <code>std::string</code>\u2014then you don't need to define any of these functions yourself. This is known as the Rule of Zero: let the compiler generate the special functions for you automatically.</p>"},{"location":"08%20User%20Defined%20Types/#destructors","title":"Destructors","text":"<p>Info</p> <p>This section is fairly short, as the core concept is straightforward. However, we\u2019ll return to the topic later\u2014particularly when we cover inheritance\u2014where destructors become a bit more important.</p> <p>Similar to a constructor, a destructor is a special method, but it's called automatically when an object goes out of scope or is explicitly deleted. Its job is to clean up\u2014releasing resources the object may have acquired during its lifetime, such as dynamic memory, file handles, or network connections.</p> <p>Just like constructors, destructors have a unique syntax:</p> <ul> <li>They have no return type (not even void).</li> <li>Their name matches the class, but with a tilde <code>~</code> prefix.</li> <li>A class can have only one destructor, and it cannot take any parameters.</li> </ul> <p>Destructors are declared public in most cases, especially when objects are created on the stack or dynamically via new. However, in more advanced designs (like factories or polymorphic hierarchies), destructors may be protected or virtual. We\u2019ll explore those patterns later.</p> <p>The most common use case for a destructor is to free dynamically allocated memory or close resources.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct FileHandle {\n    FileHandle() {\n        std::cout &lt;&lt; \"File opened\" &lt;&lt; std::endl;\n    }\n\n    ~FileHandle() {\n        std::cout &lt;&lt; \"File closed\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    {\n        FileHandle file;\n        std::cout &lt;&lt; \"Working with file...\" &lt;&lt; std::endl;\n    } // file goes out of scope here \u2014 destructor is called automatically\n\n    std::cout &lt;&lt; \"Program ending\" &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>File opened\nWorking with file...\nFile closed\nProgram ending\n</code></pre> <p>Note</p> <p>If your class acquires resources using <code>new</code>, <code>malloc</code>, or similar raw APIs, you should always define a destructor to release them. For polymorphic classes\u2014those meant to be used via base pointers\u2014you must make the destructor virtual to ensure the correct one is called. We\u2019ll cover that in detail when we get to inheritance.</p>"},{"location":"08%20User%20Defined%20Types/#arrow-operator","title":"Arrow Operator","text":"<p>Up until now, we've been using the dot operator to access members of structs and classes. But that only works when we have a direct instance of the object.</p> <p>When we have a pointer to an object, things change. We can\u2019t use the dot operator anymore \u2014 because the pointer itself doesn\u2019t have those members. Instead, we use the arrow operator (<code>-&gt;</code>) to access them through the pointer.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nstruct Point {\n    double x;\n    double y;\n\n    void Print() const {\n        std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \" y: \" &lt;&lt; y &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Point* ptr_point = new Point{41.32, 22.87};\n\n    /*\n        This won't work because ptr_point is a pointer, not an object:\n\n        ptr_point.Print();\n    */\n\n    // But this will:\n    ptr_point-&gt;Print();\n}\n</code></pre> output<pre><code>x: 41.32 y: 22.87\n</code></pre> <p>Note</p> <p>If you're thinking, \"Wait, couldn't we just dereference the pointer and call the method like this: <code>(*ptr_point).Print()</code>?\" \u2014 you're absolutely right. However, that syntax is a bit messy to read. That\u2019s exactly why the arrow operator exists: it's just a cleaner, more readable shortcut for <code>(*pointer).member</code>.</p> <p>The arrow operator can even be used in clever low-level tricks \u2014 like calculating the byte offset of a struct member from the beginning of the structure.</p> <p>Info</p> <p>This section covers advanced memory management concepts, including how data is organized in memory and how to optimize it. This knowledge is generally not required unless you are working in performance-critical or low-level systems.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\nstruct Point {\n    double x;\n    double y;\n    double z;\n};\n\nint main() {\n    // Use the arrow operator on a null pointer to compute member offsets\n    uintptr_t offset_x = (uintptr_t)&amp;((Point*)nullptr)-&gt;x;\n    uintptr_t offset_y = (uintptr_t)&amp;((Point*)nullptr)-&gt;y;\n    uintptr_t offset_z = (uintptr_t)&amp;((Point*)nullptr)-&gt;z;\n\n    /*\n        We could technically use a regular int here, but using uintptr_t is more correct,\n        as it is specifically designed to safely store pointer values as integers.\n    */\n\n    std::cout &lt;&lt; \"Byte Offset of x: \" &lt;&lt; offset_x &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Byte Offset of y: \" &lt;&lt; offset_y &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Byte Offset of z: \" &lt;&lt; offset_z &lt;&lt; std::endl;\n}\n</code></pre> output<pre><code>Byte Offset of x: 0\nByte Offset of y: 8\nByte Offset of z: 16\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#current-instance-pointer","title":"Current Instance Pointer","text":"<p>In C++, we have access to a special keyword called <code>this</code>. It is only available inside member functions, and it points to the current instance of the class or object the method is acting on. While using <code>this</code> is often optional, it becomes especially useful when there is a name clash\u2014for example, between constructor parameters and member variables.</p> main.cpp<pre><code>struct Point {\n    double x;\n    double y;\n    double z;\n\n    // This works fine: the member variables are initialized using an initializer list\n    Point(double x, double y, double z) \n        : x(x), y(y), z(z) {\n    }\n\n    /* \n        This will not work as expected:\n        The assignments just assign the parameters to themselves,\n        leaving the member variables unchanged.\n\n        Point(double x, double y, double z) {\n            x = x;\n            y = y;\n            z = z;\n        }\n    */\n};\n</code></pre> <p>To resolve this ambiguity, we can use the <code>this</code> pointer to explicitly refer to the member variables. Since <code>this</code> is a pointer, we access members using the arrow operator.</p> example<pre><code>struct Point {\n    double x;\n    double y;\n    double z;\n\n    Point(double x, double y, double z) {\n        this-&gt;x = x;\n        this-&gt;y = y;\n        this-&gt;z = z;\n    }\n};\n</code></pre> <p>Note</p> <p>Remember that in many C++ style guides\u2014like Google\u2019s or others\u2014it\u2019s common to suffix member variables with <code>_</code> (e.g., <code>name_</code>) or prefix them with <code>m_</code> (e.g., <code>m_name</code>). This naming convention helps avoid name clashes entirely and improves readability without needing to use <code>this-&gt;</code>.</p>"},{"location":"08%20User%20Defined%20Types/#friend-functions","title":"Friend Functions","text":"<p>In C++, we can grant non-member functions access to a class\u2019s private and protected members by declaring them as friend. Although these functions are not part of the class itself, they are treated as trusted and can interact with the internal state of the class directly.</p> <p>This approach is useful when a function needs to work closely with a class\u2014such as when overloading operators\u2014but doesn\u2019t logically belong as a member, helping keep responsibilities separated while still allowing close access.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Box {\nprivate:\n    double edge_length_;\n\npublic:\n    Box(double edge_length_)\n        : edge_length_(edge_length_) {\n    }\n\n    // Declare a friend function inside public access specifier\n    friend void PrintEdgeLength(const Box&amp; box);\n};\n\n// Define friend function outside the class\nvoid PrintEdgeLength(const Box&amp; box) {\n    std::cout &lt;&lt; \"Edge length: \" &lt;&lt; box.edge_length_ &lt;&lt; std::endl;\n}\n\nint main() {\n    Box box(42.5);\n    PrintEdgeLength(box);  // Can access private width directly\n}\n</code></pre> output<pre><code>Edge length: 42.5\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#inheritance","title":"Inheritance","text":"<p>In more complex programs\u2014especially games\u2014we often need to structure our code in a way that\u2019s both reusable and maintainable. Imagine you have a <code>Player</code> class and an <code>Enemy</code> class. At first glance, they may seem different, but both share several common traits: they might have a <code>name</code>, <code>hitpoints</code>, a <code>level</code>, or a <code>position</code> in the game world.</p> <p>Rather than duplicating those shared members in every class, we can extract them into a more general-purpose class\u2014say, <code>Entity</code>. Both <code>Player</code> and <code>Enemy</code> can then be built on top of <code>Entity</code>, inheriting its functionality and enriching it with their own unique behavior. This mechanism is called inheritance.</p> <p>Inheritance lets us write cleaner, more modular code. It allows us to group shared functionality in one place and extend or override it as needed in specialized types.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Entity {\nprotected:\n    std::string name_;\n    double hitpoints_;\n    unsigned int level_;\n\npublic:\n    /*\n        'name' is passed by value (copied into this constructor),\n        so to avoid copying it again into name_, we move it instead.\n\n        This technique works with all STL containers\n        like std::vector, std::map as well as std::string.\n        Just remember: after moving a variable, \n        you should not use it again unless you reassign a valid value.\n\n        In many cases this optimization isn\u2019t strictly necessary,\n        but it serves as a good example of where move semantics\u2014\n        which we introduced earlier\u2014can be applied in real code.\n    */\n    Entity(std::string name, double hitpoints, unsigned int level)\n        : name_(std::move(name)), hitpoints_(hitpoints), level_(level) {\n    }\n\n    void PrintInfo() const {\n        std::cout &lt;&lt; \"name: \" &lt;&lt; name_ &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"hitpoints: \" &lt;&lt; hitpoints_ &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"level: \" &lt;&lt; level_ &lt;&lt; std::endl;\n    }\n};\n\n\n/*\n    You will almost always want to use the public inheritance\n    access specifier. See the detailed table below for why\n    that\u2019s usually the right choice.\n*/\nstruct Player : public Entity {\n    /*\n        We're using the constructor of the parent class (Entity),\n        which is one of the main benefits of inheritance:\n        reusing shared initialization logic.\n    */\n    Player(std::string name)\n        : Entity(std::move(name), 100.0, 1) {\n    }\n\n    void Attack() {\n        std::cout &lt;&lt; name_ &lt;&lt; \" attacks with a sword!\" &lt;&lt; std::endl;\n    }\n};\n\nstruct Enemy : public Entity {\n    Enemy(std::string name, double hp, unsigned int lvl)\n        : Entity(std::move(name), hp, lvl) {\n    }\n\n    void Taunt() {\n        std::cout &lt;&lt; name_ &lt;&lt; \" growls!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Player player(\"Archer\");\n    Enemy entity(\"Goblin\", 50.0, 2);\n\n    std::cout &lt;&lt; \"Player info\" &lt;&lt; std::endl;\n    player.PrintInfo();\n    player.Attack();\n\n    std::cout &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"Enemy info\" &lt;&lt; std::endl;\n    entity.PrintInfo();\n    entity.Taunt();\n}\n</code></pre> output<pre><code>Player info\nname: Archer\nhitpoints: 100\nlevel: 1\nArcher attacks with a sword!\n\nEnemy info\nname: Goblin\nhitpoints: 50\nlevel: 2\nGoblin growls!\n</code></pre> Inheritance Type <code>public</code> Members in Base <code>protected</code> Members in Base <code>private</code> Members in Base <code>public</code> Remain <code>public</code> in derived Remain <code>protected</code> in derived Not accessible <code>protected</code> Become <code>protected</code> Remain <code>protected</code> Not accessible <code>private</code> Become <code>private</code> Become <code>private</code> Not accessible"},{"location":"08%20User%20Defined%20Types/#polymorphism","title":"Polymorphism","text":"<p>Polymorphism refers to the ability of different classes to respond to the same function call in their own way. Unlike regular function overloading (where multiple functions share a name but differ in parameters), polymorphism usually involves methods of a base class that are overridden in derived classes to provide specialized behavior.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Entity {\npublic:\n    virtual void Speak() { // Must be marked virtual\n        std::cout &lt;&lt; \"Entity speaks.\" &lt;&lt; std::endl;\n    }\n};\n\nclass Player : public Entity {\npublic:\n    void Speak() override {\n        std::cout &lt;&lt; \"Player speaks.\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Entity* entity = new Player(); // Base class pointer to derived object\n    entity-&gt;Speak();               // Calls Player::Speak() thanks to polymorphism\n\n    delete entity;\n}\n</code></pre> output<pre><code>Player speaks.\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#virtual-methods","title":"Virtual Methods","text":"<p>In the previous section, we used the virtual keyword to enable polymorphism. Let\u2019s now take a moment to focus on what virtual methods actually are.</p> <p>A virtual method is a member function that can be overridden in a derived class. When you call it through a base class pointer or reference, the version that's selected is based on the actual type of the object \u2014 not the type of the pointer or reference.</p> <p>This mechanism is called dynamic dispatch, and it only happens when you're using a base class pointer or reference and the method is marked as virtual.</p> Keyword Purpose Where it's used Notes <code>virtual</code> Marks a method as overridable in derived classes In base class declarations Enables runtime polymorphism. <code>override</code> Indicates that a method intentionally overrides a base virtual method In derived class definitions Helps catch bugs caused by mismatched method signatures. <code>final</code> Prevents a virtual method from being overridden further In derived class definitions Can also be used to seal entire classes: <code>class MyFinalClass final {}</code> <p>Tip</p> <p>Always use override when overriding virtual methods. It makes your intent clear and helps the compiler catch mistakes.</p> example<pre><code>class Entity {\npublic:\n    virtual void Speak() {\n        std::cout &lt;&lt; \"Entity speaks.\" &lt;&lt; std::endl;\n    }\n};\n\nclass Player : public Entity {\npublic:\n    void Speak() override final { // overrides and seals the method\n        std::cout &lt;&lt; \"Player speaks.\" &lt;&lt; std::endl;\n    }\n};\n\n/*\n    This would cause a compile error:\n\n    class Boss : public Player {\n        void Speak() override { ... } // Not allowed as it was marked as final\n    };\n*/\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#interfaces","title":"Interfaces","text":"<p>Now that we've seen how virtual methods work, let's talk about a special case: interfaces.</p> <p>In C++, an interface is typically just a class that contains only pure virtual functions \u2014 methods that must be implemented by any derived class. They have no body and are declared using <code>= 0</code>.</p> <p>Interfaces are especially useful for enforcing consistent behavior across many unrelated types \u2014 for example, in plugins, simulation systems, or game objects. You can build systems that interact with any class that implements the interface, without caring what kind of object it is.</p> <p>You can think of an interface as an abstract base class made up entirely of pure virtual methods. And yes \u2014 in C++, a class can inherit from multiple interfaces.</p> <p>Note</p> <p>A class that contains at least one pure virtual method becomes an abstract class, and it cannot be instantiated directly.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\nclass Updatable {\npublic:\n    virtual void Update() = 0; // Pure virtual function\n};\n\nclass Player : public Updatable {\npublic:\n    void Update() override {\n        std::cout &lt;&lt; \"Player updates.\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Player player;\n    player.Update(); // Calls Player's implementation\n}\n</code></pre> output<pre><code>Player updates.\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#singletons","title":"Singletons","text":"<p>Sometimes, we only ever want a single instance of a class to exist across an entire program. Maybe it's a logger, a configuration manager, or a global game state\u2014whatever the case, the Singleton design pattern is exactly for this pupose. Instead of letting code freely create new objects, a Singleton class controls its own instantiation and ensures only one object is ever made. The typical approach involves a static method that hands out a reference to the sole instance, creating it the first time it's needed.</p> example<pre><code>class Game {\nprivate:\n    Game() {\n    }\n\npublic:\n    Game(const Game&amp;) = delete;\n    Game&amp; operator=(const Game&amp;) = delete;\n    Game(Game&amp;&amp;) = delete;\n    Game&amp; operator=(Game&amp;&amp;) = delete;\n\n    static Game&amp; Instance() {\n        static Game instance;\n        return instance;\n    }\n\n    void Run() {\n        // Game loop would go here\n    }\n};\n\nint main() {\n    Game::Instance().Run(); // Only one Game ever exists\n}\n</code></pre>"},{"location":"08%20User%20Defined%20Types/#questions","title":"Questions","text":""},{"location":"08%20User%20Defined%20Types/#exercises","title":"Exercises","text":"task 1answer <p>Define a <code>Book</code> struct with the following fields: <code>title</code>, <code>author</code>, <code>year</code>, and <code>price</code>. Then, write a function that takes a <code>Book</code> as a parameter and prints its contents in a human-readable format.</p> <pre><code>\n</code></pre> task 2answer <p>Create a Rectangle class that stores width and height.</p> <ul> <li>Provide a constructor.</li> <li>Add getter and setter methods for both members.</li> <li>Add a method area() that returns the area of the rectangle.</li> </ul> <pre><code>\n</code></pre> task 3answer <p>Define a class Logger that writes custom user defined messages into terminal when:</p> <ul> <li>An object is constructed</li> <li>An object is destructed</li> </ul> <p>Create several <code>Logger</code> instances inside a <code>CreateLoggers</code> function and observe the output order.</p> <pre><code>\n</code></pre>"},{"location":"09%20Error%20Handling/","title":"09 Error Handling","text":"<p>\ud83d\udea7 This chapter is under construction... \ud83d\udea7</p>"},{"location":"10%20Macros/","title":"10 Macros","text":"<p>In the introductory chapter, we took a first look at how a C++ program comes together. One important detail we touched on was that the compiler is not the first tool that sees your code. Before any C++ syntax is parsed or type-checked, your source files pass through an earlier stage of the build pipeline: the preprocessor.</p> <p>This fact matters because, in C++, macros are provided entirely by the preprocessor through a set of special directives. Rather than operating on C++ constructs, macros work by rewriting source code before compilation begins. In practice, macro expansion is a purely textual transformation\u2014closer to an automated find-and-replace than to actual C++ logic.</p> <p>Because macros operate at the textual level, they come with significant limitations. They have no awareness of types, ignore scope, and can erase symbol names before the compiler ever sees them. As a result, macros are often difficult to debug and can obscure what the code is really doing.</p> <p>Warning</p> <p>In modern C++ macros should be avoided. As they cause the code you write to differ from the code the compiler actually sees. This can introduce subtle and unexpected behavior, especially since macros have global scope. Language features such as <code>constexpr</code>, strongly typed enums, and inline functions provide the same functionality with proper type safety, scoping, and far better diagnostics. Object-like macros today remain mainly for legacy code and build-time configuration.</p> <p>This chapter therefore serves as a bridge into templates and metaprogramming, showing how C++ historically approached certain problems. By studying macros first, we gain useful context for understanding why modern techniques exist and how they improve safety, readability, and maintainability.</p>"},{"location":"10%20Macros/#object-like-macros","title":"Object Like Macros","text":"<p>The simplest form of a macro is the object-like macro. Despite the name, it does not define an object in the C++ sense. Instead, it defines a textual substitution rule.</p> example<pre><code>#define SOME_CONSTANT 10\n</code></pre> <p>Every time the preprocessor encounters the identifier <code>SOME_CONSTANT</code>, it replaces it with the literal text <code>10</code> before the compiler ever sees the code. After preprocessing, the compiler has no knowledge that <code>SOME_CONSTANT</code> ever existed\u2014it only sees the value <code>10</code>.</p> main.cpp<pre><code>#define SOME_CONSTANT 10\n\nint main()\n{\n    int value = SOME_CONSTANT;\n}\n</code></pre> main.i<pre><code>int main()\n{\n    int value = 10;\n}\n</code></pre>"},{"location":"10%20Macros/#function-like-macros","title":"Function Like Macros","text":"<p>Function-like macros resemble functions in syntax, but they are not functions in the usual programming sense. Like all macros, they are handled entirely by the preprocessor and exist purely as text-substitution rules.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#define SQUARE(x) x * x\n\nint main()\n{\n    int result = SQUARE(5);\n\n    std::cout &lt;&lt; result;\n}\n</code></pre> main.i<pre><code>/* ... entirety of iostream header file ... */\n\nint main()\n{\n    int result = 5 * 5\n\n    std::cout &lt;&lt; result;\n}\n</code></pre> output<pre><code>25\n</code></pre> <p>At a glance, this appears to define a function that squares a value. In reality, it defines a rule that replaces every occurrence of <code>SQUARE(something)</code> with the literal text <code>something * something</code>. So far, this seems to work exactly as intended. The problems start to appear as soon as we pass anything more complex than a single literal.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#define SQUARE(x) x * x\n\nint main()\n{\n    double result = 72 / SQUARE(5 + 1);\n\n    std::cout &lt;&lt; result;\n}\n</code></pre> main.i<pre><code>/* ... entirety of iostream header file ... */\n\nint main()\n{\n    double result = 72 / 5 + 1 * 5 + 1\n\n    std::cout &lt;&lt; result;\n}\n</code></pre> output<pre><code>20\n</code></pre> <p>This result is almost certainly not what was intended. The issue arises because the macro does not insert any parentheses. The preprocessor performs a blind textual replacement, and normal operator precedence rules then apply to the expanded code.</p> <p>A common attempt to fix and a rule of thumb is to parenthesize every macro parameter and expression.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#define SQUARE(x) ((x) * (x))\n\nint main()\n{\n    double result = 72 / SQUARE(5 + 1);\n\n    std::cout &lt;&lt; result;\n}\n</code></pre> main.i<pre><code>/* ... entirety of iostream header file ... */\n\nint main()\n{\n    double result = 72 / ((5 + 1) * (5 + 1))\n\n    std::cout &lt;&lt; result;\n}\n</code></pre> output<pre><code>2\n</code></pre> <p>Unfortunately, some problems cannot be fixed with parentheses.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#define SQUARE(x) ((x) * (x))\n\nint main()\n{\n    int n = 5;\n    double result = SQUARE(n++);\n\n    std::cout &lt;&lt; \"n: \" &lt;&lt; n &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"result: \" &lt;&lt; result;\n}\n</code></pre> main.i<pre><code>/* ... entirety of iostream header file ... */\n\nint main()\n{\n    int n = 5;\n    double result = ((n++) * (n++))\n\n    std::cout &lt;&lt; \"n: \" &lt;&lt; n &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"result: \" &lt;&lt; result;\n}\n</code></pre> output<pre><code>n: 7\nresult: 30\n</code></pre> <p>The increment operation runs twice, completely breaking the intended logic. Depending on the C++ standard and evaluation rules, this may also result in undefined behavior.</p> <p>Note</p> <p>This example highlights a fundamental limitation of macros: they do not evaluate expressions or preserve intent. They simply duplicate text. Macros were not designed for performing mathematical operations; they exist primarily to manipulate code at the textual level.</p>"},{"location":"10%20Macros/#stringizing-operator","title":"Stringizing Operator","text":"<p>The stringizing operator allows a macro parameter to be converted into a string literal. It is written as a single <code>#</code> placed directly in front of a macro parameter.</p> <p>When the preprocessor expands the macro, the argument passed to that parameter is wrapped in double quotes and turned into a C-style string.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#define PRINT_VAR(x) std::cout &lt;&lt; \"Var name: \" &lt;&lt; #x &lt;&lt; '\\n'\n\nint main()\n{\n    int value = 10;\n    PRINT_VAR(value);\n}\n</code></pre> main.i<pre><code>/* ... entirety of iostream header file ... */\n\nint main()\n{\n    int value = 10;\n    std::cout &lt;&lt; \"Var name: \" &lt;&lt; \"value\" &lt;&lt; '\\n';\n}\n</code></pre> output<pre><code>Var name: value\n</code></pre> <p>This can be useful for logging, debugging, or diagnostic output where you want to display the name of a variable rather than its value. As with all macros, this happens purely at the textual level\u2014the compiler never sees the original macro parameter.</p>"},{"location":"10%20Macros/#token-concatenation-operator","title":"Token Concatenation Operator","text":"<p>The token concatenation operator\u2014written as <code>##</code>\u2014allows two tokens in a macro to be joined together into a single token during macro expansion.</p> <p>This is useful in situations where code follows strict naming conventions and you want to generate identifiers programmatically rather than writing repetitive boilerplate by hand.</p> example.cpp<pre><code>#define COMMAND_HANDLER(name) void File##name()\n\nCOMMAND_HANDLER(Open)\nCOMMAND_HANDLER(Close)\n</code></pre> example.i<pre><code>void FileOpen();\nvoid FileClose();\n</code></pre> <p>The preprocessor treats File and Open as separate tokens, then pastes them together into a single identifier. The same rule applies to any tokens that can legally be combined to form a valid identifier.</p>"},{"location":"10%20Macros/#predefined-macros","title":"Predefined Macros","text":"<p>In addition to user-defined macros, the compiler environment automatically provides a set of predefined ones. These macros are always available and expand to information about the current source file, compilation context, or language version.</p> <p>Because they are supplied by the compiler or preprocessing environment, predefined macros are particularly useful.</p> Macro Description <code>__FILE__</code> Expands to the current source file name. <code>__LINE__</code> Expands to the current line number in the source file. <code>__DATE__</code> Expands to the compilation date as a string literal (e.g., <code>\"Jan  6 2026\"</code>). <code>__TIME__</code> Expands to the compilation time as a string literal (e.g., <code>\"14:30:00\"</code>). <code>__func__</code> A compiler-provided identifier that evaluates to the name of the current function (not a macro). <p>For example, <code>__FILE__</code> and <code>__LINE__</code> are often combined to produce detailed error or log messages that point directly to the source location where an issue occurred. <code>__func__</code> can provide additional context when tracing execution paths or debugging complex code.</p> <p>Note</p> <p>Not all predefined macros are standardized. Some are compiler-specific and should be used with care when writing portable code.</p>"},{"location":"10%20Macros/#conditional-compilation","title":"Conditional Compilation","text":"<p>The preprocessor can include or exclude sections of code based on whether certain macros are defined. This is called conditional compilation, and it\u2019s controlled using directives such as those shown in the table below.</p> Directive Purpose <code>#ifdef</code> Checks whether a macro is defined. <code>#ifndef</code> Checks whether a macro is not defined. <code>#endif</code> Marks the end of a conditional block. main.cpp<pre><code>#include &lt;iostream&gt;\n\n#define DEBUG_MODE\n\nint main() {\n    #ifdef DEBUG_MODE\n        std::cout &lt;&lt; \"Debug mode is enabled.\\n\";\n    #endif\n\n    #ifndef RELEASE_MODE\n        std::cout &lt;&lt; \"Release mode is not defined.\\n\";\n    #endif\n}\n</code></pre> main.i<pre><code>/* ... entirety of iostream header file ... */\n\nint main() {\n    std::cout &lt;&lt; \"Debug mode is enabled.\\n\";\n    std::cout &lt;&lt; \"Release mode is not defined.\\n\";\n}\n</code></pre> main<pre><code>Debug mode is enabled.\nRelease mode is not defined.\n</code></pre> <p>Note</p> <p>Every <code>#ifdef</code> or <code>#ifndef</code> must be closed with a corresponding <code>#endif</code>. Failing to do so will cause preprocessing or compilation errors.</p>"},{"location":"10%20Macros/#multiline-macros","title":"Multiline Macros","text":"<p>Sometimes a macro needs to expand to multiple lines of code. To indicate that a macro continues onto the next line, we use a backslash <code>\\</code> at the end of each line except the last.</p> main.cpp<pre><code>#define PRINT_SUM(a, b) \\\n    std::cout &lt;&lt; \"Sum: \" &lt;&lt; ((a) + (b)) &lt;&lt; '\\n';\n</code></pre> <p>Without the backslash, the preprocessor would treat each line as a separate directive or statement, leading to compilation errors.</p> <p>A common problem with multiline macros arises when a macro contains multiple statements and is used inside a control-flow construct. Simply enclosing the macro in braces <code>{}</code> may seem intuitive, but it can break the surrounding code if a semicolon follows, because the macro then expands to a compound statement that does not behave like a single statement.</p> example<pre><code>if (condition)\n    MACRO();\n</code></pre> <p>The standard solution is to wrap the macro in a <code>do { ... } while(0)</code> loop This pattern is widely used in professional codebases and library macros because it guarantees predictable expansion while keeping the preprocessor happy.</p> <pre><code>#define MACRO_SAFE(x) do { \\\n    func1(x);              \\\n    func2(x);              \\\n} while (0)\n</code></pre>"},{"location":"10%20Macros/#variadic-macros","title":"Variadic Macros","text":"<p>Variadic macros are function-like macros that can accept any number of arguments. They are particularly useful for logging, debugging, or other situations where the number of parameters may vary.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#define LOG(msg, ...)                         \\\n    std::cout &lt;&lt; \"[LOG] \" &lt;&lt; msg;             \\\n    ((std::cout &lt;&lt; ' ' &lt;&lt; __VA_ARGS__), ...); \\\n    std::cout &lt;&lt; '\\n';\n\nint main()\n{\n    LOG(\"Player score:\", \"P1\", 100);\n    LOG(\"Game started\");\n}\n</code></pre> output<pre><code>\n</code></pre> Concept Description <code>...</code> In the macro definition, captures all additional arguments after the first. <code>__VA_ARGS__</code> Replaced by whatever extra arguments are provided when the macro is invoked. <p>The <code>__VA_ARGS__</code> mechanism allows the macro to work correctly with zero or more additional arguments. This makes it possible to write flexible logging or debugging macros entirely in idiomatic C++.</p>"},{"location":"10%20Macros/#questions","title":"Questions","text":"question 1answer <p>What is a macro in C++?</p> <p>A macro is a preprocessor directive that defines a rule for text substitution before compilation.</p> question 2answer <p>What is the difference between object-like and function-like macros?</p> <ul> <li>Object-like macros resemble constants and do not take parameters.  </li> <li>Function-like macros take parameters and resemble functions in syntax, but expand as text.</li> </ul> question 3answer <p>What is the purpose of the stringizing operator <code>#</code> in a macro?</p> <p>It converts a macro parameter into a string literal during preprocessing.</p> question 4answer <p>How does the token concatenation operator <code>##</code> work?</p> <p>It joins two tokens into a single token during macro expansion, allowing programmatic generation of identifiers.</p> question 5answer <p>Why are parentheses important when defining function-like macros?</p> <p>Parentheses prevent operator precedence issues by ensuring the macro arguments and the resulting expression evaluate correctly.</p> question 6answer <p>What problem does the <code>do { ... } while(0)</code> pattern solve in macros?</p> <p>It ensures that multi-statement macros behave like a single statement in any control-flow context, preventing syntax errors.</p> question 7answer <p>What are variadic macros and how are they defined?</p> <p>Macros that accept any number of arguments, defined with <code>...</code> in the macro parameter list, and using <code>__VA_ARGS__</code> to expand the extra arguments.</p> question 8answer <p>What is a predefined macro? Give two examples.</p> <p>Predefined macros are macros automatically provided by the compiler or preprocessor. Examples: - <code>__FILE__</code> \u2014 expands to the current source file name. - <code>__LINE__</code> \u2014 expands to the current line number.</p>"},{"location":"10%20Macros/#exercises","title":"Exercises","text":"exercise 1answer <p>Write a function-like macro <code>CUBE(x)</code> that correctly computes the cube of an expression, handling operator precedence.</p> <pre><code>#include &lt;iostream&gt;\n\n#define CUBE(x) ((x) * (x) * (x))\n\nint main() {\n    int n = 5;\n\n    std::cout &lt;&lt; \"Cube of \" &lt;&lt; n &lt;&lt; \" is \" &lt;&lt; CUBE(n) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Cube of (n + 1) is \" &lt;&lt; CUBE(n + 1) &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/","title":"11 Templates and Metaprogramming","text":"<p>Info</p> <p>From this point forward, we are diving into the advanced features of the language. While these concepts form the backbone of modern C++ library design, they are not strictly mandatory for building functional software in the same way our previous chapters were.</p> <p>To truly level up as a developer, you should balance this theory with hands-on projects. Exploring professional frameworks like Qt, engines like UE5, graphics APIs like OpenGL or Direct3D11, or embedded systems like Arduino will often teach you more about real-world software development than language syntax alone.</p> <p>As we learned in the previous chapter, macros in modern C++ should be avoided in favor of safer, language-native alternatives. One of these alternatives is Templates.</p> <p>Templates allow us to write generic code that works with any data type without duplicating logic. Instead of overloading functions or rewriting classes for every possible type, we define a template\u2014a single blueprint\u2014and let the compiler handle the rest.</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#how-templates-work","title":"How Templates Work","text":"<p>The compiler uses these blueprints to generate the actual machine code only when it is needed. This process is called instantiation. If a template is never used, it never appears in the final binary, keeping our executable lean.</p> <p>Since templates are a native C++ concept, they follow the rules of the language. They participate in type deduction, overload resolution, and respect access modifiers. This makes them far more predictable and safer than the copy-paste behavior of macros.</p> <p>In fact, templates form the foundation of the Standard Template Library; all containers rely on templates to store various data types.</p> <p>One of the most important rules is: Templates should exist entirely in header files.</p> <p>Unlike regular functions, the compiler needs to see the entire definition of a template to instantiate it for a specific type.</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#the-tradeoff","title":"The Tradeoff","text":"<p>While templates are incredibly powerful, they should be used with care. It is rarely healthy to \"templatize\" every part of our codebase just because we can. Templates have a reputation for producing notoriously long and confusing error messages that can be difficult to debug. Like any complex feature, overusing them can lead to code that is difficult to read or maintain. Balance is key.</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#function-templates","title":"Function Templates","text":"<p>Let\u2019s start with the most basic implementation of a template. One of the clearest ways to see why templates are so vital is by examining a simple function that outputs a value to the console.</p> <pre><code>void Print(int value) {\n    std::cout &lt;&lt; value &lt;&lt; '\\n';\n}\n\nPrint(42);\nPrint(\"Hello World!\"); // Error: cannot implicitly convert const char* to int\n</code></pre> <p>This function handles integers perfectly, but if we pass a string, the compiler throws an error due to a type mismatch. Previously, we might have solved this by overloading the function for every type we wanted to support. However, this becomes redundant quickly. All these functions perform the exact same logic; they just use different types.</p> <p>Instead of writing multiple versions of the same function, we can define one generic version through a template.</p> <pre><code>// 'typename' and 'class' are interchangeable here; both define a type.\n// 'T' is a placeholder for a type; we can name it whatever we like.\ntemplate&lt;typename T&gt; \nvoid Print(const T&amp; value) {\n    std::cout &lt;&lt; value &lt;&lt; '\\n';\n}\n\nPrint(42);                 // T is int\nPrint(3.14);               // T is double\nPrint(\"Hello world!\");     // T is const char*\nPrint(std::string(\"C++\")); // T becomes std::string\n</code></pre> <p>Info</p> <p>In the template definition, we'll see <code>typename T</code>. We might also see developers use <code>class T</code> (e.g., <code>template&lt;class T&gt;</code>). While they are functionally interchangeable in this context, typename is generally preferred. Using <code>class</code> can be misleading, as it suggests the template only works with class types, when it actually works with primitives as well.</p> <p>When we compile this, the compiler performs a process called instantiation. It generates a specific version of the function for every type we actually use in our code. In the final binary, it looks as if we had written:</p> <pre><code>void Print(const int&amp; value) {\n    std::cout &lt;&lt; value &lt;&lt; '\\n';\n}\n\nvoid Print(const double&amp; value) {\n    std::cout &lt;&lt; value &lt;&lt; '\\n';\n}\n\nvoid Print(const char* const&amp; value) {\n    std::cout &lt;&lt; value &lt;&lt; '\\n';\n}\n\nvoid Print(const std::string&amp; value) {\n    std::cout &lt;&lt; value &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#explicit-template-arguments","title":"Explicit Template Arguments","text":"<p>In most cases, the compiler can automatically deduce the template types based on the arguments we provide. This is called Template Argument Deduction. However, we can manually specify the type using angle brackets.</p> <pre><code>template&lt;typename T&gt;\nT GetValue(const T&amp; value) {\n    return value;\n}\n\n// Manually telling the compiler T is an int\nauto value = GetValue&lt;int&gt;(42);\n</code></pre> <p>Info</p> <p>Explicitly stating the type doesn't change the performance of the code, but it is useful for resolving ambiguity.</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#multiple-template-parameters","title":"Multiple Template Parameters","text":"<p>Template definitions aren't limited to a single type\u2014we can define as many as needed by separating them with commas. This is helpful when we want a function to handle different types for different parameters.</p> <pre><code>template &lt;typename T, typename U&gt;\nvoid PrintPair(const T&amp; first, const U&amp; second) {\n    std::cout &lt;&lt; \"First: \" &lt;&lt; first &lt;&lt; \", Second: \" &lt;&lt; second &lt;&lt; '\\n';\n}\n\n// T becomes int, U becomes const char*\nPrintPair(42, \"Age\");\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#non-type-template-parameters","title":"Non Type Template Parameters","text":"<p>In earlier chapters, we saw that passing a <code>std::array</code> into a function can be a problem because the size is part of the type. For example, a function expecting a <code>std::array&lt;int, 5&gt;</code> cannot accept a <code>std::array&lt;int, 10&gt;</code>.</p> <p>Trough templates we can solve this beautifully. We can use a non-type template parameter to capture the size of the array at compile time, making the function completely flexible.</p> <pre><code>// 'T' is the type, 'K' is a non-type template parameter (the size)\n// 'K' represents a compile-time constant value\ntemplate&lt;typename T, size_t K&gt;\nvoid PrintArray(const std::array&lt;T, K&gt;&amp; arr) {\n    for (const T&amp; element : arr) {\n        std::cout &lt;&lt; element &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; '\\n';\n}\n\nstd::array&lt;int, 5&gt; int_arr;\nstd::array&lt;std::string, 3&gt; str_arr;\n\n// T = int, K = 5\nPrintArray(int_arr); \n\n// T = std::string, K = 3\nPrintArray(str_arr);\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#abbrevieted-function-templates","title":"Abbrevieted Function Templates","text":"<p>In C++20, we can write templates without using the <code>template&lt;typename T&gt;</code> syntax. By using <code>auto</code> in a function\u2019s parameter list, the compiler automatically treats that function as a template.</p> <pre><code>// This is still a function template\nvoid PrintCollection(const auto&amp; coll) {\n    for (const auto&amp; elem : coll) {\n        std::cout &lt;&lt; elem &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; '\\n';\n}\n</code></pre> <p>While this is shorter and easier to read, there is a catch: we don't have a name for the type. In a traditional template, we can use <code>T</code> to create a local variable or a return type. With abbreviated templates, if we suddenly need to know the name of the type, it becomes a bit tricky. We have to use <code>decltype</code> to extract the type.</p> <pre><code>void SwapFirstAndSecond(auto&amp; coll) {\n    // We don't have 'T', so we use decltype to find the type of the elements\n    using T = decltype(coll[0]); \n    T temp = coll[0];\n    coll[0] = coll[1];\n    coll[1] = temp;\n}\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#concepts","title":"Concepts","text":"<p>To understand what concepts are and the problems they solve, we must first look at a common challenge we faced in the past. Templates are incredibly flexible, but they are also blind to the capabilities of the types we pass into them until the moment of instantiation.</p> <p>Consider a scenario where we want to create a generic <code>Add</code> function that works with different types of collections.</p> <pre><code>template&lt;typename CollT, typename T&gt;\nvoid Add(CollT&amp; coll, const T&amp; val) {\n    coll.push_back(val);\n}\n\nstd::vector&lt;int&gt; coll;\n\nAdd(coll, 10);\n</code></pre> <p>This works perfectly for <code>std::vector</code>, but a complication arises when we try to use a collection that does not support <code>.push_back()</code>, such as for example a <code>std::set</code>. In the past, we could not simply overload this template because the function signature remains the same; only the logic inside the body changes. If we tried to define two versions of this template, we would face a redefinition error.</p> <p>Historically, C++ did not have a direct way to express requirements for template parameters. If we wanted to restrict a function to only work with certain types, we had to rely on a complex paradigm known as SFINAE (Substitution Failure Is Not An Error).</p> <p>This usually involved using <code>std::enable_if</code>, a tool that intentionally breaks a template's substitution to force the compiler to look for a different overload. While effective, this approach often felt like we were abusing the template system. It resulted in verbose, hacky code and produced notoriously long, cryptic error messages that were difficult to debug.</p> <p>In Modern C++ (C++20 and beyond), we have moved away from these workarounds in favor of a formal, first-class solution: Concepts.</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#defining-and-using-concepts","title":"Defining and Using Concepts","text":"<p>Concepts allow us to define requirements that a type must meet at compile time. Instead of hoping a type has a specific method, we can explicitly check for it.</p> <pre><code>// We define a concept to check if a type has a push_back method\ntemplate&lt;typename CollT&gt;\nconcept HasPushBack = requires(CollT c, CollT::value_type v) {\n    c.push_back(v);\n};\n\n// This version is only used if the collection matches our concept\ntemplate&lt;typename CollT, typename T&gt;\nrequires HasPushBack&lt;CollT&gt;\nvoid Add(CollT&amp; coll, const T&amp; val) {\n    coll.push_back(val);\n}\n\n// This version acts as a fallback for other collections like std::set\ntemplate&lt;typename CollT, typename T&gt;\nvoid Add(CollT&amp; coll, const T&amp; val) {\n    coll.insert(val);\n}\n\nstd::vector&lt;int&gt; v;\nstd::set&lt;int&gt; s;\n\nAdd(v, 10); // Uses the push_back version\nAdd(s, 99); // Uses the insert version\n</code></pre> <p>By studying this approach, we can see how we now have the power to set clear requirements for our templates. In the example above, the compiler evaluates the constraints: if the type satisfies <code>HasPushBack</code>, it uses the first implementation. If not, it falls back to the second. This results in much cleaner code and, importantly, much clearer error messages if we pass a type that meets neither requirement.</p> <p>For better readability, we can use a more concise syntax. Instead of using a separate requires clause, we can replace the <code>typename</code> keyword directly with our concept name. Both of these approaches are functionally identical.</p> <pre><code>// Version 1\ntemplate&lt;typename CollT, typename T&gt;\nrequires HasPushBack&lt;CollT&gt;\n\n// Version 2\ntemplateF&lt;HasPushBack CollT, typename T&gt;\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#concept-validation","title":"Concept Validation","text":"<p>While Concepts are a powerful addition to the language, they are not immune to human error. Because Concepts are essentially compile-time predicates (logical true/false checks), a simple typo can lead to unexpected behavior that is often difficult to track down.</p> <p>The most common issue we encounter is a misspelling within the requires block. Consider the following mistake.</p> <pre><code>template&lt;typename CollT&gt;\nconcept HasPushBack = requires(CollT c, CollT::value_type v) {\n    c.pushback(v); // We accidentally omitted the underscore\n};\n\nstd::vector&lt;int&gt; v;\n\nAdd(v, 10); // ERROR: can't call insert()\n</code></pre> <p>In this scenario, the compiler checks <code>std::vector</code> against our <code>HasPushBack</code> concept. Because <code>std::vector</code> does not have a method named <code>pushback</code>, the concept evaluates to false.</p> <p>Rather than giving us a compiler error about the typo, the compiler assumes the requirement was simply not met and moves on to the next available <code>Add</code> overload\u2014the one that uses <code>.insert()</code>. This results in a confusing error message claiming that <code>std::vector</code> has no member named <code>insert</code>.</p> <p>Because concepts evaluate to boolean values at compile time, we can\u2014and should\u2014verify them using <code>static_assert</code>. This allows us to catch typos and logic errors immediately without needing to instantiate complex function templates first.</p> <pre><code>template&lt;typename CollT&gt;\nconcept HasPushBack = requires(CollT c, CollT::value_type v) {\n    c.push_back(v);\n};\n\nstatic_assert(HasPushBack&lt;std::vector&lt;int&gt;&gt;, \"Vector should be supported\");\nstatic_assert(!HasPushBack&lt;std::set&lt;int&gt;&gt;, \"Set should not be supported\");\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#concepts-in-abbreviated-templates","title":"Concepts in Abbreviated Templates","text":"<p>In modern C++, we often use <code>auto</code> in function parameters to create Abbreviated Function Templates. This is a cleaner shorthand for writing <code>template&lt;typename T&gt;</code>. However, we encounter the same redefinition problem if we try to overload them without constraints.</p> <pre><code>// This will cause a redefinition error because both signatures look identical\nvoid Add(auto&amp; coll, const auto&amp; val) {\n    coll.push_back(val);\n}\n\nvoid Add(auto&amp; coll, const auto&amp; val) {\n    coll.insert(val);\n}\n</code></pre> <p>We can solve this by qualifying the <code>auto</code> keyword with a concept. This tells the compiler: \"This function only accepts an object that satisfies <code>HasPushBack</code>.</p> <pre><code>void Add(HasPushBack auto&amp; coll, const auto&amp; val) {\n    coll.push_back(val);\n}\n\nvoid Add(auto&amp; coll, const auto&amp; val) {\n    coll.insert(val);\n}\n</code></pre> <p>Sometimes, we may prefer using a <code>requires</code> clause with <code>decltype</code> for better control. However, we must be careful. If our function takes a reference like in this case, <code>decltype</code> will return a reference type such as <code>std::vector&lt;int&gt;&amp;</code>.</p> <p>Concepts often fail when we pass them a reference because a reference itself doesn't have member functions or nested types like <code>value_type</code>; only the underlying type does. To fix this, we must strip away the extras like references and const qualifiers.</p> <p>We can do this using <code>std::remove_cvref_t</code> (introduced in C++20). This is preferred over the older <code>std::decay</code>, as it can accidentally turn arrays into pointers, which might not be our intention.</p> <p>We have two ways to apply this fix. We can apply it at the call site.</p> <pre><code>void Add(auto&amp; coll, const auto&amp; val) \nrequires HasPushBack&lt;std::remove_cvref_t&lt;decltype(coll)&gt;&gt; {\n    coll.push_back(val);\n}\n</code></pre> <p>However, to keep our code clean, it is often better to handle this cleaning inside the concept definition itself. This ensures that anyone using the concept doesn't have to worry about whether they are passing a reference or a value.</p> <pre><code>template&lt;typename CollT&gt;\nconcept HasPushBack = requires(std::remove_cvref_t&lt;CollT&gt; c,\n                               std::remove_cvref_t&lt;CollT&gt;::value_type v) {\n    c.push_back(v);\n};\n\nvoid Add(auto&amp; collection, const auto&amp; value) \nrequires HasPushBack&lt;decltype(collection)&gt; {\n    collection.push_back(value);\n}\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#concepts-for-multiple-prameters","title":"Concepts for Multiple Prameters","text":"<p>We are not limited to validating a single type at a time. Often, the logic of our code depends on how two different types interact. In these cases, we can define concepts that accept multiple parameters.</p> <p>For example, it isn't enough to know that a collection has a <code>.push_back()</code>; we must also ensure that the specific value we are passing is compatible with that collection.</p> <pre><code>template&lt;typename CollT, typename T&gt;\nconcept CanPushBack = requires (CollT c, T v) {\n    c.push_back(v);\n};\n\ntemplate&lt;typename CollT, typename T&gt;\nrequires CanPushBack&lt;CollT, T&gt;\nvoid Add(CollT&amp; coll, const T&amp; val) {\n    coll.push_back(val);\n}\n\nstd::vector&lt;int&gt; numbers;\nAdd(numbers, 10);   // OK: Can push int into vector&lt;int&gt;\n\nAdd(numbers, \"Hi\"); // ERROR: vector&lt;int&gt; cannot push_back a const char*\n</code></pre> <p>We can also apply this to abbreviated function templates. However, as we noticed in previous examples, this requires us to be very explicit with <code>decltype</code> and type-cleaning traits to ensure we are passing the correct types to the concept.</p> <pre><code>void Add(auto&amp; coll, const auto&amp; val)\nrequires CanPushBack&lt;std::remove_cvref_t&lt;decltype(coll)&gt;, \n                     std::remove_cvref_t&lt;decltype(val)&gt;&gt; {\n    coll.push_back(val);\n}\n</code></pre> <p>As we begin to use concepts more frequently, we must be careful not to fall into the template rabbit hole. It is possible to create concepts that are too granular or specific, which can add unnecessary overhead to our mental model of the code.</p> <p>If a concept is only ever used for one specific function and one specific pair of types, we might ask ourselves if a standard function overload would be simpler and more readable. The true power of concepts lies in their ability to define generic requirements that apply to broad range of types.</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#requires-in-compile-time-if","title":"Requires in Compile Time If","text":"<p>Sometimes we don't need a full-blown named concept. We just want to check if a specific line of code would work before we try to compile it. This is where the requires expression and <code>if constexpr</code> work together to create branching logic at compile time.</p> <p>In the example below, we create a function that adds an item to a collection. It doesn't care if the collection uses <code>.push_back()</code> or <code>.insert()</code>, it checks for the right method automatically.</p> <pre><code>void Add(auto&amp; coll, const auto&amp; val) {\n    if consexpr (requires { coll.push_back(val); }) {\n        coll.push_back(val);\n    } else {\n        coll.insert(val);\n    }\n}\n\nstd::vector&lt;int&gt; v;\nstd::set&lt;int&gt; s;\n\nAdd(v, 10); // Compiler sees push_back works, uses the first branch\nAdd(s, 20); // Compiler sees push_back fails, uses the second branch\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#constrain-ambiguities","title":"Constrain Ambiguities","text":"<p>Concepts can lead to ambiguity errors if two different functions match the same type equally well.</p> <p>In the example below, a <code>std::vector</code> supports both <code>.size()</code> and the index operator. Because it satisfies both requirements, the compiler doesn't know which version of <code>foo()</code> to choose.</p> <pre><code>template&lt;typename CollT&gt;\nconcept HasSize = requires (CollT c) {\n    { c.size() } -&gt; std::converitble_to&lt;int&gt;;\n};\n\ntemplate&lt;typename CollT&gt;\nconcept HasIndexOp = requires (CollT c) {\n    c[0];\n};\n\ntemplate&lt;typename CollT&gt;\nrequires HasSize&lt;CollT&gt;               // Has to support size()\nvoid foo(const CollT&amp; coll) {\n    std::cout &lt;&lt; coll.size() &lt;&lt; '\\n';\n}\n\ntemplate&lt;typename CollT&gt;\nrequires HasIndexOp&lt;CollT&gt;            // Has to support []\nvoid foo(const CollT&amp; coll) {\n    std::cout &lt;&lt; \"[]\\n\";\n}\n\nfoo(std::list&lt;int&gt;{0, 8, 15});   // OK: calls first foo()\nfoo(std::vector&lt;int&gt;{0, 8, 15}); // ERROR: ambiguous\n</code></pre> <p>To fix this, we need to tell the compiler that one version is more specialized than the other. C++ uses a rule called subsumption: if one function's requirements include all the requirements of another plus something extra, the compiler will pick the more specific one.</p> <p>We can fix the ambiguity by combining the concepts in the requires clause.</p> <pre><code>// This version is now more constrained than before\ntemplate&lt;typename CollT&gt;\nrequires HasSize&lt;CollT&gt; &amp;&amp; HasIndexOp&lt;CollT&gt; \nvoid foo(const CollT&amp; coll) {\n    std::cout &lt;&lt; \"[]\\n\";\n}\n\nfoo(std::vector&lt;int&gt;{1, 2}); // OK: Picks the most constrained version.\n}\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#constrains-for-non-type-template-parameters","title":"Constrains for Non Type Template Parameters","text":"<p>Concepts are most commonly used to check properties, but they can also be used to validate non-type template parameters. This allows us to catch logic errors at compile time before the program even runs.</p> <p>Suppose we want a class or function that only accepts a prime number as a template argument. First, we define a compile time function to do the math, then we wrap it in a concept.</p> <pre><code>// A constexpr function that can be evaluated at compile-time\nconstexpr bool IsPrime(int val) {\n    if (val &lt;= 1) {\n        return false;\n    }\n\n    for (int i = 2; i * i &lt;= val; ++i) {\n        if (val % i == 0) {\n            return false;\n        }\n    }\n\n    return true; \n}\n\n// A concept that uses that function\ntemplate&lt;int N&gt;\nconcept Prime = IsPrime(N);\n\n// Applying the concept to a Non-Type Template Parameter\ntemplate&lt;int N&gt;\nrequires Prime&lt;N&gt;\nvoid ProcessPrime() {\n    std::cout &lt;&lt; \"valid prime number\\n\";\n}\n\nProcessPrime&lt;7&gt;();  // OK: 7 is prime\nProcessPrime&lt;10&gt;(); // ERROR: 10 is not prime (fails at compile time)\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#template-specialization","title":"Template Specialization","text":"<p>Sometimes, the one-size-fits-all approach of a general template isn't enough. We might need a specific data type to behave differently\u2014perhaps to optimize performance, handle a unique edge case, or format the output differently.</p> <p>Template specialization allows us to override the general template with a custom implementation for one specific type. To do this, we use the <code>template&lt;&gt;</code> syntax. This tells the compiler: \"I am still using a template, but I am providing a specific version where the types are already filled in.\"</p> <pre><code>// The Primary (General) Template\ntemplate&lt;typename T&gt;\nvoid Print(const T&amp; value) {\n    std::cout &lt;&lt; \"General: \" &lt;&lt; value &lt;&lt; '\\n';\n}\n\n// Full Specialization for std::string\ntemplate&lt;&gt;\nvoid Print&lt;std::string&gt;(const std::string&amp; value) {\n    std::cout &lt;&lt; \"Specialized: '\" &lt;&lt; value &lt;&lt; \"'\\n\";\n}\n\nPrint(100);                        // Uses General\nPrint(std::string(\"Specialized\")); // Uses Specialization\n</code></pre> <p>Note</p> <p>A string literal (<code>const char*</code>) is NOT a <code>std::string</code>. Therefore it will use the General template unless we specialize for <code>const char*</code> too.</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#class-templates","title":"Class Templates","text":"<p>Class templates apply the blueprint logic to entire data structures. As we have seen, the Standard Template Library is built entirely on this foundation; when we use <code>std::vector&lt;int&gt;</code>, we aren't just using a class\u2014we are using a specific instantiation of a class template.</p> <p>A class template allows us to define member variables and methods using placeholder types, deferring the choice of the actual type until the object is declared.</p> main.cpp<pre><code>template&lt;typename T&gt;\nclass Stack {\npublic:\n    void Push(const T&amp; elem);\n    T Pop();\n    T Top() const;\n\n    bool Empty() const {\n        return elems.empty();\n    }\n\nprivate:\n    std::vector&lt;T&gt; elems;\n};\n</code></pre> <p>Because the compiler needs to see the template definition to generate the code for a specific type, the implementation must reside in the header file.</p> <p>The most common and readable approach is to write the implementation directly inside the class definition.</p> <pre><code>template&lt;typename T&gt;\nclass Stack {\npublic:\n    void Push(const T&amp; elem) {\n        elems.push_back(elem);\n    }\n    // ... other methods ...\n};\n</code></pre> <p>Alternatively, if we prefer to keep our class interface clean, we can define methods outside the class body, provided they remain in the same header.</p> <pre><code>template&lt;typename T&gt;\nvoid Stack&lt;T&gt;::Push(const T&amp; elem) {\n    elems.push_back(elem);\n}\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#implicit-reuirements","title":"Implicit Reuirements","text":"<p>One of the more subtle, and occasionally dangerous, aspects of C++ templates is that requirements are often implicit. Unlike traditional inheritance where requirements are explicitly defined in a base class, template requirements emerge from how the type is actually used within the code.</p> <p>Consider what happens if we add a debugging method to our <code>Stack</code>.</p> <pre><code>template&lt;typename T&gt;\nvoid Stack&lt;T&gt;::Print() const {\n    for (const T&amp; elem : elems) {\n        // Implicit requirement: T must support operator&lt;&lt;\n        std::cout &lt;&lt; elem &lt;&lt; ' ';\n    }\n}\n</code></pre> <p>By adding this method, we have introduced a new constraint: <code>T</code> must be printable. However, C++ employs a strategy called Lazy Instantiation. The compiler does not generate the executable code for a template member function unless that specific function is actually called in our program.</p> <p>This behavior allows for a high degree of flexibility in our designs. We can successfully instantiate a <code>Stack&lt;MyType&gt;</code>\u2014even if <code>MyType</code> has no definition for <code>operator&lt;&lt;</code>\u2014provided we never actually call the <code>Print()</code> method.</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#argument-deduction","title":"Argument Deduction","text":"<p>Since templates were introduced, the compiler has become even smarter. In many cases, we no longer need to explicitly list the template types if the compiler can figure them out from the constructor arguments. This is called CTAD.</p> main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\ntemplate&lt;typename T, typename U&gt;\nstruct Pair {\n    T first;\n    U second;\n\n    Pair(T f, U s) : first(f), second(s) {}\n};\n\nPair p(\"string\", 41.78);\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#variadic-templates","title":"Variadic Templates","text":"<p>While standard templates allow us to be generic with types, Variadic Templates allow us to be generic with the number of arguments. Sometimes, we need a function that can accept an unknown number of arguments, each potentially being a different type.</p> <p>The syntax utilizes the ellipsis operator <code>(...)</code>, which defines what is known as a Parameter Pack.</p> <pre><code>// Base case: To stop the recursion when no arguments are left\nvoid Print() {}\n\ntemplate&lt;typename T, typename... Types&gt;\nvoid Print(const T&amp; first_arg, const Types&amp;... args) {\n    std::cout &lt;&lt; first_arg &lt;&lt; '\\n';\n    Print(args...); // Recursive call\n}\n\nstd::string str = \"string\";\n\nPrint(\"Hello\", 43.71, str);\n</code></pre> <p>A variadic template typically works through a functional pattern of recursion. It peels off the first argument, processes it, and then passes the remaining pack back into itself.</p> <p>When we call <code>Print(\"Hello\", 43.71, str)</code>, the compiler instantiates a chain of functions that looks like this:</p> <pre><code>// 1. first_arg is \"Hello\", args is {43.71, str}\nPrint(const char* first_arg, double arg1, std::string arg2) {\n    std::cout &lt;&lt; \"Hello\" &lt;&lt; '\\n';\n    Print(43.71, str); \n}\n\n// 2. first_arg is 43.71, args is {str}\nPrint(double first_arg, std::string arg1) {\n    std::cout &lt;&lt; 43.71 &lt;&lt; '\\n';\n    Print(str);\n}\n\n// 3. first_arg is str, args is empty\nPrint(std::string first_arg) {\n    std::cout &lt;&lt; \"string\" &lt;&lt; '\\n';\n    Print(); // Calls the base case\n}\n\n// 4. Base case\nPrint() {}\n</code></pre> <p>We can query the number of elements inside a parameter pack using the <code>sizeof...</code> operator. This is useful for debugging or logic branching within the template.</p> <p>In modern C++ (C++17 and later), we can often avoid writing a separate base case function by using <code>if constexpr</code>. This allows the compiler to conditionally discard the recursive call if the pack is empty, preventing a compilation error when the arguments run out.</p> <pre><code>template&lt;typename T, typename... Types&gt;\nvoid Print(const T&amp; first_arg, const Types&amp;... args) {\n    std::cout &lt;&lt; first_arg &lt;&lt; '\\n';\n\n    if constexpr (sizeof...(args) &gt; 0) { // Only compiled if there are more args\n        Print(args...);\n    }\n}\n</code></pre> <p>Info</p> <p>Variadic templates are a cornerstone of the Standard Template Library. While the syntax may seem specialized at first, these templates are incredibly versatile. Even if we don't find ourselfs writing them daily, understanding how they work is essential for navigating modern C++ and understanding how many standard library features operate under the hood.</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#variable-templates","title":"Variable Templates","text":"<p>While function templates define blueprints for functions and class templates define blueprints of classes, Variable Templates allow us to define blueprints of variables. This is particularly useful for mathematical constants, configuration settings.</p> <p>The most immediate use case for variable templates is defining constants that maintain the precision of the type they are called with.</p> <pre><code>template&lt;typename T&gt;\nconstexpr T pi = T(3.14159265358979323L); \n\nint main() {\n    // The compiler generates a double version of pi\n    std::cout &lt;&lt; std::setprecision(20) &lt;&lt; pi&lt;double&gt; &lt;&lt; \"\\n\"; \n\n    // The compiler generates a float version (less precise)\n    std::cout &lt;&lt; pi&lt;float&gt; &lt;&lt; \"\\n\"; \n}\n</code></pre> <p>Before C++14, we often used constexpr functions to get values. Variable templates provide a cleaner, data-centric syntax.</p> <pre><code>constexpr auto GetValue() {\n    return 31;\n}\n\n// Variable template acting as a type-casted \"bridge\"\ntemplate&lt;typename T&gt;\nconstexpr T value = static_cast&lt;T&gt;(GetValue());\n</code></pre> <p>Note</p> <p>We use variable templates when we are describing a property of a type (e.g., \"The Pi value for a float\") rather than a process (e.g., \"Calculate the value of Pi\").</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#specialization-and-compile-time-recursion","title":"Specialization and Compile-Time Recursion","text":"<p>Just like class templates, variable templates can be specialized. This allows us to perform complex calculations like the Fibonacci sequence and similar entirely at compile time.</p> <pre><code>template&lt;int Value&gt;\nconstexpr auto fib = fib&lt;Value - 1&gt; + fib&lt;Value - 2&gt;;\n\n// Base cases using full specialization\ntemplate&lt;&gt;\nconstexpr auto fib&lt;0&gt; = 0;\n\ntemplate&lt;&gt;\nconstexpr auto fib&lt;1&gt; = 1;\n</code></pre> <p>When we access <code>fib&lt;5&gt;</code>, the compiler recursively instantiates the templates until it hits the specialized base cases (0 and 1), resulting in a single constant at runtime.</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#simplifying-type-traits","title":"Simplifying Type Traits","text":"<p>Variable templates revolutionized how we write type traits. Instead of the clunky C++11 syntax <code>std::is_same&lt;T, U&gt;::value</code>, we can create direct boolean variables.</p> <pre><code>template&lt;typename T, typename U&gt;\nconstexpr bool is_same = false;\n\n// Partial specialization: triggered only when types match\ntemplate&lt;typename T&gt;\nconstexpr bool is_same&lt;T, T&gt; = true;\n\nstatic_assert(is_same&lt;int, int&gt;);    // OK\nstatic_assert(!is_same&lt;int, float&gt;); // OK\n</code></pre>"},{"location":"11%20Templates%20and%20Metaprogramming/#templated-lambdas","title":"Templated Lambdas","text":"<p>We can store a lambda expression inside a variable template. This creates a generic function object factory that is bound to a specific type.</p> <pre><code>template&lt;typename T&gt;\nconstexpr auto add = [](const T&amp; lhs, const T&amp; rhs) {\n    return lhs + rhs;\n};\n\nauto sum = add&lt;int&gt;(10, 20);\n</code></pre> <p>This is a powerful pattern for creating reusable logic that must remain strictly typed.</p>"},{"location":"11%20Templates%20and%20Metaprogramming/#alias-templates","title":"Alias Templates","text":""},{"location":"11%20Templates%20and%20Metaprogramming/#type-traits","title":"Type Traits","text":""},{"location":"11%20Templates%20and%20Metaprogramming/#questions","title":"Questions","text":""},{"location":"11%20Templates%20and%20Metaprogramming/#exercises","title":"Exercises","text":"exercise 1answer"},{"location":"12%20Multithreading/","title":"12 Multithreading","text":"<p>\ud83d\udea7 This chapter is under construction... \ud83d\udea7</p>"},{"location":"13%20Build%20Systems%20and%20CMake/","title":"13 Build Systems with CMake","text":"<p>At this point, we want to build more than just command-line tools and utilities. Those were a necessary starting point\u2014but now it's time to scale up. As C++ isn\u2019t just used for small scripts; it\u2019s the backbone of massive systems like game engines, CAD software and 3D tools, as well as complex systems in aerospace and robotics. Since these projects often target multiple platforms, we\u2019ll need a cross-platform build system to streamline development, integration and deployment.</p> <p>A build system is a tool that automates the process of compiling, linking, and packaging code. It manages file dependencies, handles platform-specific quirks, and generates the necessary build files for your compiler or IDE to produce an executable. When the build system is cross-platform, it means you can define your build logic once and have it work seamlessly on Windows, macOS, or Linux\u2014without rewriting anything.</p> <p>The need for a cross-platform build system doesn\u2019t arise from a lack of platform-specific tools\u2014they absolutely exist. Each major IDE comes bundled with its own build system, such as MSBuild in Microsoft Visual Studio or the build tools integrated into Apple\u2019s Xcode. These environments are powerful, but they tend to lock you into their ecosystems, making it harder to move between platforms or collaborate with developers using different setups. And realistically, learning a different build system for every platform just isn\u2019t practical.</p> <p>What developers really need is a unified solution. It\u2019s far more efficient to master a single, flexible, and portable tool that works everywhere. Also a cross-platform build system becomes especially valuable when you're using third-party libraries, switching between compilers, or integrating tools like formatters, linters, and static analyzers. That\u2019s why these systems are essential for maintainable development.</p> <p>The thing is, as we've seen with IDEs being tied to their respective operating systems, C++ development isn\u2019t as unified as in some more modern languages. There\u2019s no single, official cross-platform build system endorsed by the language itself. Instead, the community relies on a variety of tools\u2014some more established than others.</p> <p>Fortunately, several solid options exist, but only one has emerged as the de facto standard\u2014CMake. It\u2019s flexible, powerful, and widely used by major libraries and projects across the C++ ecosystem, making it the most worthwhile build system for beginners to learn and an essential skill for any C++ developer.</p> <p>Other noteworthy build systems include Bazel, developed by Google with an emphasis on performance and large-scale builds, and Premake, which opts for a Lua-based configuration style that prioritizes readability and simplicity. Still, if you're just starting out\u2014or even working on serious cross-platform projects\u2014CMake remains the best place to begin.</p> <p>Some might argue\u2014just like with C++ itself\u2014that CMake is outdated and hard to write because of its unusual and unreadable syntax and behaviour. While that may have been true a decade ago, modern CMake has evolved into a comprehensive and much more approachable tool. That\u2019s why, in this chapter\u2014and as our build system of choice\u2014we\u2019ll focus on CMake: how it works and how to effectively use it in our projects.</p>"},{"location":"13%20Build%20Systems%20and%20CMake/#getting-started","title":"Getting Started","text":"<p>As mentioned, CMake is a standalone cross-platform build system, which means it must be installed separately. Fortunately, installation is straightforward on all major platforms and can be done in a few simple steps.</p> <p>The easiest way is through the official CMake website: https://cmake.org/download/.</p> <p>We then have to scroll down to the \"Binary Distributions\" section, choose the latest version available, and download the installer that matches our operating system and system architecture. Then just run the installer and follow the default steps\u2014it\u2019s a simple next-next-finish process.</p> <p>Alternatively, we can install CMake through a package manager available on our platform, such as winget, Homebrew, or Chocolatey. This can be an even quicker option if you\u2019re already comfortable with the terminal, but either method will get you to the same result.</p>"},{"location":"13%20Build%20Systems%20and%20CMake/#cmake-basics","title":"CMake Basics","text":"<p>The first thing to understand is that CMake has its own scripting language, and it expects build scripts to be placed in files named <code>CMakeLists.txt</code>\u2014this is the specific filename CMake looks for when configuring a project. There\u2019s no limit to how many of these files a project can contain\u2014each subdirectory can have its own\u2014but just like in C++, there needs to be a clear entry point. For CMake, that entry point is the root <code>CMakeLists.txt</code> file located at the top level of our project. This is where the build configuration begins.</p> <p>It's also highly recommended to use a dedicated <code>build/</code> or <code>out/</code> directory. This is where CMake generates all the necessary build files, tailored specifically to our platform and compiler. Keeping these generated files separate helps maintain a clean project structure, free from clutter.</p> <p>The contents of this directory will vary depending on our system, compiler, and build tools, but that\u2019s exactly where CMake\u2019s power comes through. We only need to write a single <code>CMakeLists.txt</code> file, and CMake takes care of generating the appropriate build files for whatever environment we\u2019re using.</p> <p>This approach not only keeps our source code tidy but also makes it easier to manage multiple builds\u2014such as Debug and Release\u2014simultaneously by using separate build directories for each configuration.</p> <p>To get started, we'll begin with the simplest example and cover all the basics you need to understand to successfully configure and build a project using CMake.</p> <p>First, recreate the file structure shown below and place the example code into the corresponding files. This setup is necessary because we\u2019ll build upon this example in the upcoming sections.</p> <pre><code>cmake-example-project/\n\u251c\u2500\u2500 build/\n\u251c\u2500\u2500 include/\n\u2502   \u2514\u2500\u2500 calc.h\n\u251c\u2500\u2500 source/\n\u2502   \u251c\u2500\u2500 calc.cpp\n\u2502   \u2514\u2500\u2500 main.cpp\n\u2514\u2500\u2500 CMakeLists.txt\n</code></pre> calc.h<pre><code>#pragma once\n\nint Sum(int arr[], int size);\n</code></pre> calc.cpp<pre><code>#include \"calc.h\"\n\nint Sum(int arr[], int size) {\n    int sum = 0;\n\n    if (size &lt;= 0)\n        return 0;\n\n    for (int i = 0; i &lt; size; ++i)\n        sum += arr[i];\n\n    return sum;\n}\n</code></pre> main.cpp<pre><code>#include &lt;iostream&gt;\n\n#include \"calc.h\"\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    std::cout &lt;&lt; \"Sum of array: \" &lt;&lt; Sum(arr, 5) &lt;&lt; std::endl;\n}\n</code></pre> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15...4.0)\n\nproject(\n    CMakeExampleProject\n    VERSION 0.1.0\n    DESCRIPTION \"A simple CMake project\"\n    LANGUAGES CXX\n)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nset(\n    PROJECT_SOURCES\n    include/calc.h\n    source/calc.cpp\n    source/main.cpp\n)\n\nadd_executable(${PROJECT_NAME} ${PROJECT_SOURCES})\n\ntarget_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/include)\n</code></pre> output<pre><code>Sum of array: 15\n</code></pre> <p>Note</p> <p>CMake functions are case-insensitive, so you can write them as <code>SET()</code> or <code>set()</code>. However, the convention is to use snake_case, like <code>set()</code> or <code>add_executable()</code>.</p> <p>Info</p> <p>For versioning, it\u2019s best to follow a consistent versioning system such as Semantic Versioning. This approach uses a <code>MAJOR.MINOR.PATCH</code> format to clearly communicate the scope of changes:</p> <ul> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backwards-compatible manner</li> <li>PATCH version for backwards-compatible bug fixes</li> </ul> <p>Adopting semantic versioning helps maintain clarity and predictability as your project evolves.</p> <p>More info on Semantic Versioning can be found here: https://semver.org/</p> <ol> <li> <p><code>cmake_minimum_required()</code></p> <p>This is the first line in every root <code>CMakeLists.txt</code>. It sets the minimum required CMake version to 3.15 and supports any version up to (but not including) 4.0. The <code>...</code> syntax means \"compatible with versions from 3.15 up to 4.0.\" This range indicates the versions that were tested and should work correctly with your project.</p> </li> <li> <p><code>project()</code></p> <p>Defines the project name \"CMakeExampleProject\", version \"0.1.0\", description, and the programming languages used. CMake supports several languages including C, CXX (C++), Fortran, ASM, CUDA, CSharp, and Swift. Here we specify only CXX since it's a C++ project.</p> </li> <li> <p><code>set()</code></p> <p>Used to create or modify variables. Here, <code>CMAKE_CXX_STANDARD</code> is set to 20, which means the project uses C++20. <code>CMAKE_CXX_STANDARD_REQUIRED ON</code> means this version is mandatory \u2014 the compiler must support C++20 or higher.</p> </li> <li> <p><code>set(SOURCES ...)</code></p> <p>We define a variable named SOURCES listing all the source files and header files used in the project. Notice we also include header files even though they are not compiled directly. This is because CMake also informs IDEs and editors about which files belong to the project. Without listing headers here, tools like Visual Studio won't show them in the project explorer, or enable features like search and navigation properly.</p> </li> <li> <p><code>add_executable()</code></p> <p>This tells CMake to create an executable with the project name <code>${PROJECT_NAME}</code> (variable referencing the project name defined in <code>project()</code>) from the listed source files.</p> </li> <li> <p><code>target_include_directories()</code></p> <p>This sets the include paths for the compiler. Here, we add the include directory as a place to look for header files, so your source files can <code>#include \"log.h\"</code> without needing to write relative or absolute paths.</p> Access Modifier Used By Current Target Propagated to Dependent Targets Description <code>PRIVATE</code> Yes No The include path (or library link) is used only by this target. <code>PUBLIC</code> Yes Yes Used by this target and also passed on to targets that link to it. </li> </ol> <p>Info</p> <p>To add comments in <code>CMakeLists.txt</code>, simply put a <code>#</code> at the start of each line.</p> <p>Generating the build files with CMake and then building the project is straightforward. First, open a terminal inside the <code>build/</code> directory\u2014or navigate to it if terminal is already open. Once there, run these two simple commands.</p> <ol> <li> <p><code>cmake ..</code></p> <p>Generates the build files in the current directory based on the CMakeLists.txt in the parent folder.</p> </li> <li> <p><code>cmake --build .</code></p> <p>Builds the project using the generated build system in the current directory.</p> </li> </ol> <p>The build executable is defaultly located inside the <code>build/Debug/</code> directory.</p>"},{"location":"13%20Build%20Systems%20and%20CMake/#creating-a-library","title":"Creating a Library","text":"<p>When a project includes larger, reusable components\u2014such as a logging system or a configuration manager\u2014that are used across multiple parts of the codebase, it's a good practice to separate them into their own modules, commonly referred to as libraries. These libraries represent code that functions as a self-contained unit and typically doesn't change often during development. By isolating them, we avoid the need to recompile everything from scratch every time we build the project\u2014saving time and improving build efficiency.</p> <p>Note</p> <p>This doesn\u2019t apply to small helper functions or quick utilities. A library is typically for stable, well-defined code that doesn\u2019t change often. Once finished, we rarely touch it\u2014and that means we can save time during the build process, since CMake won't recompile it every time the main program changes.</p> <p>In CMake, we can define a library using the <code>add_library()</code> command, along with a few optional tweaks to control how it's built and linked.</p> <p>Let\u2019s build upon the file structure and code from the previous section by adding a library.</p> <pre><code>cmake-example-project/\n\u251c\u2500\u2500 build/\n\u251c\u2500\u2500 include/\n\u2502   \u2514\u2500\u2500 calc.h\n\u251c\u2500\u2500 libs/\n\u2502   \u2514\u2500\u2500 logger/\n\u2502       \u251c\u2500\u2500 logger.cpp\n\u2502       \u2514\u2500\u2500 logger.h\n\u251c\u2500\u2500 source/\n\u2502   \u251c\u2500\u2500 calc.cpp\n\u2502   \u2514\u2500\u2500 main.cpp\n\u2514\u2500\u2500 CMakeLists.txt\n</code></pre> logger.h<pre><code>#pragma once\n\nnamespace logger {\n    void LOG(const char* message);\n    void LOG(int value);\n}\n</code></pre> logger.cpp<pre><code>#include \"logger.h\"\n\n#include &lt;iostream&gt;\n\nvoid logger::LOG(const char* message) {\n    std::cout &lt;&lt; message &lt;&lt; std::endl;\n}\n\nvoid logger::LOG(int value) {\n    std::cout &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre> main.cpp<pre><code>#include \"calc.h\"\n#include \"logger.h\"\n\nint main() {\n    logger::LOG(\"Hello, World!\");\n\n    int arr[] = {1, 2, 3, 4, 5};\n    logger::LOG(Sum(arr, 5));\n}\n</code></pre> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15...4.0)\n\nproject(\n    CMakeExampleProject\n    VERSION 0.1.0\n    DESCRIPTION \"A simple CMake project\"\n    LANGUAGES CXX\n)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nadd_library(\n    logger STATIC\n    libs/logger/logger.cpp\n    libs/logger/logger.h\n)\n\ntarget_include_directories(logger PUBLIC libs/logger)\n\nset(\n    PROJECT_SOURCES\n    include/calc.h\n    source/calc.cpp\n    src/main.cpp\n)\n\nadd_executable(${PROJECT_NAME} ${PROJECT_SOURCES})\n\ntarget_include_directories(${PROJECT_NAME} PRIVATE include)\n\ntarget_link_libraries(${PROJECT_NAME} PRIVATE logger)\n</code></pre> output<pre><code>Hello, World!\n15\n</code></pre> <p>Note</p> <p>It's considered best practice to wrap each library in its own namespace. This helps avoid name clashes in the global namespace and makes it easier to identify which library a given function, class, or symbol comes from.</p> <p>Likewise, in larger (non-example) projects, the main project's source and header files (typically inside <code>src/</code> and <code>include/</code>) should also be wrapped inside a namespace matching the project's name.</p> <p>Before we dive into these details, let\u2019s clarify what a target means in CMake: a target is essentially a buildable entity\u2014this could be an executable, a static library, or a shared library. Targets are the central units CMake manages when configuring and building your project.</p> <ol> <li> <p><code>add_library()</code></p> <p>This command tells CMake to create a library target named logger. The keyword STATIC specifies the type of library\u2014we\u2019re building a static library.</p> Type Description Produces Typical Use Case <code>STATIC</code> Compiles source files into a static library. The code is embedded into the final executable. <code>.lib</code> (Windows) / <code>.a</code> (Unix) Useful for internal libraries or when distribution simplicity is preferred. <code>SHARED</code> Builds a dynamic/shared library. The code is loaded at runtime and kept separate from the executable. <code>.dll</code> (Windows) / <code>.so</code> (Linux) / <code>.dylib</code> (macOS) Ideal when sharing common code across multiple executables or applications. <code>INTERFACE</code> No library is actually compiled. Used for header-only libraries or metadata targets. None For header-only libraries or when only properties (e.g. include dirs) need to be propagated. </li> <li> <p><code>target_link_libraries()</code></p> <p>This tells CMake to link the logger library with your main project executable (${PROJECT_NAME} refers to the name defined in project() earlier).</p> <p>In other words, this line connects your main program to the logger library so the functions and classes defined in it can be used by the main program.</p> </li> </ol>"},{"location":"13%20Build%20Systems%20and%20CMake/#programming-in-cmake","title":"Programming in CMake","text":"<p>\ud83d\udea7 This chapter is under construction... \ud83d\udea7</p>"},{"location":"14%20Package%20Managers/","title":"14 Package Managers","text":"<p>\ud83d\udea7 This chapter is under construction... \ud83d\udea7</p>"},{"location":"15%20Final%20Project/","title":"15 Final Project","text":"<p>\ud83d\udea7 This chapter is under construction... \ud83d\udea7</p>"}]}